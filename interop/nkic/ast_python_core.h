// This file is automatically generated from KLR.
// Manual edits to this file will be overwritten.
#include "region.h"
#include "stdc.h"

// KLR.Python Abstract Syntax

struct Python_Pos {
  u32 lineno;
  u32 end_lineno;
  u32 col_offset;
  u32 end_col_offset;
};

struct Python_Const {
  enum Python_Const_Tag {
    Python_Const_NONE,
    Python_Const_BOOL,
    Python_Const_INT,
    Python_Const_FLOAT,
    Python_Const_STRING,
    Python_Const_ELLIPSIS
  } tag;
  union {
    struct Python_Const_bool {
      bool value;
    } b;
    struct Python_Const_int {
      i32 value;
    } i;
    struct Python_Const_float {
      f32 value;
    } f;
    struct Python_Const_string {
      const char *value;
    } s;
  };
};

enum Python_Ctx { Python_Ctx_Load, Python_Ctx_Store, Python_Ctx_Del };

enum Python_BoolOp { Python_BoolOp_Land, Python_BoolOp_Lor };

enum Python_CmpOp {
  Python_CmpOp_Eq,
  Python_CmpOp_Ne,
  Python_CmpOp_Lt,
  Python_CmpOp_Le,
  Python_CmpOp_Gt,
  Python_CmpOp_Ge,
  Python_CmpOp_Is,
  Python_CmpOp_IsNot,
  Python_CmpOp_IsIn,
  Python_CmpOp_NotIn
};

enum Python_UnaryOp {
  Python_UnaryOp_Invert,
  Python_UnaryOp_Not,
  Python_UnaryOp_Uadd,
  Python_UnaryOp_Usub
};

enum Python_BinOp {
  Python_BinOp_Add,
  Python_BinOp_Sub,
  Python_BinOp_Mul,
  Python_BinOp_Matmul,
  Python_BinOp_Div,
  Python_BinOp_Mod,
  Python_BinOp_Pow,
  Python_BinOp_Lshift,
  Python_BinOp_Rshift,
  Python_BinOp_Or,
  Python_BinOp_Xor,
  Python_BinOp_And,
  Python_BinOp_Floor
};

struct Python_Expr_ {
  enum Python_Expr_Tag {
    Python_Expr_CONST,
    Python_Expr_TENSOR,
    Python_Expr_NAME,
    Python_Expr_ATTR,
    Python_Expr_TUPLE,
    Python_Expr_LIST,
    Python_Expr_SUBSCRIPT,
    Python_Expr_SLICE,
    Python_Expr_BOOLOP,
    Python_Expr_BINOP,
    Python_Expr_UNARYOP,
    Python_Expr_COMPARE,
    Python_Expr_IFEXP,
    Python_Expr_CALL
  } tag;
  union {
    struct Python_Expr_const {
      struct Python_Const value;
    } c;
    struct Python_Expr_tensor {
      struct Python_Expr_List *shape;
      const char *dtype;
    } tensor;
    struct Python_Expr_name {
      const char *id;
      enum Python_Ctx ctx;
    } name;
    struct Python_Expr_attr {
      struct Python_Expr *value;
      const char *id;
      enum Python_Ctx ctx;
    } attr;
    struct Python_Expr_tuple {
      struct Python_Expr_List *xs;
      enum Python_Ctx ctx;
    } tuple;
    struct Python_Expr_list {
      struct Python_Expr_List *xs;
      enum Python_Ctx ctx;
    } list;
    struct Python_Expr_subscript {
      struct Python_Expr *tensor;
      struct Python_Expr *index;
      enum Python_Ctx ctx;
    } subscript;
    struct Python_Expr_slice {
      struct Python_Expr *l;
      struct Python_Expr *u;
      struct Python_Expr *step;
    } slice;
    struct Python_Expr_boolOp {
      enum Python_BoolOp op;
      struct Python_Expr_List *values;
    } boolOp;
    struct Python_Expr_binOp {
      enum Python_BinOp op;
      struct Python_Expr *left;
      struct Python_Expr *right;
    } binOp;
    struct Python_Expr_unaryOp {
      enum Python_UnaryOp op;
      struct Python_Expr *operand;
    } unaryOp;
    struct Python_Expr_compare {
      struct Python_Expr *left;
      enum Python_CmpOp_List *ops;
      struct Python_Expr_List *comparators;
    } compare;
    struct Python_Expr_ifExp {
      struct Python_Expr *test;
      struct Python_Expr *body;
      struct Python_Expr *orelse;
    } ifExp;
    struct Python_Expr_call {
      struct Python_Expr *f;
      struct Python_Expr_List *args;
      struct Python_Keyword_List *keywords;
    } call;
  };
};

struct Python_Expr {
  struct Python_Expr_ expr;
  struct Python_Pos pos;
};

struct Python_Keyword {
  const char *id;
  struct Python_Expr value;
  struct Python_Pos pos;
};

struct Python_Stmt_ {
  enum Python_Stmt_Tag {
    Python_Stmt_PASS,
    Python_Stmt_EXPR,
    Python_Stmt_ASSERT,
    Python_Stmt_RET,
    Python_Stmt_ASSIGN,
    Python_Stmt_AUGASSIGN,
    Python_Stmt_ANNASSIGN,
    Python_Stmt_IFSTM,
    Python_Stmt_FORLOOP,
    Python_Stmt_BREAKLOOP,
    Python_Stmt_CONTINUELOOP
  } tag;
  union {
    struct Python_Stmt_expr {
      struct Python_Expr e;
    } expr;
    struct Python_Stmt_assert {
      struct Python_Expr e;
    } assert;
    struct Python_Stmt_ret {
      struct Python_Expr e;
    } ret;
    struct Python_Stmt_assign {
      struct Python_Expr_List *xs;
      struct Python_Expr e;
    } assign;
    struct Python_Stmt_augAssign {
      struct Python_Expr x;
      enum Python_BinOp op;
      struct Python_Expr e;
    } augAssign;
    struct Python_Stmt_annAssign {
      struct Python_Expr x;
      struct Python_Expr annotation;
      struct Python_Expr *value;
    } annAssign;
    struct Python_Stmt_ifStm {
      struct Python_Expr e;
      struct Python_Stmt_List *thn;
      struct Python_Stmt_List *els;
    } ifStm;
    struct Python_Stmt_forLoop {
      struct Python_Expr x;
      struct Python_Expr iter;
      struct Python_Stmt_List *body;
      struct Python_Stmt_List *orelse;
    } forLoop;
  };
};

struct Python_Stmt {
  struct Python_Stmt_ stmt;
  struct Python_Pos pos;
};

struct Python_Args {
  struct String_List *posonlyargs;
  struct String_List *args;
  struct Python_Expr_List *defaults;
  const char *vararg;
  struct String_List *kwonlyargs;
  struct Python_Keyword_List *kw_defaults;
  const char *kwarg;
};

struct Python_Fun {
  const char *name;
  u32 line;
  const char *source;
  struct Python_Args args;
  struct Python_Stmt_List *body;
};

struct Python_Kernel {
  const char *entry;
  struct Python_Fun_List *funcs;
  struct Python_Expr_List *args;
  struct Python_Keyword_List *kwargs;
  struct Python_Keyword_List *globals;
  struct String_List *undefinedSymbols;
};

struct Python_Expr_List {
  struct Python_Expr_List *next;
  struct Python_Expr Python_expr;
};

struct Python_Keyword_List {
  struct Python_Keyword_List *next;
  struct Python_Keyword Python_keyword;
};

struct Python_Stmt_List {
  struct Python_Stmt_List *next;
  struct Python_Stmt Python_stmt;
};

struct Python_Fun_List {
  struct Python_Fun_List *next;
  struct Python_Fun Python_fun;
};

static inline struct Python_Expr *mkPython_Expr_const(struct Python_Const value,
                                                      struct region *region) {
  struct Python_Expr *res = region_alloc(region, sizeof(*res));
  if (!res)
    return NULL;
  res->expr.tag = Python_Expr_CONST;
  res->expr.c.value = value;
  return res;
}

static inline struct Python_Expr *
mkPython_Expr_tensor(struct Python_Expr_List *shape, const char *dtype,
                     struct region *region) {
  struct Python_Expr *res = region_alloc(region, sizeof(*res));
  if (!res)
    return NULL;
  res->expr.tag = Python_Expr_TENSOR;
  res->expr.tensor.shape = shape;
  res->expr.tensor.dtype = dtype;
  return res;
}

static inline struct Python_Expr *
mkPython_Expr_name(const char *id, enum Python_Ctx ctx, struct region *region) {
  struct Python_Expr *res = region_alloc(region, sizeof(*res));
  if (!res)
    return NULL;
  res->expr.tag = Python_Expr_NAME;
  res->expr.name.id = id;
  res->expr.name.ctx = ctx;
  return res;
}

static inline struct Python_Expr *mkPython_Expr_attr(struct Python_Expr *value,
                                                     const char *id,
                                                     enum Python_Ctx ctx,
                                                     struct region *region) {
  struct Python_Expr *res = region_alloc(region, sizeof(*res));
  if (!res)
    return NULL;
  res->expr.tag = Python_Expr_ATTR;
  res->expr.attr.value = value;
  res->expr.attr.id = id;
  res->expr.attr.ctx = ctx;
  return res;
}

static inline struct Python_Expr *
mkPython_Expr_tuple(struct Python_Expr_List *xs, enum Python_Ctx ctx,
                    struct region *region) {
  struct Python_Expr *res = region_alloc(region, sizeof(*res));
  if (!res)
    return NULL;
  res->expr.tag = Python_Expr_TUPLE;
  res->expr.tuple.xs = xs;
  res->expr.tuple.ctx = ctx;
  return res;
}

static inline struct Python_Expr *
mkPython_Expr_list(struct Python_Expr_List *xs, enum Python_Ctx ctx,
                   struct region *region) {
  struct Python_Expr *res = region_alloc(region, sizeof(*res));
  if (!res)
    return NULL;
  res->expr.tag = Python_Expr_LIST;
  res->expr.list.xs = xs;
  res->expr.list.ctx = ctx;
  return res;
}

static inline struct Python_Expr *
mkPython_Expr_subscript(struct Python_Expr *tensor, struct Python_Expr *index,
                        enum Python_Ctx ctx, struct region *region) {
  struct Python_Expr *res = region_alloc(region, sizeof(*res));
  if (!res)
    return NULL;
  res->expr.tag = Python_Expr_SUBSCRIPT;
  res->expr.subscript.tensor = tensor;
  res->expr.subscript.index = index;
  res->expr.subscript.ctx = ctx;
  return res;
}

static inline struct Python_Expr *mkPython_Expr_slice(struct Python_Expr *l,
                                                      struct Python_Expr *u,
                                                      struct Python_Expr *step,
                                                      struct region *region) {
  struct Python_Expr *res = region_alloc(region, sizeof(*res));
  if (!res)
    return NULL;
  res->expr.tag = Python_Expr_SLICE;
  res->expr.slice.l = l;
  res->expr.slice.u = u;
  res->expr.slice.step = step;
  return res;
}

static inline struct Python_Expr *
mkPython_Expr_boolOp(enum Python_BoolOp op, struct Python_Expr_List *values,
                     struct region *region) {
  struct Python_Expr *res = region_alloc(region, sizeof(*res));
  if (!res)
    return NULL;
  res->expr.tag = Python_Expr_BOOLOP;
  res->expr.boolOp.op = op;
  res->expr.boolOp.values = values;
  return res;
}

static inline struct Python_Expr *mkPython_Expr_binOp(enum Python_BinOp op,
                                                      struct Python_Expr *left,
                                                      struct Python_Expr *right,
                                                      struct region *region) {
  struct Python_Expr *res = region_alloc(region, sizeof(*res));
  if (!res)
    return NULL;
  res->expr.tag = Python_Expr_BINOP;
  res->expr.binOp.op = op;
  res->expr.binOp.left = left;
  res->expr.binOp.right = right;
  return res;
}

static inline struct Python_Expr *
mkPython_Expr_unaryOp(enum Python_UnaryOp op, struct Python_Expr *operand,
                      struct region *region) {
  struct Python_Expr *res = region_alloc(region, sizeof(*res));
  if (!res)
    return NULL;
  res->expr.tag = Python_Expr_UNARYOP;
  res->expr.unaryOp.op = op;
  res->expr.unaryOp.operand = operand;
  return res;
}

static inline struct Python_Expr *
mkPython_Expr_compare(struct Python_Expr *left, enum Python_CmpOp_List *ops,
                      struct Python_Expr_List *comparators,
                      struct region *region) {
  struct Python_Expr *res = region_alloc(region, sizeof(*res));
  if (!res)
    return NULL;
  res->expr.tag = Python_Expr_COMPARE;
  res->expr.compare.left = left;
  res->expr.compare.ops = ops;
  res->expr.compare.comparators = comparators;
  return res;
}

static inline struct Python_Expr *
mkPython_Expr_ifExp(struct Python_Expr *test, struct Python_Expr *body,
                    struct Python_Expr *orelse, struct region *region) {
  struct Python_Expr *res = region_alloc(region, sizeof(*res));
  if (!res)
    return NULL;
  res->expr.tag = Python_Expr_IFEXP;
  res->expr.ifExp.test = test;
  res->expr.ifExp.body = body;
  res->expr.ifExp.orelse = orelse;
  return res;
}

static inline struct Python_Expr *
mkPython_Expr_call(struct Python_Expr *f, struct Python_Expr_List *args,
                   struct Python_Keyword_List *keywords,
                   struct region *region) {
  struct Python_Expr *res = region_alloc(region, sizeof(*res));
  if (!res)
    return NULL;
  res->expr.tag = Python_Expr_CALL;
  res->expr.call.f = f;
  res->expr.call.args = args;
  res->expr.call.keywords = keywords;
  return res;
}

static inline struct Python_Stmt *mkPython_Stmt_pass(struct region *region) {
  struct Python_Stmt *res = region_alloc(region, sizeof(*res));
  if (!res)
    return NULL;
  res->stmt.tag = Python_Stmt_PASS;
  return res;
}

static inline struct Python_Stmt *mkPython_Stmt_expr(struct Python_Expr e,
                                                     struct region *region) {
  struct Python_Stmt *res = region_alloc(region, sizeof(*res));
  if (!res)
    return NULL;
  res->stmt.tag = Python_Stmt_EXPR;
  res->stmt.expr.e = e;
  return res;
}

static inline struct Python_Stmt *mkPython_Stmt_assert(struct Python_Expr e,
                                                       struct region *region) {
  struct Python_Stmt *res = region_alloc(region, sizeof(*res));
  if (!res)
    return NULL;
  res->stmt.tag = Python_Stmt_ASSERT;
  res->stmt.assert.e = e;
  return res;
}

static inline struct Python_Stmt *mkPython_Stmt_ret(struct Python_Expr e,
                                                    struct region *region) {
  struct Python_Stmt *res = region_alloc(region, sizeof(*res));
  if (!res)
    return NULL;
  res->stmt.tag = Python_Stmt_RET;
  res->stmt.ret.e = e;
  return res;
}

static inline struct Python_Stmt *
mkPython_Stmt_assign(struct Python_Expr_List *xs, struct Python_Expr e,
                     struct region *region) {
  struct Python_Stmt *res = region_alloc(region, sizeof(*res));
  if (!res)
    return NULL;
  res->stmt.tag = Python_Stmt_ASSIGN;
  res->stmt.assign.xs = xs;
  res->stmt.assign.e = e;
  return res;
}

static inline struct Python_Stmt *
mkPython_Stmt_augAssign(struct Python_Expr x, enum Python_BinOp op,
                        struct Python_Expr e, struct region *region) {
  struct Python_Stmt *res = region_alloc(region, sizeof(*res));
  if (!res)
    return NULL;
  res->stmt.tag = Python_Stmt_AUGASSIGN;
  res->stmt.augAssign.x = x;
  res->stmt.augAssign.op = op;
  res->stmt.augAssign.e = e;
  return res;
}

static inline struct Python_Stmt *
mkPython_Stmt_annAssign(struct Python_Expr x, struct Python_Expr annotation,
                        struct Python_Expr *value, struct region *region) {
  struct Python_Stmt *res = region_alloc(region, sizeof(*res));
  if (!res)
    return NULL;
  res->stmt.tag = Python_Stmt_ANNASSIGN;
  res->stmt.annAssign.x = x;
  res->stmt.annAssign.annotation = annotation;
  res->stmt.annAssign.value = value;
  return res;
}

static inline struct Python_Stmt *
mkPython_Stmt_ifStm(struct Python_Expr e, struct Python_Stmt_List *thn,
                    struct Python_Stmt_List *els, struct region *region) {
  struct Python_Stmt *res = region_alloc(region, sizeof(*res));
  if (!res)
    return NULL;
  res->stmt.tag = Python_Stmt_IFSTM;
  res->stmt.ifStm.e = e;
  res->stmt.ifStm.thn = thn;
  res->stmt.ifStm.els = els;
  return res;
}

static inline struct Python_Stmt *
mkPython_Stmt_forLoop(struct Python_Expr x, struct Python_Expr iter,
                      struct Python_Stmt_List *body,
                      struct Python_Stmt_List *orelse, struct region *region) {
  struct Python_Stmt *res = region_alloc(region, sizeof(*res));
  if (!res)
    return NULL;
  res->stmt.tag = Python_Stmt_FORLOOP;
  res->stmt.forLoop.x = x;
  res->stmt.forLoop.iter = iter;
  res->stmt.forLoop.body = body;
  res->stmt.forLoop.orelse = orelse;
  return res;
}

static inline struct Python_Stmt *
mkPython_Stmt_breakLoop(struct region *region) {
  struct Python_Stmt *res = region_alloc(region, sizeof(*res));
  if (!res)
    return NULL;
  res->stmt.tag = Python_Stmt_BREAKLOOP;
  return res;
}

static inline struct Python_Stmt *
mkPython_Stmt_continueLoop(struct region *region) {
  struct Python_Stmt *res = region_alloc(region, sizeof(*res));
  if (!res)
    return NULL;
  res->stmt.tag = Python_Stmt_CONTINUELOOP;
  return res;
}
