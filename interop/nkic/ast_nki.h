// This file is automatically generated from KLR.
// Manual edits to this file will be overwritten.
#include "region.h"
#include "stdc.h"

// KLR.NKI Abstract Syntax

struct NKI_Pos {
  u32 line;
  u32 column;
};

struct NKI_Value {
  enum NKI_Value_Tag {
    NKI_Value_NONE,
    NKI_Value_BOOL,
    NKI_Value_INT,
    NKI_Value_FLOAT,
    NKI_Value_STRING,
    NKI_Value_ELLIPSIS,
    NKI_Value_TENSOR
  } tag;
  union {
    struct NKI_Value_bool {
      bool value;
    } b;
    struct NKI_Value_int {
      i32 value;
    } i;
    struct NKI_Value_float {
      f32 value;
    } f;
    struct NKI_Value_string {
      const char *value;
    } s;
    struct NKI_Value_tensor {
      struct Nat_List *shape;
      const char *dtype;
    } tensor;
  };
};

enum NKI_BinOp {
  NKI_BinOp_Land,
  NKI_BinOp_Lor,
  NKI_BinOp_Eq,
  NKI_BinOp_Ne,
  NKI_BinOp_Lt,
  NKI_BinOp_Le,
  NKI_BinOp_Gt,
  NKI_BinOp_Ge,
  NKI_BinOp_Add,
  NKI_BinOp_Sub,
  NKI_BinOp_Mul,
  NKI_BinOp_Div,
  NKI_BinOp_Mod,
  NKI_BinOp_Pow,
  NKI_BinOp_Floor,
  NKI_BinOp_Lshift,
  NKI_BinOp_Rshift,
  NKI_BinOp_Or,
  NKI_BinOp_Xor,
  NKI_BinOp_And
};

struct NKI_Expr_ {
  enum NKI_Expr_Tag {
    NKI_Expr_VALUE,
    NKI_Expr_VAR,
    NKI_Expr_PROJ,
    NKI_Expr_TUPLE,
    NKI_Expr_ACCESS,
    NKI_Expr_BINOP,
    NKI_Expr_IFEXP,
    NKI_Expr_CALL
  } tag;
  union {
    struct NKI_Expr_value {
      struct NKI_Value *value;
    } value;
    struct NKI_Expr_var {
      const char *name;
    } var;
    struct NKI_Expr_proj {
      struct NKI_Expr *expr;
      const char *name;
    } proj;
    struct NKI_Expr_tuple {
      struct NKI_Expr_List *elements;
    } tuple;
    struct NKI_Expr_access {
      struct NKI_Expr *expr;
      struct NKI_Index_List *indices;
    } access;
    struct NKI_Expr_binOp {
      enum NKI_BinOp op;
      struct NKI_Expr *left;
      struct NKI_Expr *right;
    } binOp;
    struct NKI_Expr_ifExp {
      struct NKI_Expr *test;
      struct NKI_Expr *body;
      struct NKI_Expr *orelse;
    } ifExp;
    struct NKI_Expr_call {
      struct NKI_Expr *f;
      struct NKI_Expr_List *args;
      struct NKI_Keyword_List *keywords;
    } call;
  };
};

struct NKI_Expr {
  struct NKI_Expr_ *expr;
  struct NKI_Pos *pos;
};

struct NKI_Index {
  enum NKI_Index_Tag { NKI_Index_COORD, NKI_Index_SLICE } tag;
  union {
    struct NKI_Index_coord {
      struct NKI_Expr *i;
    } coord;
    struct NKI_Index_slice {
      struct NKI_Expr *l;
      struct NKI_Expr *u;
      struct NKI_Expr *step;
    } slice;
  };
};

struct NKI_Keyword {
  const char *name;
  struct NKI_Expr *expr;
};

struct NKI_Stmt_ {
  enum NKI_Stmt_Tag {
    NKI_Stmt_EXPR,
    NKI_Stmt_ASSERT,
    NKI_Stmt_RET,
    NKI_Stmt_ASSIGN,
    NKI_Stmt_IFSTM,
    NKI_Stmt_FORLOOP,
    NKI_Stmt_BREAKLOOP,
    NKI_Stmt_CONTINUELOOP
  } tag;
  union {
    struct NKI_Stmt_expr {
      struct NKI_Expr *e;
    } expr;
    struct NKI_Stmt_assert {
      struct NKI_Expr *e;
    } assert;
    struct NKI_Stmt_ret {
      struct NKI_Expr *e;
    } ret;
    struct NKI_Stmt_assign {
      struct NKI_Expr *x;
      struct NKI_Expr *ty;
      struct NKI_Expr *e;
    } assign;
    struct NKI_Stmt_ifStm {
      struct NKI_Expr *e;
      struct NKI_Stmt_List *thn;
      struct NKI_Stmt_List *els;
    } ifStm;
    struct NKI_Stmt_forLoop {
      struct NKI_Expr *x;
      struct NKI_Expr *iter;
      struct NKI_Stmt_List *body;
    } forLoop;
  };
};

struct NKI_Stmt {
  struct NKI_Stmt_ *stmt;
  struct NKI_Pos *pos;
};

struct NKI_Param {
  const char *name;
  struct NKI_Expr *dflt;
};

struct NKI_Fun {
  const char *name;
  const char *file;
  u32 line;
  struct NKI_Stmt_List *body;
  struct NKI_Param_List *args;
};

struct NKI_Arg {
  const char *name;
  struct NKI_Expr *value;
};

struct NKI_Kernel {
  const char *entry;
  struct NKI_Fun_List *funs;
  struct NKI_Arg_List *args;
  struct NKI_Arg_List *globals;
};

struct String_List {
  struct String_List *next;
  const char *string;
};

struct NKI_Expr_List {
  struct NKI_Expr_List *next;
  struct NKI_Expr *expr;
};

struct NKI_Index_List {
  struct NKI_Index_List *next;
  struct NKI_Index *index;
};

struct NKI_Keyword_List {
  struct NKI_Keyword_List *next;
  struct NKI_Keyword *keyword;
};

struct NKI_Stmt_List {
  struct NKI_Stmt_List *next;
  struct NKI_Stmt *stmt;
};

struct NKI_Fun_List {
  struct NKI_Fun_List *next;
  struct NKI_Fun *fun;
};

static inline struct NKI_Expr *mkNKI_Expr_value(struct NKI_Value *value,
                                                struct region *region) {
  struct NKI_Expr *res = region_alloc(region, sizeof(*res));
  if (!res)
    return NULL;
  res->expr->tag = NKI_Expr_VALUE;
  res->expr->value.value = value;
  return res;
}

static inline struct NKI_Expr *mkNKI_Expr_var(const char *name,
                                              struct region *region) {
  struct NKI_Expr *res = region_alloc(region, sizeof(*res));
  if (!res)
    return NULL;
  res->expr->tag = NKI_Expr_VAR;
  res->expr->var.name = name;
  return res;
}

static inline struct NKI_Expr *mkNKI_Expr_proj(struct NKI_Expr *expr,
                                               const char *name,
                                               struct region *region) {
  struct NKI_Expr *res = region_alloc(region, sizeof(*res));
  if (!res)
    return NULL;
  res->expr->tag = NKI_Expr_PROJ;
  res->expr->proj.expr = expr;
  res->expr->proj.name = name;
  return res;
}

static inline struct NKI_Expr *mkNKI_Expr_tuple(struct NKI_Expr_List *elements,
                                                struct region *region) {
  struct NKI_Expr *res = region_alloc(region, sizeof(*res));
  if (!res)
    return NULL;
  res->expr->tag = NKI_Expr_TUPLE;
  res->expr->tuple.elements = elements;
  return res;
}

static inline struct NKI_Expr *mkNKI_Expr_access(struct NKI_Expr *expr,
                                                 struct NKI_Index_List *indices,
                                                 struct region *region) {
  struct NKI_Expr *res = region_alloc(region, sizeof(*res));
  if (!res)
    return NULL;
  res->expr->tag = NKI_Expr_ACCESS;
  res->expr->access.expr = expr;
  res->expr->access.indices = indices;
  return res;
}

static inline struct NKI_Expr *mkNKI_Expr_binOp(enum NKI_BinOp op,
                                                struct NKI_Expr *left,
                                                struct NKI_Expr *right,
                                                struct region *region) {
  struct NKI_Expr *res = region_alloc(region, sizeof(*res));
  if (!res)
    return NULL;
  res->expr->tag = NKI_Expr_BINOP;
  res->expr->binOp.op = op;
  res->expr->binOp.left = left;
  res->expr->binOp.right = right;
  return res;
}

static inline struct NKI_Expr *mkNKI_Expr_ifExp(struct NKI_Expr *test,
                                                struct NKI_Expr *body,
                                                struct NKI_Expr *orelse,
                                                struct region *region) {
  struct NKI_Expr *res = region_alloc(region, sizeof(*res));
  if (!res)
    return NULL;
  res->expr->tag = NKI_Expr_IFEXP;
  res->expr->ifExp.test = test;
  res->expr->ifExp.body = body;
  res->expr->ifExp.orelse = orelse;
  return res;
}

static inline struct NKI_Expr *
mkNKI_Expr_call(struct NKI_Expr *f, struct NKI_Expr_List *args,
                struct NKI_Keyword_List *keywords, struct region *region) {
  struct NKI_Expr *res = region_alloc(region, sizeof(*res));
  if (!res)
    return NULL;
  res->expr->tag = NKI_Expr_CALL;
  res->expr->call.f = f;
  res->expr->call.args = args;
  res->expr->call.keywords = keywords;
  return res;
}

static inline struct NKI_Stmt *mkNKI_Stmt_expr(struct NKI_Expr *e,
                                               struct region *region) {
  struct NKI_Stmt *res = region_alloc(region, sizeof(*res));
  if (!res)
    return NULL;
  res->stmt->tag = NKI_Stmt_EXPR;
  res->stmt->expr.e = e;
  return res;
}

static inline struct NKI_Stmt *mkNKI_Stmt_assert(struct NKI_Expr *e,
                                                 struct region *region) {
  struct NKI_Stmt *res = region_alloc(region, sizeof(*res));
  if (!res)
    return NULL;
  res->stmt->tag = NKI_Stmt_ASSERT;
  res->stmt->assert.e = e;
  return res;
}

static inline struct NKI_Stmt *mkNKI_Stmt_ret(struct NKI_Expr *e,
                                              struct region *region) {
  struct NKI_Stmt *res = region_alloc(region, sizeof(*res));
  if (!res)
    return NULL;
  res->stmt->tag = NKI_Stmt_RET;
  res->stmt->ret.e = e;
  return res;
}

static inline struct NKI_Stmt *mkNKI_Stmt_assign(struct NKI_Expr *x,
                                                 struct NKI_Expr *ty,
                                                 struct NKI_Expr *e,
                                                 struct region *region) {
  struct NKI_Stmt *res = region_alloc(region, sizeof(*res));
  if (!res)
    return NULL;
  res->stmt->tag = NKI_Stmt_ASSIGN;
  res->stmt->assign.x = x;
  res->stmt->assign.ty = ty;
  res->stmt->assign.e = e;
  return res;
}

static inline struct NKI_Stmt *mkNKI_Stmt_ifStm(struct NKI_Expr *e,
                                                struct NKI_Stmt_List *thn,
                                                struct NKI_Stmt_List *els,
                                                struct region *region) {
  struct NKI_Stmt *res = region_alloc(region, sizeof(*res));
  if (!res)
    return NULL;
  res->stmt->tag = NKI_Stmt_IFSTM;
  res->stmt->ifStm.e = e;
  res->stmt->ifStm.thn = thn;
  res->stmt->ifStm.els = els;
  return res;
}

static inline struct NKI_Stmt *mkNKI_Stmt_forLoop(struct NKI_Expr *x,
                                                  struct NKI_Expr *iter,
                                                  struct NKI_Stmt_List *body,
                                                  struct region *region) {
  struct NKI_Stmt *res = region_alloc(region, sizeof(*res));
  if (!res)
    return NULL;
  res->stmt->tag = NKI_Stmt_FORLOOP;
  res->stmt->forLoop.x = x;
  res->stmt->forLoop.iter = iter;
  res->stmt->forLoop.body = body;
  return res;
}

static inline struct NKI_Stmt *mkNKI_Stmt_breakLoop(struct region *region) {
  struct NKI_Stmt *res = region_alloc(region, sizeof(*res));
  if (!res)
    return NULL;
  res->stmt->tag = NKI_Stmt_BREAKLOOP;
  return res;
}

static inline struct NKI_Stmt *mkNKI_Stmt_continueLoop(struct region *region) {
  struct NKI_Stmt *res = region_alloc(region, sizeof(*res));
  if (!res)
    return NULL;
  res->stmt->tag = NKI_Stmt_CONTINUELOOP;
  return res;
}
