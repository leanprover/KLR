/*
Copyright (c) 2025 Amazon.com, Inc. or its affiliates. All Rights Reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Written by the KLR Contributors (https://github.com/leanprover/KLR)
*/

// This file is automatically generated from KLR.
// Manual edits to this file will be overwritten.

#include "klir_common.hpp"
#include "klir_ast.hpp"
#include "klir_pretty_print.hpp"
#include <sstream>

namespace klr {

// Pretty Print functions for KLR.Core Abstract Syntax

std::string to_string(Pos &PosInstance) {
  std::string result;
  result += "Pos(";
  result += "line=";
  result += std::to_string(PosInstance.line);
  result += ", ";
  result += "column=";
  result += std::to_string(PosInstance.column);
  result += ", ";
  result += "lineEnd=";
  if (PosInstance.lineEnd.has_value()) {
    result += std::to_string(PosInstance.lineEnd.value());
  } else {
    result += "None";
  }
  result += ", ";
  result += "columnEnd=";
  if (PosInstance.columnEnd.has_value()) {
    result += std::to_string(PosInstance.columnEnd.value());
  } else {
    result += "None";
  }
  result += ", ";
  result += "filename=";
  if (PosInstance.filename.has_value()) {
    result += PosInstance.filename.value();
  } else {
    result += "None";
  }
  result += ")";
  return result;
};

std::string
to_string(ImmediateRegisterWrapper &ImmediateRegisterWrapperInstance) {
  std::string result;
  result += "ImmediateRegisterWrapper(";
  result += "reg=";
  result += std::to_string(ImmediateRegisterWrapperInstance.reg);
  result += ")";
  return result;
};
std::string
to_string(ImmediatePointerWrapper &ImmediatePointerWrapperInstance) {
  std::string result;
  result += "ImmediatePointerWrapper(";
  result += ")";
  return result;
};
std::string to_string(ImmediateIntWrapper &ImmediateIntWrapperInstance) {
  std::string result;
  result += "ImmediateIntWrapper(";
  result += "i=";
  result += std::to_string(ImmediateIntWrapperInstance.i);
  result += ")";
  return result;
};
std::string to_string(ImmediateFloatWrapper &ImmediateFloatWrapperInstance) {
  std::string result;
  result += "ImmediateFloatWrapper(";
  result += "f=";
  result += std::to_string(ImmediateFloatWrapperInstance.f);
  result += ")";
  return result;
};
std::string to_string(Immediate &ImmediateInstance) {
  switch (ImmediateInstance.tag) {
  case (Immediate::Tag::reg): {
    ImmediateRegisterWrapper &derivedRef =
        static_cast<ImmediateRegisterWrapper &>(ImmediateInstance);
    return to_string(derivedRef);
  }
  case (Immediate::Tag::pointer): {
    ImmediatePointerWrapper &derivedRef =
        static_cast<ImmediatePointerWrapper &>(ImmediateInstance);
    return to_string(derivedRef);
  }
  case (Immediate::Tag::int32): {
    ImmediateIntWrapper &derivedRef =
        static_cast<ImmediateIntWrapper &>(ImmediateInstance);
    return to_string(derivedRef);
  }
  case (Immediate::Tag::float32): {
    ImmediateFloatWrapper &derivedRef =
        static_cast<ImmediateFloatWrapper &>(ImmediateInstance);
    return to_string(derivedRef);
  }
  default:
    return "UNABLE TO PRINT";
  }
};

std::string to_string(Memory &MemoryInstance) {
  switch (MemoryInstance) {
  case Memory::hbm:
    return "hbm";
    break;
  case Memory::sbuf:
    return "sbuf";
    break;
  case Memory::psum:
    return "psum";
    break;
  case Memory::reg:
    return "reg";
    break;
  case Memory::shared_hbm:
    return "shared_hbm";
    break;
  case Memory::private_hbm:
    return "private_hbm";
    break;
  default:
    return "UNABLE TO PRINT";
  }
};

std::string to_string(Dtype &DtypeInstance) {
  switch (DtypeInstance) {
  case Dtype::bfloat16:
    return "bfloat16";
    break;
  case Dtype::float8e3:
    return "float8e3";
    break;
  case Dtype::float8e4:
    return "float8e4";
    break;
  case Dtype::float8e5:
    return "float8e5";
    break;
  case Dtype::float16:
    return "float16";
    break;
  case Dtype::float32:
    return "float32";
    break;
  case Dtype::float32r:
    return "float32r";
    break;
  case Dtype::int8:
    return "int8";
    break;
  case Dtype::int16:
    return "int16";
    break;
  case Dtype::int64:
    return "int64";
    break;
  case Dtype::int32:
    return "int32";
    break;
  case Dtype::uint8:
    return "uint8";
    break;
  case Dtype::uint16:
    return "uint16";
    break;
  case Dtype::uint32:
    return "uint32";
    break;
  case Dtype::uint64:
    return "uint64";
    break;
  case Dtype::float8_e4m3:
    return "float8_e4m3";
    break;
  case Dtype::float8_e4m3fn:
    return "float8_e4m3fn";
    break;
  case Dtype::float8_e5m2_x4:
    return "float8_e5m2_x4";
    break;
  case Dtype::float8_e4m3fn_x4:
    return "float8_e4m3fn_x4";
    break;
  case Dtype::float4_e2m1fn_x4:
    return "float4_e2m1fn_x4";
    break;
  default:
    return "UNABLE TO PRINT";
  }
};

std::string to_string(Shape &ShapeInstance) {
  std::string result;
  result += "Shape(";
  result += "parDim=";
  result += std::to_string(ShapeInstance.parDim);
  result += ", ";
  result += "freeDims=";
  {
    size_t i1 = 0;
    for (Nat printListLoopItem1 : ShapeInstance.freeDims) {
      result += std::to_string(printListLoopItem1);
      i1++;
      if (i1 < ShapeInstance.freeDims.size())
        result += ", ";
    }
  }
  result += ")";
  return result;
};

std::string to_string(Address &AddressInstance) {
  std::string result;
  result += "Address(";
  result += "name=";
  result += AddressInstance.name;
  result += ", ";
  result += "memory=";
  result += to_string(AddressInstance.memory); // mapped from enum
  result += ", ";
  result += "parSize=";
  result += std::to_string(AddressInstance.parSize);
  result += ", ";
  result += "freeSize=";
  result += std::to_string(AddressInstance.freeSize);
  result += ", ";
  result += "parOffset=";
  if (AddressInstance.parOffset.has_value()) {
    result += std::to_string(AddressInstance.parOffset.value());
  } else {
    result += "None";
  }
  result += ", ";
  result += "freeOffset=";
  if (AddressInstance.freeOffset.has_value()) {
    result += std::to_string(AddressInstance.freeOffset.value());
  } else {
    result += "None";
  }
  result += ", ";
  result += "isShared=";
  result += std::to_string(AddressInstance.isShared);
  result += ")";
  return result;
};

std::string to_string(TensorName &TensorNameInstance) {
  std::string result;
  result += "TensorName(";
  result += "name=";
  result += TensorNameInstance.name;
  result += ", ";
  result += "dtype=";
  result += to_string(TensorNameInstance.dtype); // mapped from enum
  result += ", ";
  result += "shape=";
  result += to_string(*(TensorNameInstance.shape.get()));
  result += ", ";
  result += "address=";
  result += to_string(*(TensorNameInstance.address.get()));
  result += ", ";
  result += "freeElements=";
  result += std::to_string(TensorNameInstance.freeElements);
  result += ", ";
  result += "parWF=";
  result += ", ";
  result += "freeWF=";
  result += ", ";
  result += "addressRotation=";
  result += std::to_string(TensorNameInstance.addressRotation);
  result += ")";
  return result;
};

std::string to_string(Slice &SliceInstance) {
  std::string result;
  result += "Slice(";
  result += "l=";
  result += std::to_string(SliceInstance.l);
  result += ", ";
  result += "u=";
  result += std::to_string(SliceInstance.u);
  result += ", ";
  result += "step=";
  result += std::to_string(SliceInstance.step);
  result += ", ";
  result += "wf=";
  result += ")";
  return result;
};

std::string to_string(IndexCoordWrapper &IndexCoordWrapperInstance) {
  std::string result;
  result += "IndexCoordWrapper(";
  result += "e=";
  result += std::to_string(IndexCoordWrapperInstance.e);
  result += ")";
  return result;
};
std::string to_string(IndexSliceWrapper &IndexSliceWrapperInstance) {
  std::string result;
  result += "IndexSliceWrapper(";
  result += "slice=";
  result += to_string(*(IndexSliceWrapperInstance.slice.get()));
  result += ")";
  return result;
};
std::string to_string(Index &IndexInstance) {
  switch (IndexInstance.tag) {
  case (Index::Tag::coord): {
    IndexCoordWrapper &derivedRef =
        static_cast<IndexCoordWrapper &>(IndexInstance);
    return to_string(derivedRef);
  }
  case (Index::Tag::slice): {
    IndexSliceWrapper &derivedRef =
        static_cast<IndexSliceWrapper &>(IndexInstance);
    return to_string(derivedRef);
  }
  default:
    return "UNABLE TO PRINT";
  }
};

std::string to_string(AccessBasic &AccessBasicInstance) {
  std::string result;
  result += "AccessBasic(";
  result += "tensor=";
  result += to_string(*(AccessBasicInstance.tensor.get()));
  result += ", ";
  result += "indexes=";
  {
    size_t i1 = 0;
    for (Ptr<Index> printListLoopItem1 : AccessBasicInstance.indexes) {
      result += to_string(*(printListLoopItem1.get()));
      i1++;
      if (i1 < AccessBasicInstance.indexes.size())
        result += ", ";
    }
  }
  result += ", ";
  result += "lenWF=";
  result += ")";
  return result;
};

std::string to_string(APPair &APPairInstance) {
  std::string result;
  result += "APPair(";
  result += "step=";
  result += std::to_string(APPairInstance.step);
  result += ", ";
  result += "num=";
  result += std::to_string(APPairInstance.num);
  result += ", ";
  result += "offset=";
  result += std::to_string(APPairInstance.offset);
  result += ")";
  return result;
};

std::string to_string(AccessPattern &AccessPatternInstance) {
  std::string result;
  result += "AccessPattern(";
  result += "tensor=";
  result += to_string(*(AccessPatternInstance.tensor.get()));
  result += ", ";
  result += "parNum=";
  result += std::to_string(AccessPatternInstance.parNum);
  result += ", ";
  result += "pattern=";
  {
    size_t i1 = 0;
    for (Ptr<APPair> printListLoopItem1 : AccessPatternInstance.pattern) {
      result += to_string(*(printListLoopItem1.get()));
      i1++;
      if (i1 < AccessPatternInstance.pattern.size())
        result += ", ";
    }
  }
  result += ", ";
  result += "parOffset=";
  result += std::to_string(AccessPatternInstance.parOffset);
  result += ", ";
  result += "freeOffset=";
  result += std::to_string(AccessPatternInstance.freeOffset);
  result += ", ";
  result += "fixedAxis=";
  {
    size_t i1 = 0;
    for (Nat printListLoopItem1 : AccessPatternInstance.fixedAxis) {
      result += std::to_string(printListLoopItem1);
      i1++;
      if (i1 < AccessPatternInstance.fixedAxis.size())
        result += ", ";
    }
  }
  result += ")";
  return result;
};

std::string to_string(ScalarOffsetRegWrapper &ScalarOffsetRegWrapperInstance) {
  std::string result;
  result += "ScalarOffsetRegWrapper(";
  result += "r=";
  result += ScalarOffsetRegWrapperInstance.r;
  result += ")";
  return result;
};
std::string to_string(ScalarOffsetAccWrapper &ScalarOffsetAccWrapperInstance) {
  std::string result;
  result += "ScalarOffsetAccWrapper(";
  result += "a=";
  result += to_string(*(ScalarOffsetAccWrapperInstance.a.get()));
  result += ")";
  return result;
};
std::string to_string(ScalarOffset &ScalarOffsetInstance) {
  switch (ScalarOffsetInstance.tag) {
  case (ScalarOffset::Tag::reg): {
    ScalarOffsetRegWrapper &derivedRef =
        static_cast<ScalarOffsetRegWrapper &>(ScalarOffsetInstance);
    return to_string(derivedRef);
  }
  case (ScalarOffset::Tag::acc): {
    ScalarOffsetAccWrapper &derivedRef =
        static_cast<ScalarOffsetAccWrapper &>(ScalarOffsetInstance);
    return to_string(derivedRef);
  }
  default:
    return "UNABLE TO PRINT";
  }
};

std::string to_string(BirAccessPattern &BirAccessPatternInstance) {
  std::string result;
  result += "BirAccessPattern(";
  result += "tensor=";
  result += to_string(*(BirAccessPatternInstance.tensor.get()));
  result += ", ";
  result += "offset=";
  result += std::to_string(BirAccessPatternInstance.offset);
  result += ", ";
  result += "pattern=";
  {
    size_t i1 = 0;
    for (Ptr<APPair> printListLoopItem1 : BirAccessPatternInstance.pattern) {
      result += to_string(*(printListLoopItem1.get()));
      i1++;
      if (i1 < BirAccessPatternInstance.pattern.size())
        result += ", ";
    }
  }
  result += ", ";
  result += "scalarOffset=";
  if (BirAccessPatternInstance.scalarOffset.has_value()) {
    result += to_string(*(BirAccessPatternInstance.scalarOffset.value().get()));
  } else {
    result += "None";
  }
  result += ", ";
  result += "vectorOffset=";
  if (BirAccessPatternInstance.vectorOffset.has_value()) {
    result += to_string(*(BirAccessPatternInstance.vectorOffset.value().get()));
  } else {
    result += "None";
  }
  result += ", ";
  result += "indirectDim=";
  result += std::to_string(BirAccessPatternInstance.indirectDim);
  result += ", ";
  result += "dtypeOverride=";
  if (BirAccessPatternInstance.dtypeOverride.has_value()) {
    result += to_string(
        BirAccessPatternInstance.dtypeOverride.value()); // mapped from enum
  } else {
    result += "None";
  }
  result += ")";
  return result;
};

std::string to_string(AccessSimpleWrapper &AccessSimpleWrapperInstance) {
  std::string result;
  result += "AccessSimpleWrapper(";
  result += "tensor=";
  result += to_string(*(AccessSimpleWrapperInstance.tensor.get()));
  result += ")";
  return result;
};
std::string to_string(AccessBasicWrapper &AccessBasicWrapperInstance) {
  std::string result;
  result += "AccessBasicWrapper(";
  result += "access=";
  result += to_string(*(AccessBasicWrapperInstance.access.get()));
  result += ")";
  return result;
};
std::string to_string(AccessPatternWrapper &AccessPatternWrapperInstance) {
  std::string result;
  result += "AccessPatternWrapper(";
  result += "access=";
  result += to_string(*(AccessPatternWrapperInstance.access.get()));
  result += ")";
  return result;
};
std::string
to_string(AccessBirPatternWrapper &AccessBirPatternWrapperInstance) {
  std::string result;
  result += "AccessBirPatternWrapper(";
  result += "access=";
  result += to_string(*(AccessBirPatternWrapperInstance.access.get()));
  result += ")";
  return result;
};
std::string to_string(Access &AccessInstance) {
  switch (AccessInstance.tag) {
  case (Access::Tag::simple): {
    AccessSimpleWrapper &derivedRef =
        static_cast<AccessSimpleWrapper &>(AccessInstance);
    return to_string(derivedRef);
  }
  case (Access::Tag::basic): {
    AccessBasicWrapper &derivedRef =
        static_cast<AccessBasicWrapper &>(AccessInstance);
    return to_string(derivedRef);
  }
  case (Access::Tag::pattern): {
    AccessPatternWrapper &derivedRef =
        static_cast<AccessPatternWrapper &>(AccessInstance);
    return to_string(derivedRef);
  }
  case (Access::Tag::birPattern): {
    AccessBirPatternWrapper &derivedRef =
        static_cast<AccessBirPatternWrapper &>(AccessInstance);
    return to_string(derivedRef);
  }
  default:
    return "UNABLE TO PRINT";
  }
};

std::string to_string(TensorHbm &TensorHbmInstance) {
  std::string result;
  result += "TensorHbm(";
  result += "name=";
  result += TensorHbmInstance.name;
  result += ", ";
  result += "dtype=";
  result += to_string(TensorHbmInstance.dtype); // mapped from enum
  result += ", ";
  result += "address=";
  result += std::to_string(TensorHbmInstance.address);
  result += ", ";
  result += "dims=";
  {
    size_t i1 = 0;
    for (Ptr<APPair> printListLoopItem1 : TensorHbmInstance.dims) {
      result += to_string(*(printListLoopItem1.get()));
      i1++;
      if (i1 < TensorHbmInstance.dims.size())
        result += ", ";
    }
  }
  result += ")";
  return result;
};

std::string to_string(TensorSram &TensorSramInstance) {
  std::string result;
  result += "TensorSram(";
  result += "name=";
  result += TensorSramInstance.name;
  result += ", ";
  result += "dtype=";
  result += to_string(TensorSramInstance.dtype); // mapped from enum
  result += ", ";
  result += "parNum=";
  result += std::to_string(TensorSramInstance.parNum);
  result += ", ";
  result += "pattern=";
  {
    size_t i1 = 0;
    for (Ptr<APPair> printListLoopItem1 : TensorSramInstance.pattern) {
      result += to_string(*(printListLoopItem1.get()));
      i1++;
      if (i1 < TensorSramInstance.pattern.size())
        result += ", ";
    }
  }
  result += ", ";
  result += "parOffset=";
  result += std::to_string(TensorSramInstance.parOffset);
  result += ", ";
  result += "freeOffset=";
  result += std::to_string(TensorSramInstance.freeOffset);
  result += ")";
  return result;
};

std::string
to_string(TensorRefAbstractWrapper &TensorRefAbstractWrapperInstance) {
  std::string result;
  result += "TensorRefAbstractWrapper(";
  result += "access=";
  result += to_string(*(TensorRefAbstractWrapperInstance.access.get()));
  result += ")";
  return result;
};
std::string to_string(TensorRefSbufWrapper &TensorRefSbufWrapperInstance) {
  std::string result;
  result += "TensorRefSbufWrapper(";
  result += "view=";
  result += to_string(*(TensorRefSbufWrapperInstance.view.get()));
  result += ")";
  return result;
};
std::string to_string(TensorRefPsumWrapper &TensorRefPsumWrapperInstance) {
  std::string result;
  result += "TensorRefPsumWrapper(";
  result += "view=";
  result += to_string(*(TensorRefPsumWrapperInstance.view.get()));
  result += ")";
  return result;
};
std::string to_string(TensorRefHbmWrapper &TensorRefHbmWrapperInstance) {
  std::string result;
  result += "TensorRefHbmWrapper(";
  result += "view=";
  result += to_string(*(TensorRefHbmWrapperInstance.view.get()));
  result += ")";
  return result;
};
std::string
to_string(TensorRefRegisterWrapper &TensorRefRegisterWrapperInstance) {
  std::string result;
  result += "TensorRefRegisterWrapper(";
  result += "reg=";
  result += std::to_string(TensorRefRegisterWrapperInstance.reg);
  result += ")";
  return result;
};
std::string to_string(TensorRef &TensorRefInstance) {
  switch (TensorRefInstance.tag) {
  case (TensorRef::Tag::abstract): {
    TensorRefAbstractWrapper &derivedRef =
        static_cast<TensorRefAbstractWrapper &>(TensorRefInstance);
    return to_string(derivedRef);
  }
  case (TensorRef::Tag::sbuf): {
    TensorRefSbufWrapper &derivedRef =
        static_cast<TensorRefSbufWrapper &>(TensorRefInstance);
    return to_string(derivedRef);
  }
  case (TensorRef::Tag::psum): {
    TensorRefPsumWrapper &derivedRef =
        static_cast<TensorRefPsumWrapper &>(TensorRefInstance);
    return to_string(derivedRef);
  }
  case (TensorRef::Tag::hbm): {
    TensorRefHbmWrapper &derivedRef =
        static_cast<TensorRefHbmWrapper &>(TensorRefInstance);
    return to_string(derivedRef);
  }
  case (TensorRef::Tag::reg): {
    TensorRefRegisterWrapper &derivedRef =
        static_cast<TensorRefRegisterWrapper &>(TensorRefInstance);
    return to_string(derivedRef);
  }
  default:
    return "UNABLE TO PRINT";
  }
};

std::string to_string(MatmulPerfMode &MatmulPerfModeInstance) {
  switch (MatmulPerfModeInstance) {
  case MatmulPerfMode::None:
    return "None";
    break;
  case MatmulPerfMode::DoubleRow:
    return "DoubleRow";
    break;
  case MatmulPerfMode::DoubleRowSwInterleave:
    return "DoubleRowSwInterleave";
    break;
  default:
    return "UNABLE TO PRINT";
  }
};

std::string to_string(Engine &EngineInstance) {
  switch (EngineInstance) {
  case Engine::unassigned:
    return "unassigned";
    break;
  case Engine::act:
    return "act";
    break;
  case Engine::dma:
    return "dma";
    break;
  case Engine::dve:
    return "dve";
    break;
  case Engine::pe:
    return "pe";
    break;
  case Engine::pool:
    return "pool";
    break;
  case Engine::sp:
    return "sp";
    break;
  default:
    return "UNABLE TO PRINT";
  }
};

std::string
to_string(ActivationImmRegisterWrapper &ActivationImmRegisterWrapperInstance) {
  std::string result;
  result += "ActivationImmRegisterWrapper(";
  result += "reg=";
  result += std::to_string(ActivationImmRegisterWrapperInstance.reg);
  result += ")";
  return result;
};
std::string
to_string(ActivationImmPointerWrapper &ActivationImmPointerWrapperInstance) {
  std::string result;
  result += "ActivationImmPointerWrapper(";
  result += ")";
  return result;
};
std::string
to_string(ActivationImmFloatWrapper &ActivationImmFloatWrapperInstance) {
  std::string result;
  result += "ActivationImmFloatWrapper(";
  result += "f=";
  result += std::to_string(ActivationImmFloatWrapperInstance.f);
  result += ")";
  return result;
};
std::string to_string(ActivationImm &ActivationImmInstance) {
  switch (ActivationImmInstance.tag) {
  case (ActivationImm::Tag::reg): {
    ActivationImmRegisterWrapper &derivedRef =
        static_cast<ActivationImmRegisterWrapper &>(ActivationImmInstance);
    return to_string(derivedRef);
  }
  case (ActivationImm::Tag::pointer): {
    ActivationImmPointerWrapper &derivedRef =
        static_cast<ActivationImmPointerWrapper &>(ActivationImmInstance);
    return to_string(derivedRef);
  }
  case (ActivationImm::Tag::float32): {
    ActivationImmFloatWrapper &derivedRef =
        static_cast<ActivationImmFloatWrapper &>(ActivationImmInstance);
    return to_string(derivedRef);
  }
  default:
    return "UNABLE TO PRINT";
  }
};

std::string to_string(OperandImmWrapper &OperandImmWrapperInstance) {
  std::string result;
  result += "OperandImmWrapper(";
  result += "i=";
  result += to_string(*(OperandImmWrapperInstance.i.get()));
  result += ")";
  return result;
};
std::string to_string(OperandTileWrapper &OperandTileWrapperInstance) {
  std::string result;
  result += "OperandTileWrapper(";
  result += "t=";
  result += to_string(*(OperandTileWrapperInstance.t.get()));
  result += ")";
  return result;
};
std::string to_string(Operand &OperandInstance) {
  switch (OperandInstance.tag) {
  case (Operand::Tag::imm): {
    OperandImmWrapper &derivedRef =
        static_cast<OperandImmWrapper &>(OperandInstance);
    return to_string(derivedRef);
  }
  case (Operand::Tag::tile): {
    OperandTileWrapper &derivedRef =
        static_cast<OperandTileWrapper &>(OperandInstance);
    return to_string(derivedRef);
  }
  default:
    return "UNABLE TO PRINT";
  }
};

std::string to_string(DataPattern &DataPatternInstance) {
  std::string result;
  result += "DataPattern(";
  result += "offset=";
  result += std::to_string(DataPatternInstance.offset);
  result += ", ";
  result += "pattern=";
  {
    size_t i1 = 0;
    for (Ptr<APPair> printListLoopItem1 : DataPatternInstance.pattern) {
      result += to_string(*(printListLoopItem1.get()));
      i1++;
      if (i1 < DataPatternInstance.pattern.size())
        result += ", ";
    }
  }
  result += ", ";
  result += "channelMultiplier=";
  result += std::to_string(DataPatternInstance.channelMultiplier);
  result += ")";
  return result;
};

std::string to_string(AluOp &AluOpInstance) {
  switch (AluOpInstance) {
  case AluOp::abs:
    return "abs";
    break;
  case AluOp::add:
    return "add";
    break;
  case AluOp::arith_shift_left:
    return "arith_shift_left";
    break;
  case AluOp::arith_shift_right:
    return "arith_shift_right";
    break;
  case AluOp::average:
    return "average";
    break;
  case AluOp::bitwise_and:
    return "bitwise_and";
    break;
  case AluOp::bitwise_not:
    return "bitwise_not";
    break;
  case AluOp::bitwise_or:
    return "bitwise_or";
    break;
  case AluOp::bitwise_xor:
    return "bitwise_xor";
    break;
  case AluOp::bypass:
    return "bypass";
    break;
  case AluOp::divide:
    return "divide";
    break;
  case AluOp::is_equal:
    return "is_equal";
    break;
  case AluOp::is_ge:
    return "is_ge";
    break;
  case AluOp::is_gt:
    return "is_gt";
    break;
  case AluOp::is_le:
    return "is_le";
    break;
  case AluOp::is_lt:
    return "is_lt";
    break;
  case AluOp::logical_and:
    return "logical_and";
    break;
  case AluOp::logical_or:
    return "logical_or";
    break;
  case AluOp::logical_shift_left:
    return "logical_shift_left";
    break;
  case AluOp::logical_shift_right:
    return "logical_shift_right";
    break;
  case AluOp::logical_xor:
    return "logical_xor";
    break;
  case AluOp::max:
    return "max";
    break;
  case AluOp::min:
    return "min";
    break;
  case AluOp::mod:
    return "mod";
    break;
  case AluOp::mult:
    return "mult";
    break;
  case AluOp::not_equal:
    return "not_equal";
    break;
  case AluOp::pow:
    return "pow";
    break;
  case AluOp::rsqrt:
    return "rsqrt";
    break;
  case AluOp::subtract:
    return "subtract";
    break;
  default:
    return "UNABLE TO PRINT";
  }
};

std::string to_string(DropoutThresholdType &DropoutThresholdTypeInstance) {
  switch (DropoutThresholdTypeInstance) {
  case DropoutThresholdType::DropRate:
    return "DropRate";
    break;
  case DropoutThresholdType::KeepRate:
    return "KeepRate";
    break;
  default:
    return "UNABLE TO PRINT";
  }
};

std::string to_string(AccumCmd &AccumCmdInstance) {
  switch (AccumCmdInstance) {
  case AccumCmd::Idle:
    return "Idle";
    break;
  case AccumCmd::Zero:
    return "Zero";
    break;
  case AccumCmd::Accumulate:
    return "Accumulate";
    break;
  case AccumCmd::ZeroAccumulate:
    return "ZeroAccumulate";
    break;
  case AccumCmd::LoadAccumulate:
    return "LoadAccumulate";
    break;
  default:
    return "UNABLE TO PRINT";
  }
};

std::string to_string(ActivationFunc &ActivationFuncInstance) {
  switch (ActivationFuncInstance) {
  case ActivationFunc::abs:
    return "abs";
    break;
  case ActivationFunc::arctan:
    return "arctan";
    break;
  case ActivationFunc::copy:
    return "copy";
    break;
  case ActivationFunc::erf:
    return "erf";
    break;
  case ActivationFunc::erf_dx:
    return "erf_dx";
    break;
  case ActivationFunc::exp:
    return "exp";
    break;
  case ActivationFunc::gelu:
    return "gelu";
    break;
  case ActivationFunc::gelu_apprx_tanh:
    return "gelu_apprx_tanh";
    break;
  case ActivationFunc::gelu_dx:
    return "gelu_dx";
    break;
  case ActivationFunc::log:
    return "log";
    break;
  case ActivationFunc::mish:
    return "mish";
    break;
  case ActivationFunc::reciprocal:
    return "reciprocal";
    break;
  case ActivationFunc::relu:
    return "relu";
    break;
  case ActivationFunc::rsqrt:
    return "rsqrt";
    break;
  case ActivationFunc::sigmoid:
    return "sigmoid";
    break;
  case ActivationFunc::sign:
    return "sign";
    break;
  case ActivationFunc::silu:
    return "silu";
    break;
  case ActivationFunc::silu_dx:
    return "silu_dx";
    break;
  case ActivationFunc::sin:
    return "sin";
    break;
  case ActivationFunc::softplus:
    return "softplus";
    break;
  case ActivationFunc::sqrt:
    return "sqrt";
    break;
  case ActivationFunc::square:
    return "square";
    break;
  case ActivationFunc::tanh:
    return "tanh";
    break;
  case ActivationFunc::gelu_apprx_sigmoid:
    return "gelu_apprx_sigmoid";
    break;
  case ActivationFunc::gelu_apprx_sigmoid_dx:
    return "gelu_apprx_sigmoid_dx";
    break;
  default:
    return "UNABLE TO PRINT";
  }
};

std::string to_string(AffineSelectCmp &AffineSelectCmpInstance) {
  switch (AffineSelectCmpInstance) {
  case AffineSelectCmp::GreaterThan:
    return "GreaterThan";
    break;
  case AffineSelectCmp::GreaterThanEq:
    return "GreaterThanEq";
    break;
  case AffineSelectCmp::Eq:
    return "Eq";
    break;
  case AffineSelectCmp::NotEq:
    return "NotEq";
    break;
  default:
    return "UNABLE TO PRINT";
  }
};

std::string to_string(DgeComputeOp &DgeComputeOpInstance) {
  switch (DgeComputeOpInstance) {
  case DgeComputeOp::none:
    return "none";
    break;
  case DgeComputeOp::add:
    return "add";
    break;
  default:
    return "UNABLE TO PRINT";
  }
};

std::string to_string(DmaBoundsSkipWrapper &DmaBoundsSkipWrapperInstance) {
  std::string result;
  result += "DmaBoundsSkipWrapper(";
  result += ")";
  return result;
};
std::string to_string(DmaBoundsErrorWrapper &DmaBoundsErrorWrapperInstance) {
  std::string result;
  result += "DmaBoundsErrorWrapper(";
  result += ")";
  return result;
};
std::string to_string(DmaBoundsRegWrapper &DmaBoundsRegWrapperInstance) {
  std::string result;
  result += "DmaBoundsRegWrapper(";
  result += "reg=";
  result += std::to_string(DmaBoundsRegWrapperInstance.reg);
  result += ")";
  return result;
};
std::string to_string(DmaBounds &DmaBoundsInstance) {
  switch (DmaBoundsInstance.tag) {
  case (DmaBounds::Tag::skip): {
    DmaBoundsSkipWrapper &derivedRef =
        static_cast<DmaBoundsSkipWrapper &>(DmaBoundsInstance);
    return to_string(derivedRef);
  }
  case (DmaBounds::Tag::error): {
    DmaBoundsErrorWrapper &derivedRef =
        static_cast<DmaBoundsErrorWrapper &>(DmaBoundsInstance);
    return to_string(derivedRef);
  }
  case (DmaBounds::Tag::reg): {
    DmaBoundsRegWrapper &derivedRef =
        static_cast<DmaBoundsRegWrapper &>(DmaBoundsInstance);
    return to_string(derivedRef);
  }
  default:
    return "UNABLE TO PRINT";
  }
};

std::string to_string(MatmulGroupElement &MatmulGroupElementInstance) {
  switch (MatmulGroupElementInstance) {
  case MatmulGroupElement::first:
    return "first";
    break;
  case MatmulGroupElement::middle:
    return "middle";
    break;
  case MatmulGroupElement::last:
    return "last";
    break;
  case MatmulGroupElement::whole:
    return "whole";
    break;
  default:
    return "UNABLE TO PRINT";
  }
};

std::string
to_string(IndexMissBehaviorImmWrapper &IndexMissBehaviorImmWrapperInstance) {
  std::string result;
  result += "IndexMissBehaviorImmWrapper(";
  result += "value=";
  result += to_string(*(IndexMissBehaviorImmWrapperInstance.value.get()));
  result += ")";
  return result;
};
std::string
to_string(IndexMissBehaviorSkipWrapper &IndexMissBehaviorSkipWrapperInstance) {
  std::string result;
  result += "IndexMissBehaviorSkipWrapper(";
  result += ")";
  return result;
};
std::string to_string(IndexMissBehavior &IndexMissBehaviorInstance) {
  switch (IndexMissBehaviorInstance.tag) {
  case (IndexMissBehavior::Tag::imm): {
    IndexMissBehaviorImmWrapper &derivedRef =
        static_cast<IndexMissBehaviorImmWrapper &>(IndexMissBehaviorInstance);
    return to_string(derivedRef);
  }
  case (IndexMissBehavior::Tag::skip): {
    IndexMissBehaviorSkipWrapper &derivedRef =
        static_cast<IndexMissBehaviorSkipWrapper &>(IndexMissBehaviorInstance);
    return to_string(derivedRef);
  }
  default:
    return "UNABLE TO PRINT";
  }
};

std::string to_string(TensorScalarReverseOps &TensorScalarReverseOpsInstance) {
  switch (TensorScalarReverseOpsInstance) {
  case TensorScalarReverseOps::none:
    return "none";
    break;
  case TensorScalarReverseOps::first:
    return "first";
    break;
  case TensorScalarReverseOps::second:
    return "second";
    break;
  case TensorScalarReverseOps::both:
    return "both";
    break;
  default:
    return "UNABLE TO PRINT";
  }
};

std::string to_string(TensorSubDim &TensorSubDimInstance) {
  switch (TensorSubDimInstance) {
  case TensorSubDim::X:
    return "X";
    break;
  case TensorSubDim::XY:
    return "XY";
    break;
  case TensorSubDim::XYZ:
    return "XYZ";
    break;
  case TensorSubDim::XYZW:
    return "XYZW";
    break;
  default:
    return "UNABLE TO PRINT";
  }
};

std::string to_string(TransposeOps &TransposeOpsInstance) {
  switch (TransposeOpsInstance) {
  case TransposeOps::None:
    return "None";
    break;
  case TransposeOps::WZXY:
    return "WZXY";
    break;
  case TransposeOps::WXZY:
    return "WXZY";
    break;
  case TransposeOps::WYXZ:
    return "WYXZ";
    break;
  case TransposeOps::ZWYX:
    return "ZWYX";
    break;
  case TransposeOps::ZYWX:
    return "ZYWX";
    break;
  case TransposeOps::ZYXW:
    return "ZYXW";
    break;
  case TransposeOps::YXWZ:
    return "YXWZ";
    break;
  case TransposeOps::YXZW:
    return "YXZW";
    break;
  case TransposeOps::YWZX:
    return "YWZX";
    break;
  case TransposeOps::XWZY:
    return "XWZY";
    break;
  case TransposeOps::XZYW:
    return "XZYW";
    break;
  case TransposeOps::XYZW:
    return "XYZW";
    break;
  case TransposeOps::XYWZ:
    return "XYWZ";
    break;
  default:
    return "UNABLE TO PRINT";
  }
};

std::string to_string(Dropout &DropoutInstance) {
  std::string result;
  result += "Dropout(";
  result += "dst=";
  result += to_string(*(DropoutInstance.dst.get()));
  result += ", ";
  result += "src=";
  result += to_string(*(DropoutInstance.src.get()));
  result += ", ";
  result += "thresholdType=";
  result += to_string(DropoutInstance.thresholdType); // mapped from enum
  result += ", ";
  result += "threshold=";
  result += to_string(*(DropoutInstance.threshold.get()));
  result += ", ";
  result += "dtype=";
  if (DropoutInstance.dtype.has_value()) {
    result += to_string(DropoutInstance.dtype.value()); // mapped from enum
  } else {
    result += "None";
  }
  result += ")";
  return result;
};

std::string to_string(Activate &ActivateInstance) {
  std::string result;
  result += "Activate(";
  result += "dst=";
  result += to_string(*(ActivateInstance.dst.get()));
  result += ", ";
  result += "src=";
  result += to_string(*(ActivateInstance.src.get()));
  result += ", ";
  result += "accumulatorCmd=";
  result += to_string(ActivateInstance.accumulatorCmd); // mapped from enum
  result += ", ";
  result += "activationFunc=";
  result += to_string(ActivateInstance.activationFunc); // mapped from enum
  result += ", ";
  result += "scale=";
  result += to_string(*(ActivateInstance.scale.get()));
  result += ", ";
  result += "bias=";
  result += to_string(*(ActivateInstance.bias.get()));
  result += ", ";
  result += "imm=";
  result += to_string(*(ActivateInstance.imm.get()));
  result += ")";
  return result;
};

std::string to_string(AffineSelect &AffineSelectInstance) {
  std::string result;
  result += "AffineSelect(";
  result += "dst=";
  result += to_string(*(AffineSelectInstance.dst.get()));
  result += ", ";
  result += "src=";
  result += to_string(*(AffineSelectInstance.src.get()));
  result += ", ";
  result += "fillMode=";
  result += to_string(AffineSelectInstance.fillMode); // mapped from enum
  result += ", ";
  result += "fillReg=";
  result += std::to_string(AffineSelectInstance.fillReg);
  result += ", ";
  result += "maskPattern=";
  result += to_string(*(AffineSelectInstance.maskPattern.get()));
  result += ")";
  return result;
};

std::string to_string(DmaCopy &DmaCopyInstance) {
  std::string result;
  result += "DmaCopy(";
  result += "dst=";
  result += to_string(*(DmaCopyInstance.dst.get()));
  result += ", ";
  result += "src=";
  result += to_string(*(DmaCopyInstance.src.get()));
  result += ", ";
  result += "compute_op=";
  result += to_string(DmaCopyInstance.compute_op); // mapped from enum
  result += ", ";
  result += "dstBoundsCheck=";
  result += to_string(*(DmaCopyInstance.dstBoundsCheck.get()));
  result += ", ";
  result += "srcBoundsCheck=";
  result += to_string(*(DmaCopyInstance.srcBoundsCheck.get()));
  result += ")";
  return result;
};

std::string to_string(DmaTranspose &DmaTransposeInstance) {
  std::string result;
  result += "DmaTranspose(";
  result += "dst=";
  result += to_string(*(DmaTransposeInstance.dst.get()));
  result += ", ";
  result += "src=";
  result += to_string(*(DmaTransposeInstance.src.get()));
  result += ", ";
  result += "axes=";
  result += to_string(DmaTransposeInstance.axes); // mapped from enum
  result += ", ";
  result += "dtype=";
  if (DmaTransposeInstance.dtype.has_value()) {
    result += to_string(DmaTransposeInstance.dtype.value()); // mapped from enum
  } else {
    result += "None";
  }
  result += ", ";
  result += "dgeMode=";
  result += std::to_string(DmaTransposeInstance.dgeMode);
  result += ", ";
  result += "oobMode=";
  result += to_string(*(DmaTransposeInstance.oobMode.get()));
  result += ")";
  return result;
};

std::string to_string(Transpose &TransposeInstance) {
  std::string result;
  result += "Transpose(";
  result += "dst=";
  result += to_string(*(TransposeInstance.dst.get()));
  result += ", ";
  result += "src=";
  result += to_string(*(TransposeInstance.src.get()));
  result += ", ";
  result += "dtype=";
  if (TransposeInstance.dtype.has_value()) {
    result += to_string(TransposeInstance.dtype.value()); // mapped from enum
  } else {
    result += "None";
  }
  result += ", ";
  result += "engine=";
  result += to_string(TransposeInstance.engine); // mapped from enum
  result += ")";
  return result;
};

std::string to_string(LoadMaskRegister &LoadMaskRegisterInstance) {
  std::string result;
  result += "LoadMaskRegister(";
  result += "regNum=";
  result += std::to_string(LoadMaskRegisterInstance.regNum);
  result += ")";
  return result;
};

std::string to_string(Shuffle &ShuffleInstance) {
  std::string result;
  result += "Shuffle(";
  result += "dst=";
  result += to_string(*(ShuffleInstance.dst.get()));
  result += ", ";
  result += "src=";
  result += to_string(*(ShuffleInstance.src.get()));
  result += ", ";
  result += "shuffleMask=";
  {
    size_t i1 = 0;
    for (Ptr<Immediate> printListLoopItem1 : ShuffleInstance.shuffleMask) {
      result += to_string(*(printListLoopItem1.get()));
      i1++;
      if (i1 < ShuffleInstance.shuffleMask.size())
        result += ", ";
    }
  }
  result += ", ";
  result += "dtype=";
  if (ShuffleInstance.dtype.has_value()) {
    result += to_string(ShuffleInstance.dtype.value()); // mapped from enum
  } else {
    result += "None";
  }
  result += ")";
  return result;
};

std::string to_string(MemSet &MemSetInstance) {
  std::string result;
  result += "MemSet(";
  result += "dst=";
  result += to_string(*(MemSetInstance.dst.get()));
  result += ", ";
  result += "value=";
  result += to_string(*(MemSetInstance.value.get()));
  result += ", ";
  result += "dtype=";
  result += to_string(MemSetInstance.dtype); // mapped from enum
  result += ", ";
  result += "engine=";
  result += to_string(MemSetInstance.engine); // mapped from enum
  result += ")";
  return result;
};

std::string to_string(Iota &IotaInstance) {
  std::string result;
  result += "Iota(";
  result += "dst=";
  result += to_string(*(IotaInstance.dst.get()));
  result += ", ";
  result += "pattern=";
  result += to_string(*(IotaInstance.pattern.get()));
  result += ", ";
  result += "dtype=";
  if (IotaInstance.dtype.has_value()) {
    result += to_string(IotaInstance.dtype.value()); // mapped from enum
  } else {
    result += "None";
  }
  result += ")";
  return result;
};

std::string to_string(LoadStationary &LoadStationaryInstance) {
  std::string result;
  result += "LoadStationary(";
  result += "src=";
  result += to_string(*(LoadStationaryInstance.src.get()));
  result += ", ";
  result += "isTranspose=";
  result += std::to_string(LoadStationaryInstance.isTranspose);
  result += ")";
  return result;
};

std::string to_string(MatMul &MatMulInstance) {
  std::string result;
  result += "MatMul(";
  result += "dst=";
  result += to_string(*(MatMulInstance.dst.get()));
  result += ", ";
  result += "moving=";
  result += to_string(*(MatMulInstance.moving.get()));
  result += ")";
  return result;
};

std::string to_string(LocalGather &LocalGatherInstance) {
  std::string result;
  result += "LocalGather(";
  result += "dst=";
  result += to_string(*(LocalGatherInstance.dst.get()));
  result += ", ";
  result += "src=";
  result += to_string(*(LocalGatherInstance.src.get()));
  result += ", ";
  result += "indexMissBehavior=";
  result += to_string(*(LocalGatherInstance.indexMissBehavior.get()));
  result += ", ";
  result += "freePoolBuffer=";
  result += std::to_string(LocalGatherInstance.freePoolBuffer);
  result += ")";
  return result;
};

std::string to_string(RangeSelect &RangeSelectInstance) {
  std::string result;
  result += "RangeSelect(";
  result += "dst=";
  result += to_string(*(RangeSelectInstance.dst.get()));
  result += ", ";
  result += "src=";
  result += to_string(*(RangeSelectInstance.src.get()));
  result += ", ";
  result += "reduceCommand=";
  result += to_string(RangeSelectInstance.reduceCommand); // mapped from enum
  result += ", ";
  result += "reduceOp=";
  result += to_string(RangeSelectInstance.reduceOp); // mapped from enum
  result += ", ";
  result += "base=";
  result += std::to_string(RangeSelectInstance.base);
  result += ", ";
  result += "fillValue=";
  result += std::to_string(RangeSelectInstance.fillValue);
  result += ", ";
  result += "compOp0=";
  result += to_string(RangeSelectInstance.compOp0); // mapped from enum
  result += ", ";
  result += "compOp1=";
  result += to_string(RangeSelectInstance.compOp1); // mapped from enum
  result += ", ";
  result += "bound0=";
  result += to_string(*(RangeSelectInstance.bound0.get()));
  result += ", ";
  result += "bound1=";
  result += to_string(*(RangeSelectInstance.bound1.get()));
  result += ")";
  return result;
};

std::string to_string(ScalarTensorTensor &ScalarTensorTensorInstance) {
  std::string result;
  result += "ScalarTensorTensor(";
  result += "dst=";
  result += to_string(*(ScalarTensorTensorInstance.dst.get()));
  result += ", ";
  result += "src0=";
  result += to_string(*(ScalarTensorTensorInstance.src0.get()));
  result += ", ";
  result += "src1=";
  result += to_string(*(ScalarTensorTensorInstance.src1.get()));
  result += ", ";
  result += "op0=";
  result += to_string(ScalarTensorTensorInstance.op0); // mapped from enum
  result += ", ";
  result += "op1=";
  result += to_string(ScalarTensorTensorInstance.op1); // mapped from enum
  result += ", ";
  result += "reverseOperands=";
  result +=
      to_string(ScalarTensorTensorInstance.reverseOperands); // mapped from enum
  result += ", ";
  result += "imm0=";
  result += to_string(*(ScalarTensorTensorInstance.imm0.get()));
  result += ", ";
  result += "accumulatorCmd=";
  result +=
      to_string(ScalarTensorTensorInstance.accumulatorCmd); // mapped from enum
  result += ")";
  return result;
};

std::string to_string(CopyPredicated &CopyPredicatedInstance) {
  std::string result;
  result += "CopyPredicated(";
  result += "dst=";
  result += to_string(*(CopyPredicatedInstance.dst.get()));
  result += ", ";
  result += "src=";
  result += to_string(*(CopyPredicatedInstance.src.get()));
  result += ", ";
  result += "predicate=";
  result += to_string(*(CopyPredicatedInstance.predicate.get()));
  result += ", ";
  result += "dtype=";
  if (CopyPredicatedInstance.dtype.has_value()) {
    result +=
        to_string(CopyPredicatedInstance.dtype.value()); // mapped from enum
  } else {
    result += "None";
  }
  result += ", ";
  result += "reversePred=";
  result += std::to_string(CopyPredicatedInstance.reversePred);
  result += ")";
  return result;
};

std::string to_string(TensorTensorScan &TensorTensorScanInstance) {
  std::string result;
  result += "TensorTensorScan(";
  result += "dst=";
  result += to_string(*(TensorTensorScanInstance.dst.get()));
  result += ", ";
  result += "src0=";
  result += to_string(*(TensorTensorScanInstance.src0.get()));
  result += ", ";
  result += "src1=";
  result += to_string(*(TensorTensorScanInstance.src1.get()));
  result += ", ";
  result += "op0=";
  result += to_string(TensorTensorScanInstance.op0); // mapped from enum
  result += ", ";
  result += "op1=";
  result += to_string(TensorTensorScanInstance.op1); // mapped from enum
  result += ", ";
  result += "reverseOperands=";
  result +=
      to_string(TensorTensorScanInstance.reverseOperands); // mapped from enum
  result += ", ";
  result += "imm0=";
  result += to_string(*(TensorTensorScanInstance.imm0.get()));
  result += ", ";
  result += "accumulatorCmd=";
  result +=
      to_string(TensorTensorScanInstance.accumulatorCmd); // mapped from enum
  result += ", ";
  result += "dtype=";
  if (TensorTensorScanInstance.dtype.has_value()) {
    result +=
        to_string(TensorTensorScanInstance.dtype.value()); // mapped from enum
  } else {
    result += "None";
  }
  result += ")";
  return result;
};

std::string to_string(MatchValueLoad &MatchValueLoadInstance) {
  std::string result;
  result += "MatchValueLoad(";
  result += "src=";
  result += to_string(*(MatchValueLoadInstance.src.get()));
  result += ")";
  return result;
};

std::string to_string(FindIndex8 &FindIndex8Instance) {
  std::string result;
  result += "FindIndex8(";
  result += "dst=";
  result += to_string(*(FindIndex8Instance.dst.get()));
  result += ", ";
  result += "src=";
  result += to_string(*(FindIndex8Instance.src.get()));
  result += ", ";
  result += "vals=";
  result += to_string(*(FindIndex8Instance.vals.get()));
  result += ", ";
  result += "dtype=";
  if (FindIndex8Instance.dtype.has_value()) {
    result += to_string(FindIndex8Instance.dtype.value()); // mapped from enum
  } else {
    result += "None";
  }
  result += ")";
  return result;
};

std::string to_string(MatchReplace8 &MatchReplace8Instance) {
  std::string result;
  result += "MatchReplace8(";
  result += "dst=";
  result += to_string(*(MatchReplace8Instance.dst.get()));
  result += ", ";
  result += "src=";
  result += to_string(*(MatchReplace8Instance.src.get()));
  result += ", ";
  result += "vals=";
  result += to_string(*(MatchReplace8Instance.vals.get()));
  result += ", ";
  result += "replaceValue=";
  result += to_string(*(MatchReplace8Instance.replaceValue.get()));
  result += ", ";
  result += "dstIdx=";
  if (MatchReplace8Instance.dstIdx.has_value()) {
    result += to_string(*(MatchReplace8Instance.dstIdx.value().get()));
  } else {
    result += "None";
  }
  result += ", ";
  result += "dtype=";
  if (MatchReplace8Instance.dtype.has_value()) {
    result += to_string(MatchReplace8Instance.dtype.value()); // mapped from
                                                              // enum
  } else {
    result += "None";
  }
  result += ")";
  return result;
};

std::string to_string(Max8 &Max8Instance) {
  std::string result;
  result += "Max8(";
  result += "dst=";
  result += to_string(*(Max8Instance.dst.get()));
  result += ", ";
  result += "src=";
  result += to_string(*(Max8Instance.src.get()));
  result += ", ";
  result += "dtype=";
  if (Max8Instance.dtype.has_value()) {
    result += to_string(Max8Instance.dtype.value()); // mapped from enum
  } else {
    result += "None";
  }
  result += ")";
  return result;
};

std::string to_string(BatchNormAggregate &BatchNormAggregateInstance) {
  std::string result;
  result += "BatchNormAggregate(";
  result += "dst=";
  result += to_string(*(BatchNormAggregateInstance.dst.get()));
  result += ", ";
  result += "src=";
  result += to_string(*(BatchNormAggregateInstance.src.get()));
  result += ", ";
  result += "dtype=";
  if (BatchNormAggregateInstance.dtype.has_value()) {
    result +=
        to_string(BatchNormAggregateInstance.dtype.value()); // mapped from enum
  } else {
    result += "None";
  }
  result += ")";
  return result;
};

std::string to_string(BatchNormStats &BatchNormStatsInstance) {
  std::string result;
  result += "BatchNormStats(";
  result += "dst=";
  result += to_string(*(BatchNormStatsInstance.dst.get()));
  result += ", ";
  result += "src=";
  result += to_string(*(BatchNormStatsInstance.src.get()));
  result += ", ";
  result += "dtype=";
  if (BatchNormStatsInstance.dtype.has_value()) {
    result +=
        to_string(BatchNormStatsInstance.dtype.value()); // mapped from enum
  } else {
    result += "None";
  }
  result += ")";
  return result;
};

std::string to_string(Reciprocal &ReciprocalInstance) {
  std::string result;
  result += "Reciprocal(";
  result += "dst=";
  result += to_string(*(ReciprocalInstance.dst.get()));
  result += ", ";
  result += "src=";
  result += to_string(*(ReciprocalInstance.src.get()));
  result += ", ";
  result += "dtype=";
  if (ReciprocalInstance.dtype.has_value()) {
    result += to_string(ReciprocalInstance.dtype.value()); // mapped from enum
  } else {
    result += "None";
  }
  result += ")";
  return result;
};

std::string to_string(Copy &CopyInstance) {
  std::string result;
  result += "Copy(";
  result += "dst=";
  result += to_string(*(CopyInstance.dst.get()));
  result += ", ";
  result += "src=";
  result += to_string(*(CopyInstance.src.get()));
  result += ", ";
  result += "opDim=";
  if (CopyInstance.opDim.has_value()) {
    result += to_string(CopyInstance.opDim.value()); // mapped from enum
  } else {
    result += "None";
  }
  result += ")";
  return result;
};

std::string to_string(TensorReduce &TensorReduceInstance) {
  std::string result;
  result += "TensorReduce(";
  result += "dst=";
  result += to_string(*(TensorReduceInstance.dst.get()));
  result += ", ";
  result += "src=";
  result += to_string(*(TensorReduceInstance.src.get()));
  result += ", ";
  result += "op=";
  result += to_string(TensorReduceInstance.op); // mapped from enum
  result += ", ";
  result += "opDim=";
  result += to_string(TensorReduceInstance.opDim); // mapped from enum
  result += ", ";
  result += "negated=";
  result += std::to_string(TensorReduceInstance.negated);
  result += ", ";
  result += "dtype=";
  if (TensorReduceInstance.dtype.has_value()) {
    result += to_string(TensorReduceInstance.dtype.value()); // mapped from enum
  } else {
    result += "None";
  }
  result += ", ";
  result += "keepdims=";
  result += std::to_string(TensorReduceInstance.keepdims);
  result += ")";
  return result;
};

std::string to_string(TensorScalar &TensorScalarInstance) {
  std::string result;
  result += "TensorScalar(";
  result += "dst=";
  result += to_string(*(TensorScalarInstance.dst.get()));
  result += ", ";
  result += "src=";
  result += to_string(*(TensorScalarInstance.src.get()));
  result += ", ";
  result += "imm0=";
  result += to_string(*(TensorScalarInstance.imm0.get()));
  result += ", ";
  result += "op0=";
  result += to_string(TensorScalarInstance.op0); // mapped from enum
  result += ", ";
  result += "imm1=";
  if (TensorScalarInstance.imm1.has_value()) {
    result += to_string(*(TensorScalarInstance.imm1.value().get()));
  } else {
    result += "None";
  }
  result += ", ";
  result += "op1=";
  if (TensorScalarInstance.op1.has_value()) {
    result += to_string(TensorScalarInstance.op1.value()); // mapped from enum
  } else {
    result += "None";
  }
  result += ", ";
  result += "reverse=";
  result += to_string(TensorScalarInstance.reverse); // mapped from enum
  result += ", ";
  result += "engine=";
  result += to_string(TensorScalarInstance.engine); // mapped from enum
  result += ", ";
  result += "dtype=";
  if (TensorScalarInstance.dtype.has_value()) {
    result += to_string(TensorScalarInstance.dtype.value()); // mapped from enum
  } else {
    result += "None";
  }
  result += ")";
  return result;
};

std::string to_string(TensorTensor &TensorTensorInstance) {
  std::string result;
  result += "TensorTensor(";
  result += "dst=";
  result += to_string(*(TensorTensorInstance.dst.get()));
  result += ", ";
  result += "src0=";
  result += to_string(*(TensorTensorInstance.src0.get()));
  result += ", ";
  result += "src1=";
  result += to_string(*(TensorTensorInstance.src1.get()));
  result += ", ";
  result += "op=";
  result += to_string(TensorTensorInstance.op); // mapped from enum
  result += ", ";
  result += "dtype=";
  if (TensorTensorInstance.dtype.has_value()) {
    result += to_string(TensorTensorInstance.dtype.value()); // mapped from enum
  } else {
    result += "None";
  }
  result += ", ";
  result += "engine=";
  result += to_string(TensorTensorInstance.engine); // mapped from enum
  result += ")";
  return result;
};

std::string to_string(NcMatMul &NcMatMulInstance) {
  std::string result;
  result += "NcMatMul(";
  result += "dst=";
  result += to_string(*(NcMatMulInstance.dst.get()));
  result += ", ";
  result += "stationary=";
  result += to_string(*(NcMatMulInstance.stationary.get()));
  result += ", ";
  result += "moving=";
  result += to_string(*(NcMatMulInstance.moving.get()));
  result += ", ";
  result += "isStationaryOneZero=";
  result += std::to_string(NcMatMulInstance.isStationaryOneZero);
  result += ", ";
  result += "isMovingZero=";
  result += std::to_string(NcMatMulInstance.isMovingZero);
  result += ", ";
  result += "isTranspose=";
  result += std::to_string(NcMatMulInstance.isTranspose);
  result += ", ";
  result += "tilePosition=";
  {
    size_t i1 = 0;
    for (Nat printListLoopItem1 : NcMatMulInstance.tilePosition) {
      result += std::to_string(printListLoopItem1);
      i1++;
      if (i1 < NcMatMulInstance.tilePosition.size())
        result += ", ";
    }
  }
  result += ", ";
  result += "tileSize=";
  {
    size_t i1 = 0;
    for (Nat printListLoopItem1 : NcMatMulInstance.tileSize) {
      result += std::to_string(printListLoopItem1);
      i1++;
      if (i1 < NcMatMulInstance.tileSize.size())
        result += ", ";
    }
  }
  result += ", ";
  result += "perfMode=";
  result += to_string(NcMatMulInstance.perfMode); // mapped from enum
  result += ")";
  return result;
};

std::string to_string(TensorScalarReduce &TensorScalarReduceInstance) {
  std::string result;
  result += "TensorScalarReduce(";
  result += "dst=";
  result += to_string(*(TensorScalarReduceInstance.dst.get()));
  result += ", ";
  result += "src=";
  result += to_string(*(TensorScalarReduceInstance.src.get()));
  result += ", ";
  result += "operand0=";
  result += to_string(*(TensorScalarReduceInstance.operand0.get()));
  result += ", ";
  result += "op0=";
  result += to_string(TensorScalarReduceInstance.op0); // mapped from enum
  result += ", ";
  result += "reverse0=";
  result += std::to_string(TensorScalarReduceInstance.reverse0);
  result += ", ";
  result += "dtype=";
  if (TensorScalarReduceInstance.dtype.has_value()) {
    result +=
        to_string(TensorScalarReduceInstance.dtype.value()); // mapped from enum
  } else {
    result += "None";
  }
  result += ", ";
  result += "reduceOp=";
  if (TensorScalarReduceInstance.reduceOp.has_value()) {
    result += to_string(
        TensorScalarReduceInstance.reduceOp.value()); // mapped from enum
  } else {
    result += "None";
  }
  result += ", ";
  result += "reduceRes=";
  result += to_string(*(TensorScalarReduceInstance.reduceRes.get()));
  result += ")";
  return result;
};

std::string to_string(TensorPartitionReduce &TensorPartitionReduceInstance) {
  std::string result;
  result += "TensorPartitionReduce(";
  result += "dst=";
  result += to_string(*(TensorPartitionReduceInstance.dst.get()));
  result += ", ";
  result += "op=";
  result += to_string(TensorPartitionReduceInstance.op); // mapped from enum
  result += ", ";
  result += "data=";
  result += to_string(*(TensorPartitionReduceInstance.data.get()));
  result += ", ";
  result += "dtype=";
  if (TensorPartitionReduceInstance.dtype.has_value()) {
    result += to_string(
        TensorPartitionReduceInstance.dtype.value()); // mapped from enum
  } else {
    result += "None";
  }
  result += ")";
  return result;
};

std::string to_string(NcActivate &NcActivateInstance) {
  std::string result;
  result += "NcActivate(";
  result += "dst=";
  result += to_string(*(NcActivateInstance.dst.get()));
  result += ", ";
  result += "src=";
  result += to_string(*(NcActivateInstance.src.get()));
  result += ", ";
  result += "accumulatorCmd=";
  result += to_string(NcActivateInstance.accumulatorCmd); // mapped from enum
  result += ", ";
  result += "activationFunc=";
  result += to_string(NcActivateInstance.activationFunc); // mapped from enum
  result += ", ";
  result += "scale=";
  result += to_string(*(NcActivateInstance.scale.get()));
  result += ", ";
  result += "bias=";
  if (NcActivateInstance.bias.has_value()) {
    result += to_string(*(NcActivateInstance.bias.value().get()));
  } else {
    result += "None";
  }
  result += ", ";
  result += "reduceOp=";
  if (NcActivateInstance.reduceOp.has_value()) {
    result += to_string(NcActivateInstance.reduceOp.value()); // mapped from
                                                              // enum
  } else {
    result += "None";
  }
  result += ", ";
  result += "reduceRes=";
  if (NcActivateInstance.reduceRes.has_value()) {
    result += to_string(*(NcActivateInstance.reduceRes.value().get()));
  } else {
    result += "None";
  }
  result += ", ";
  result += "dtype=";
  if (NcActivateInstance.dtype.has_value()) {
    result += to_string(NcActivateInstance.dtype.value()); // mapped from enum
  } else {
    result += "None";
  }
  result += ")";
  return result;
};

std::string to_string(NcAffineSelect &NcAffineSelectInstance) {
  std::string result;
  result += "NcAffineSelect(";
  result += "dst=";
  result += to_string(*(NcAffineSelectInstance.dst.get()));
  result += ", ";
  result += "pred=";
  result += to_string(*(NcAffineSelectInstance.pred.get()));
  result += ", ";
  result += "onTrueTile=";
  result += to_string(*(NcAffineSelectInstance.onTrueTile.get()));
  result += ", ";
  result += "onFalseValue=";
  result += to_string(*(NcAffineSelectInstance.onFalseValue.get()));
  result += ", ";
  result += "dtype=";
  if (NcAffineSelectInstance.dtype.has_value()) {
    result +=
        to_string(NcAffineSelectInstance.dtype.value()); // mapped from enum
  } else {
    result += "None";
  }
  result += ", ";
  result += "cmpOp=";
  result += to_string(NcAffineSelectInstance.cmpOp); // mapped from enum
  result += ")";
  return result;
};

std::string to_string(NcDmaCopy &NcDmaCopyInstance) {
  std::string result;
  result += "NcDmaCopy(";
  result += "dst=";
  result += to_string(*(NcDmaCopyInstance.dst.get()));
  result += ", ";
  result += "src=";
  result += to_string(*(NcDmaCopyInstance.src.get()));
  result += ", ";
  result += "compute_op=";
  result += to_string(NcDmaCopyInstance.compute_op); // mapped from enum
  result += ", ";
  result += "oobMode=";
  result += to_string(*(NcDmaCopyInstance.oobMode.get()));
  result += ", ";
  result += "dgeMode=";
  result += std::to_string(NcDmaCopyInstance.dgeMode);
  result += ", ";
  result += "uniqueIndices=";
  result += std::to_string(NcDmaCopyInstance.uniqueIndices);
  result += ", ";
  result += "engine=";
  result += to_string(NcDmaCopyInstance.engine); // mapped from enum
  result += ")";
  return result;
};

std::string to_string(NcLocalGather &NcLocalGatherInstance) {
  std::string result;
  result += "NcLocalGather(";
  result += "dst=";
  result += to_string(*(NcLocalGatherInstance.dst.get()));
  result += ", ";
  result += "src=";
  result += to_string(*(NcLocalGatherInstance.src.get()));
  result += ", ";
  result += "index=";
  result += to_string(*(NcLocalGatherInstance.index.get()));
  result += ", ";
  result += "numElemPerIdx=";
  result += to_string(*(NcLocalGatherInstance.numElemPerIdx.get()));
  result += ", ";
  result += "numValidIndicies=";
  if (NcLocalGatherInstance.numValidIndicies.has_value()) {
    result +=
        to_string(*(NcLocalGatherInstance.numValidIndicies.value().get()));
  } else {
    result += "None";
  }
  result += ")";
  return result;
};

std::string to_string(NcRangeSelect &NcRangeSelectInstance) {
  std::string result;
  result += "NcRangeSelect(";
  result += "dst=";
  result += to_string(*(NcRangeSelectInstance.dst.get()));
  result += ", ";
  result += "reduceCommand=";
  result += to_string(NcRangeSelectInstance.reduceCommand); // mapped from enum
  result += ", ";
  result += "reduceRes=";
  if (NcRangeSelectInstance.reduceRes.has_value()) {
    result += to_string(*(NcRangeSelectInstance.reduceRes.value().get()));
  } else {
    result += "None";
  }
  result += ", ";
  result += "reduceOp=";
  if (NcRangeSelectInstance.reduceOp.has_value()) {
    result +=
        to_string(NcRangeSelectInstance.reduceOp.value()); // mapped from enum
  } else {
    result += "None";
  }
  result += ", ";
  result += "compOp0=";
  result += to_string(NcRangeSelectInstance.compOp0); // mapped from enum
  result += ", ";
  result += "compOp1=";
  result += to_string(NcRangeSelectInstance.compOp1); // mapped from enum
  result += ", ";
  result += "bound0=";
  result += to_string(*(NcRangeSelectInstance.bound0.get()));
  result += ", ";
  result += "bound1=";
  result += to_string(*(NcRangeSelectInstance.bound1.get()));
  result += ", ";
  result += "rangeStart=";
  result += to_string(*(NcRangeSelectInstance.rangeStart.get()));
  result += ", ";
  result += "onTrueTile=";
  result += to_string(*(NcRangeSelectInstance.onTrueTile.get()));
  result += ", ";
  result += "onFalseValue=";
  result += to_string(*(NcRangeSelectInstance.onFalseValue.get()));
  result += ", ";
  result += "dtype=";
  if (NcRangeSelectInstance.dtype.has_value()) {
    result += to_string(NcRangeSelectInstance.dtype.value()); // mapped from
                                                              // enum
  } else {
    result += "None";
  }
  result += ")";
  return result;
};

std::string to_string(NcScalarTensorTensor &NcScalarTensorTensorInstance) {
  std::string result;
  result += "NcScalarTensorTensor(";
  result += "dst=";
  result += to_string(*(NcScalarTensorTensorInstance.dst.get()));
  result += ", ";
  result += "data=";
  result += to_string(*(NcScalarTensorTensorInstance.data.get()));
  result += ", ";
  result += "src0=";
  result += to_string(*(NcScalarTensorTensorInstance.src0.get()));
  result += ", ";
  result += "src1=";
  result += to_string(*(NcScalarTensorTensorInstance.src1.get()));
  result += ", ";
  result += "op0=";
  result += to_string(NcScalarTensorTensorInstance.op0); // mapped from enum
  result += ", ";
  result += "op1=";
  result += to_string(NcScalarTensorTensorInstance.op1); // mapped from enum
  result += ", ";
  result += "reverseOperands=";
  result += to_string(
      NcScalarTensorTensorInstance.reverseOperands); // mapped from enum
  result += ", ";
  result += "dtype=";
  if (NcScalarTensorTensorInstance.dtype.has_value()) {
    result += to_string(
        NcScalarTensorTensorInstance.dtype.value()); // mapped from enum
  } else {
    result += "None";
  }
  result += ")";
  return result;
};

std::string to_string(NcCopy &NcCopyInstance) {
  std::string result;
  result += "NcCopy(";
  result += "dst=";
  result += to_string(*(NcCopyInstance.dst.get()));
  result += ", ";
  result += "src=";
  result += to_string(*(NcCopyInstance.src.get()));
  result += ", ";
  result += "dtype=";
  if (NcCopyInstance.dtype.has_value()) {
    result += to_string(NcCopyInstance.dtype.value()); // mapped from enum
  } else {
    result += "None";
  }
  result += ", ";
  result += "engine=";
  result += to_string(NcCopyInstance.engine); // mapped from enum
  result += ")";
  return result;
};

std::string to_string(SelectReduce &SelectReduceInstance) {
  std::string result;
  result += "SelectReduce(";
  result += "dst=";
  result += to_string(*(SelectReduceInstance.dst.get()));
  result += ", ";
  result += "predicate=";
  result += to_string(*(SelectReduceInstance.predicate.get()));
  result += ", ";
  result += "onTrue=";
  result += to_string(*(SelectReduceInstance.onTrue.get()));
  result += ", ";
  result += "onFalse=";
  result += to_string(*(SelectReduceInstance.onFalse.get()));
  result += ", ";
  result += "reduceRes=";
  if (SelectReduceInstance.reduceRes.has_value()) {
    result += to_string(*(SelectReduceInstance.reduceRes.value().get()));
  } else {
    result += "None";
  }
  result += ", ";
  result += "reduceCmd=";
  result += to_string(SelectReduceInstance.reduceCmd); // mapped from enum
  result += ", ";
  result += "reduceOp=";
  result += to_string(SelectReduceInstance.reduceOp); // mapped from enum
  result += ", ";
  result += "reversePred=";
  result += std::to_string(SelectReduceInstance.reversePred);
  result += ", ";
  result += "dtype=";
  if (SelectReduceInstance.dtype.has_value()) {
    result += to_string(SelectReduceInstance.dtype.value()); // mapped from enum
  } else {
    result += "None";
  }
  result += ")";
  return result;
};

std::string to_string(SequenceBounds &SequenceBoundsInstance) {
  std::string result;
  result += "SequenceBounds(";
  result += "dst=";
  result += to_string(*(SequenceBoundsInstance.dst.get()));
  result += ", ";
  result += "segmentIds=";
  result += to_string(*(SequenceBoundsInstance.segmentIds.get()));
  result += ", ";
  result += "dtype=";
  if (SequenceBoundsInstance.dtype.has_value()) {
    result +=
        to_string(SequenceBoundsInstance.dtype.value()); // mapped from enum
  } else {
    result += "None";
  }
  result += ")";
  return result;
};

std::string to_string(SendRecv &SendRecvInstance) {
  std::string result;
  result += "SendRecv(";
  result += "dst=";
  result += to_string(*(SendRecvInstance.dst.get()));
  result += ", ";
  result += "src=";
  result += to_string(*(SendRecvInstance.src.get()));
  result += ", ";
  result += "sendToRank=";
  result += to_string(*(SendRecvInstance.sendToRank.get()));
  result += ", ";
  result += "recvFromRank=";
  result += to_string(*(SendRecvInstance.recvFromRank.get()));
  result += ", ";
  result += "pipeId=";
  result += to_string(*(SendRecvInstance.pipeId.get()));
  result += ", ";
  result += "useGpsimdDma=";
  result += std::to_string(SendRecvInstance.useGpsimdDma);
  result += ")";
  return result;
};

std::string to_string(SendRecvCompute &SendRecvComputeInstance) {
  std::string result;
  result += "SendRecvCompute(";
  result += "dsts=";
  {
    size_t i1 = 0;
    for (Ptr<TensorRef> printListLoopItem1 : SendRecvComputeInstance.dsts) {
      result += to_string(*(printListLoopItem1.get()));
      i1++;
      if (i1 < SendRecvComputeInstance.dsts.size())
        result += ", ";
    }
  }
  result += ", ";
  result += "srcs=";
  {
    size_t i1 = 0;
    for (Ptr<TensorRef> printListLoopItem1 : SendRecvComputeInstance.srcs) {
      result += to_string(*(printListLoopItem1.get()));
      i1++;
      if (i1 < SendRecvComputeInstance.srcs.size())
        result += ", ";
    }
  }
  result += ", ";
  result += "sendToRanks=";
  {
    size_t i1 = 0;
    for (Ptr<Immediate> printListLoopItem1 :
         SendRecvComputeInstance.sendToRanks) {
      result += to_string(*(printListLoopItem1.get()));
      i1++;
      if (i1 < SendRecvComputeInstance.sendToRanks.size())
        result += ", ";
    }
  }
  result += ", ";
  result += "recvFromRanks=";
  {
    size_t i1 = 0;
    for (Ptr<Immediate> printListLoopItem1 :
         SendRecvComputeInstance.recvFromRanks) {
      result += to_string(*(printListLoopItem1.get()));
      i1++;
      if (i1 < SendRecvComputeInstance.recvFromRanks.size())
        result += ", ";
    }
  }
  result += ", ";
  result += "pipeId=";
  result += to_string(*(SendRecvComputeInstance.pipeId.get()));
  result += ", ";
  result += "op=";
  result += to_string(SendRecvComputeInstance.op); // mapped from enum
  result += ")";
  return result;
};

std::string to_string(QuantizeMX &QuantizeMXInstance) {
  std::string result;
  result += "QuantizeMX(";
  result += "dst=";
  result += to_string(*(QuantizeMXInstance.dst.get()));
  result += ", ";
  result += "src=";
  result += to_string(*(QuantizeMXInstance.src.get()));
  result += ", ";
  result += "dstScale=";
  result += to_string(*(QuantizeMXInstance.dstScale.get()));
  result += ")";
  return result;
};

std::string to_string(MatMulMX &MatMulMXInstance) {
  std::string result;
  result += "MatMulMX(";
  result += "dst=";
  result += to_string(*(MatMulMXInstance.dst.get()));
  result += ", ";
  result += "stationary=";
  result += to_string(*(MatMulMXInstance.stationary.get()));
  result += ", ";
  result += "moving=";
  result += to_string(*(MatMulMXInstance.moving.get()));
  result += ", ";
  result += "stationaryScale=";
  result += to_string(*(MatMulMXInstance.stationaryScale.get()));
  result += ", ";
  result += "movingScale=";
  result += to_string(*(MatMulMXInstance.movingScale.get()));
  result += ", ";
  result += "tilePosition=";
  if (MatMulMXInstance.tilePosition.has_value()) {
    {
      size_t i1 = 0;
      for (Nat printListLoopItem1 : MatMulMXInstance.tilePosition.value()) {
        result += std::to_string(printListLoopItem1);
        i1++;
        if (i1 < MatMulMXInstance.tilePosition.value().size())
          result += ", ";
      }
    }
  } else {
    result += "None";
  }
  result += ", ";
  result += "tileSize=";
  if (MatMulMXInstance.tileSize.has_value()) {
    {
      size_t i1 = 0;
      for (Nat printListLoopItem1 : MatMulMXInstance.tileSize.value()) {
        result += std::to_string(printListLoopItem1);
        i1++;
        if (i1 < MatMulMXInstance.tileSize.value().size())
          result += ", ";
      }
    }
  } else {
    result += "None";
  }
  result += ")";
  return result;
};

std::string to_string(DmaCompute &DmaComputeInstance) {
  std::string result;
  result += "DmaCompute(";
  result += "dst=";
  result += to_string(*(DmaComputeInstance.dst.get()));
  result += ", ";
  result += "srcs=";
  {
    size_t i1 = 0;
    for (Ptr<TensorRef> printListLoopItem1 : DmaComputeInstance.srcs) {
      result += to_string(*(printListLoopItem1.get()));
      i1++;
      if (i1 < DmaComputeInstance.srcs.size())
        result += ", ";
    }
  }
  result += ", ";
  result += "scales=";
  {
    size_t i1 = 0;
    for (Ptr<Immediate> printListLoopItem1 : DmaComputeInstance.scales) {
      result += to_string(*(printListLoopItem1.get()));
      i1++;
      if (i1 < DmaComputeInstance.scales.size())
        result += ", ";
    }
  }
  result += ", ";
  result += "reduceOp=";
  result += to_string(DmaComputeInstance.reduceOp); // mapped from enum
  result += ")";
  return result;
};

std::string to_string(
    ReplicaGroupUnspecifiedWrapper &ReplicaGroupUnspecifiedWrapperInstance) {
  std::string result;
  result += "ReplicaGroupUnspecifiedWrapper(";
  result += ")";
  return result;
};
std::string
to_string(ReplicaGroupNamedWrapper &ReplicaGroupNamedWrapperInstance) {
  std::string result;
  result += "ReplicaGroupNamedWrapper(";
  result += "name=";
  result += ReplicaGroupNamedWrapperInstance.name;
  result += ")";
  return result;
};
std::string
to_string(ReplicaGroupLiteralWrapper &ReplicaGroupLiteralWrapperInstance) {
  std::string result;
  result += "ReplicaGroupLiteralWrapper(";
  result += "groups=";
  {
    size_t i1 = 0;
    for (List<Int> printListLoopItem1 :
         ReplicaGroupLiteralWrapperInstance.groups) {
      {
        size_t i2 = 0;
        for (Int printListLoopItem2 : printListLoopItem1) {
          result += std::to_string(printListLoopItem2);
          i2++;
          if (i2 < printListLoopItem1.size())
            result += ", ";
        }
      }
      i1++;
      if (i1 < ReplicaGroupLiteralWrapperInstance.groups.size())
        result += ", ";
    }
  }
  result += ")";
  return result;
};
std::string to_string(ReplicaGroup &ReplicaGroupInstance) {
  switch (ReplicaGroupInstance.tag) {
  case (ReplicaGroup::Tag::unspecified): {
    ReplicaGroupUnspecifiedWrapper &derivedRef =
        static_cast<ReplicaGroupUnspecifiedWrapper &>(ReplicaGroupInstance);
    return to_string(derivedRef);
  }
  case (ReplicaGroup::Tag::named): {
    ReplicaGroupNamedWrapper &derivedRef =
        static_cast<ReplicaGroupNamedWrapper &>(ReplicaGroupInstance);
    return to_string(derivedRef);
  }
  case (ReplicaGroup::Tag::literal): {
    ReplicaGroupLiteralWrapper &derivedRef =
        static_cast<ReplicaGroupLiteralWrapper &>(ReplicaGroupInstance);
    return to_string(derivedRef);
  }
  default:
    return "UNABLE TO PRINT";
  }
};

std::string to_string(CollectiveOp &CollectiveOpInstance) {
  std::string result;
  result += "CollectiveOp(";
  result += "dsts=";
  {
    size_t i1 = 0;
    for (Ptr<TensorRef> printListLoopItem1 : CollectiveOpInstance.dsts) {
      result += to_string(*(printListLoopItem1.get()));
      i1++;
      if (i1 < CollectiveOpInstance.dsts.size())
        result += ", ";
    }
  }
  result += ", ";
  result += "srcs=";
  {
    size_t i1 = 0;
    for (Ptr<TensorRef> printListLoopItem1 : CollectiveOpInstance.srcs) {
      result += to_string(*(printListLoopItem1.get()));
      i1++;
      if (i1 < CollectiveOpInstance.srcs.size())
        result += ", ";
    }
  }
  result += ", ";
  result += "op=";
  if (CollectiveOpInstance.op.has_value()) {
    result += to_string(CollectiveOpInstance.op.value()); // mapped from enum
  } else {
    result += "None";
  }
  result += ", ";
  result += "replicaGroup=";
  result += to_string(*(CollectiveOpInstance.replicaGroup.get()));
  result += ", ";
  result += "concatDim=";
  if (CollectiveOpInstance.concatDim.has_value()) {
    result += std::to_string(CollectiveOpInstance.concatDim.value());
  } else {
    result += "None";
  }
  result += ", ";
  result += "sourceTargetPairs=";
  if (CollectiveOpInstance.sourceTargetPairs.has_value()) {
    {
      size_t i1 = 0;
      for (List<Int> printListLoopItem1 :
           CollectiveOpInstance.sourceTargetPairs.value()) {
        {
          size_t i2 = 0;
          for (Int printListLoopItem2 : printListLoopItem1) {
            result += std::to_string(printListLoopItem2);
            i2++;
            if (i2 < printListLoopItem1.size())
              result += ", ";
          }
        }
        i1++;
        if (i1 < CollectiveOpInstance.sourceTargetPairs.value().size())
          result += ", ";
      }
    }
  } else {
    result += "None";
  }
  result += ", ";
  result += "channel_id=";
  if (CollectiveOpInstance.channel_id.has_value()) {
    result += std::to_string(CollectiveOpInstance.channel_id.value());
  } else {
    result += "None";
  }
  result += ", ";
  result += "num_channels=";
  if (CollectiveOpInstance.num_channels.has_value()) {
    result += std::to_string(CollectiveOpInstance.num_channels.value());
  } else {
    result += "None";
  }
  result += ")";
  return result;
};

std::string to_string(RankId &RankIdInstance) {
  std::string result;
  result += "RankId(";
  result += "dst=";
  result += RankIdInstance.dst;
  result += ")";
  return result;
};

std::string
to_string(CurrentProcessingRankId &CurrentProcessingRankIdInstance) {
  std::string result;
  result += "CurrentProcessingRankId(";
  result += "dst=";
  result += CurrentProcessingRankIdInstance.dst;
  result += ", ";
  result += "iterationId=";
  result += std::to_string(CurrentProcessingRankIdInstance.iterationId);
  result += ", ";
  result += "channelId=";
  result += std::to_string(CurrentProcessingRankIdInstance.channelId);
  result += ", ";
  result += "numChannels=";
  result += std::to_string(CurrentProcessingRankIdInstance.numChannels);
  result += ", ";
  result += "replicaGroup=";
  {
    size_t i1 = 0;
    for (List<Int> printListLoopItem1 :
         CurrentProcessingRankIdInstance.replicaGroup) {
      {
        size_t i2 = 0;
        for (Int printListLoopItem2 : printListLoopItem1) {
          result += std::to_string(printListLoopItem2);
          i2++;
          if (i2 < printListLoopItem1.size())
            result += ", ";
        }
      }
      i1++;
      if (i1 < CurrentProcessingRankIdInstance.replicaGroup.size())
        result += ", ";
    }
  }
  result += ")";
  return result;
};

std::string to_string(Send &SendInstance) {
  std::string result;
  result += "Send(";
  result += "op=";
  result += to_string(SendInstance.op); // mapped from enum
  result += ", ";
  result += "srcs=";
  {
    size_t i1 = 0;
    for (Ptr<TensorRef> printListLoopItem1 : SendInstance.srcs) {
      result += to_string(*(printListLoopItem1.get()));
      i1++;
      if (i1 < SendInstance.srcs.size())
        result += ", ";
    }
  }
  result += ", ";
  result += "peerId=";
  result += std::to_string(SendInstance.peerId);
  result += ")";
  return result;
};

std::string to_string(Recv &RecvInstance) {
  std::string result;
  result += "Recv(";
  result += "op=";
  result += to_string(RecvInstance.op); // mapped from enum
  result += ", ";
  result += "dsts=";
  {
    size_t i1 = 0;
    for (Ptr<TensorRef> printListLoopItem1 : RecvInstance.dsts) {
      result += to_string(*(printListLoopItem1.get()));
      i1++;
      if (i1 < RecvInstance.dsts.size())
        result += ", ";
    }
  }
  result += ", ";
  result += "replicaGroups=";
  {
    size_t i1 = 0;
    for (Int printListLoopItem1 : RecvInstance.replicaGroups) {
      result += std::to_string(printListLoopItem1);
      i1++;
      if (i1 < RecvInstance.replicaGroups.size())
        result += ", ";
    }
  }
  result += ", ";
  result += "peerId=";
  result += std::to_string(RecvInstance.peerId);
  result += ")";
  return result;
};

std::string to_string(BrCmpOp &BrCmpOpInstance) {
  switch (BrCmpOpInstance) {
  case BrCmpOp::always:
    return "always";
    break;
  case BrCmpOp::lt_imm:
    return "lt_imm";
    break;
  case BrCmpOp::le_imm:
    return "le_imm";
    break;
  case BrCmpOp::eq_imm:
    return "eq_imm";
    break;
  case BrCmpOp::ne_imm:
    return "ne_imm";
    break;
  case BrCmpOp::ge_imm:
    return "ge_imm";
    break;
  case BrCmpOp::gt_imm:
    return "gt_imm";
    break;
  case BrCmpOp::lt_reg:
    return "lt_reg";
    break;
  case BrCmpOp::le_reg:
    return "le_reg";
    break;
  case BrCmpOp::eq_reg:
    return "eq_reg";
    break;
  case BrCmpOp::ne_reg:
    return "ne_reg";
    break;
  case BrCmpOp::ge_reg:
    return "ge_reg";
    break;
  case BrCmpOp::gt_reg:
    return "gt_reg";
    break;
  default:
    return "UNABLE TO PRINT";
  }
};

std::string to_string(TensorLoad &TensorLoadInstance) {
  std::string result;
  result += "TensorLoad(";
  result += "dst=";
  result += TensorLoadInstance.dst;
  result += ", ";
  result += "src=";
  result += to_string(*(TensorLoadInstance.src.get()));
  result += ")";
  return result;
};

std::string to_string(TensorStore &TensorStoreInstance) {
  std::string result;
  result += "TensorStore(";
  result += "dst=";
  result += to_string(*(TensorStoreInstance.dst.get()));
  result += ", ";
  result += "src=";
  result += TensorStoreInstance.src;
  result += ")";
  return result;
};

std::string to_string(RegisterMove &RegisterMoveInstance) {
  std::string result;
  result += "RegisterMove(";
  result += "dst=";
  result += RegisterMoveInstance.dst;
  result += ", ";
  result += "imm=";
  result += std::to_string(RegisterMoveInstance.imm);
  result += ")";
  return result;
};

std::string to_string(CmpBranch &CmpBranchInstance) {
  std::string result;
  result += "CmpBranch(";
  result += "reg1=";
  result += CmpBranchInstance.reg1;
  result += ", ";
  result += "reg2=";
  result += CmpBranchInstance.reg2;
  result += ", ";
  result += "imm=";
  result += std::to_string(CmpBranchInstance.imm);
  result += ", ";
  result += "op=";
  result += to_string(CmpBranchInstance.op); // mapped from enum
  result += ", ";
  result += "trueLabel=";
  result += CmpBranchInstance.trueLabel;
  result += ", ";
  result += "falseLabel=";
  result += CmpBranchInstance.falseLabel;
  result += ")";
  return result;
};

std::string to_string(RegisterAluOp &RegisterAluOpInstance) {
  std::string result;
  result += "RegisterAluOp(";
  result += "dst=";
  result += RegisterAluOpInstance.dst;
  result += ", ";
  result += "src=";
  result += RegisterAluOpInstance.src;
  result += ", ";
  result += "imm=";
  result += std::to_string(RegisterAluOpInstance.imm);
  result += ", ";
  result += "op=";
  result += to_string(RegisterAluOpInstance.op); // mapped from enum
  result += ")";
  return result;
};

std::string to_string(CoreBarrier &CoreBarrierInstance) {
  std::string result;
  result += "CoreBarrier(";
  result += "data=";
  result += to_string(*(CoreBarrierInstance.data.get()));
  result += ", ";
  result += "cores=";
  {
    size_t i1 = 0;
    for (Int printListLoopItem1 : CoreBarrierInstance.cores) {
      result += std::to_string(printListLoopItem1);
      i1++;
      if (i1 < CoreBarrierInstance.cores.size())
        result += ", ";
    }
  }
  result += ", ";
  result += "engine=";
  result += to_string(CoreBarrierInstance.engine); // mapped from enum
  result += ")";
  return result;
};

std::string to_string(Rng &RngInstance) {
  std::string result;
  result += "Rng(";
  result += "dst=";
  result += to_string(*(RngInstance.dst.get()));
  result += ", ";
  result += "engine=";
  result += to_string(RngInstance.engine); // mapped from enum
  result += ")";
  return result;
};

std::string to_string(Rand2 &Rand2Instance) {
  std::string result;
  result += "Rand2(";
  result += "dst=";
  result += to_string(*(Rand2Instance.dst.get()));
  result += ", ";
  result += "min=";
  result += to_string(*(Rand2Instance.min.get()));
  result += ", ";
  result += "max=";
  result += to_string(*(Rand2Instance.max.get()));
  result += ")";
  return result;
};

std::string to_string(RandGetState &RandGetStateInstance) {
  std::string result;
  result += "RandGetState(";
  result += "dst=";
  result += to_string(*(RandGetStateInstance.dst.get()));
  result += ", ";
  result += "engine=";
  result += to_string(RandGetStateInstance.engine); // mapped from enum
  result += ")";
  return result;
};

std::string to_string(SetRngSeed &SetRngSeedInstance) {
  std::string result;
  result += "SetRngSeed(";
  result += "src=";
  result += to_string(*(SetRngSeedInstance.src.get()));
  result += ")";
  return result;
};

std::string to_string(RandSetState &RandSetStateInstance) {
  std::string result;
  result += "RandSetState(";
  result += "src=";
  result += to_string(*(RandSetStateInstance.src.get()));
  result += ", ";
  result += "engine=";
  result += to_string(RandSetStateInstance.engine); // mapped from enum
  result += ")";
  return result;
};

std::string to_string(ExtendedInst &ExtendedInstInstance) {
  std::string result;
  result += "ExtendedInst(";
  result += "opcode=";
  result += std::to_string(ExtendedInstInstance.opcode);
  result += ", ";
  result += "hasRead=";
  result += std::to_string(ExtendedInstInstance.hasRead);
  result += ", ";
  result += "hasWrite=";
  result += std::to_string(ExtendedInstInstance.hasWrite);
  result += ", ";
  result += "ports=";
  result += std::to_string(ExtendedInstInstance.ports);
  result += ", ";
  result += "data0=";
  {
    size_t i1 = 0;
    for (Nat printListLoopItem1 : ExtendedInstInstance.data0) {
      result += std::to_string(printListLoopItem1);
      i1++;
      if (i1 < ExtendedInstInstance.data0.size())
        result += ", ";
    }
  }
  result += ", ";
  result += "data1=";
  {
    size_t i1 = 0;
    for (Nat printListLoopItem1 : ExtendedInstInstance.data1) {
      result += std::to_string(printListLoopItem1);
      i1++;
      if (i1 < ExtendedInstInstance.data1.size())
        result += ", ";
    }
  }
  result += ")";
  return result;
};

std::string to_string(TensorScalarCumulative &TensorScalarCumulativeInstance) {
  std::string result;
  result += "TensorScalarCumulative(";
  result += "dst=";
  result += to_string(*(TensorScalarCumulativeInstance.dst.get()));
  result += ", ";
  result += "src=";
  result += to_string(*(TensorScalarCumulativeInstance.src.get()));
  result += ", ";
  result += "op0=";
  result += to_string(TensorScalarCumulativeInstance.op0); // mapped from enum
  result += ", ";
  result += "op1=";
  result += to_string(TensorScalarCumulativeInstance.op1); // mapped from enum
  result += ", ";
  result += "imm0=";
  result += to_string(*(TensorScalarCumulativeInstance.imm0.get()));
  result += ", ";
  result += "imm1=";
  if (TensorScalarCumulativeInstance.imm1.has_value()) {
    result += to_string(*(TensorScalarCumulativeInstance.imm1.value().get()));
  } else {
    result += "None";
  }
  result += ", ";
  result += "reduceCmd=";
  result +=
      to_string(TensorScalarCumulativeInstance.reduceCmd); // mapped from enum
  result += ", ";
  result += "reverse=";
  result +=
      to_string(TensorScalarCumulativeInstance.reverse); // mapped from enum
  result += ", ";
  result += "dtype=";
  if (TensorScalarCumulativeInstance.dtype.has_value()) {
    result += to_string(
        TensorScalarCumulativeInstance.dtype.value()); // mapped from enum
  } else {
    result += "None";
  }
  result += ")";
  return result;
};

std::string to_string(NcNGather &NcNGatherInstance) {
  std::string result;
  result += "NcNGather(";
  result += "dst=";
  result += to_string(*(NcNGatherInstance.dst.get()));
  result += ", ";
  result += "data=";
  result += to_string(*(NcNGatherInstance.data.get()));
  result += ", ";
  result += "indices=";
  result += to_string(*(NcNGatherInstance.indices.get()));
  result += ", ";
  result += "dtype=";
  if (NcNGatherInstance.dtype.has_value()) {
    result += to_string(NcNGatherInstance.dtype.value()); // mapped from enum
  } else {
    result += "None";
  }
  result += ")";
  return result;
};

std::string to_string(NonzeroWithCount &NonzeroWithCountInstance) {
  std::string result;
  result += "NonzeroWithCount(";
  result += "dst=";
  result += to_string(*(NonzeroWithCountInstance.dst.get()));
  result += ", ";
  result += "src=";
  result += to_string(*(NonzeroWithCountInstance.src.get()));
  result += ", ";
  result += "indexOffset=";
  result += to_string(*(NonzeroWithCountInstance.indexOffset.get()));
  result += ", ";
  result += "paddingVal=";
  result += to_string(*(NonzeroWithCountInstance.paddingVal.get()));
  result += ")";
  return result;
};

std::string to_string(PrintOutputBuffer &PrintOutputBufferInstance) {
  switch (PrintOutputBufferInstance) {
  case PrintOutputBuffer::stdout:
    return "stdout";
    break;
  case PrintOutputBuffer::stderr:
    return "stderr";
    break;
  default:
    return "UNABLE TO PRINT";
  }
};

std::string to_string(DevicePrint &DevicePrintInstance) {
  std::string result;
  result += "DevicePrint(";
  result += "src=";
  result += to_string(*(DevicePrintInstance.src.get()));
  result += ", ";
  result += "printPrefix=";
  result += DevicePrintInstance.printPrefix;
  result += ", ";
  result += "buffer=";
  result += to_string(DevicePrintInstance.buffer); // mapped from enum
  result += ")";
  return result;
};

std::string to_string(Exponential &ExponentialInstance) {
  std::string result;
  result += "Exponential(";
  result += "dst=";
  result += to_string(*(ExponentialInstance.dst.get()));
  result += ", ";
  result += "src=";
  result += to_string(*(ExponentialInstance.src.get()));
  result += ", ";
  result += "maxValue=";
  result += to_string(*(ExponentialInstance.maxValue.get()));
  result += ", ";
  result += "reduceRes=";
  if (ExponentialInstance.reduceRes.has_value()) {
    result += to_string(*(ExponentialInstance.reduceRes.value().get()));
  } else {
    result += "None";
  }
  result += ", ";
  result += "reducecmd=";
  result += to_string(ExponentialInstance.reducecmd); // mapped from enum
  result += ", ";
  result += "reduceInit=";
  result += to_string(*(ExponentialInstance.reduceInit.get()));
  result += ")";
  return result;
};

std::string to_string(Activate2 &Activate2Instance) {
  std::string result;
  result += "Activate2(";
  result += "dst=";
  result += to_string(*(Activate2Instance.dst.get()));
  result += ", ";
  result += "src=";
  result += to_string(*(Activate2Instance.src.get()));
  result += ", ";
  result += "op0=";
  result += to_string(Activate2Instance.op0); // mapped from enum
  result += ", ";
  result += "op1=";
  result += to_string(Activate2Instance.op1); // mapped from enum
  result += ", ";
  result += "imm0=";
  result += to_string(*(Activate2Instance.imm0.get()));
  result += ", ";
  result += "imm1=";
  result += to_string(*(Activate2Instance.imm1.get()));
  result += ", ";
  result += "activationFunc=";
  result += to_string(Activate2Instance.activationFunc); // mapped from enum
  result += ", ";
  result += "reluParam=";
  result += to_string(*(Activate2Instance.reluParam.get()));
  result += ", ";
  result += "reduceOp=";
  result += to_string(Activate2Instance.reduceOp); // mapped from enum
  result += ", ";
  result += "reduceRes=";
  if (Activate2Instance.reduceRes.has_value()) {
    result += to_string(*(Activate2Instance.reduceRes.value().get()));
  } else {
    result += "None";
  }
  result += ", ";
  result += "reduceCmd=";
  result += to_string(Activate2Instance.reduceCmd); // mapped from enum
  result += ", ";
  result += "reverse0=";
  result += std::to_string(Activate2Instance.reverse0);
  result += ", ";
  result += "reverse1=";
  result += std::to_string(Activate2Instance.reverse1);
  result += ", ";
  result += "dtype=";
  if (Activate2Instance.dtype.has_value()) {
    result += to_string(Activate2Instance.dtype.value()); // mapped from enum
  } else {
    result += "None";
  }
  result += ")";
  return result;
};

std::string to_string(DveReadAccumulator &DveReadAccumulatorInstance) {
  std::string result;
  result += "DveReadAccumulator(";
  result += "dst=";
  result += to_string(*(DveReadAccumulatorInstance.dst.get()));
  result += ", ";
  result += "negated=";
  result += std::to_string(DveReadAccumulatorInstance.negated);
  result += ")";
  return result;
};

std::string
to_string(OperatorActivateWrapper &OperatorActivateWrapperInstance) {
  std::string result;
  result += "OperatorActivateWrapper(";
  result += "op=";
  result += to_string(*(OperatorActivateWrapperInstance.op.get()));
  result += ")";
  return result;
};
std::string
to_string(OperatorNcActivateWrapper &OperatorNcActivateWrapperInstance) {
  std::string result;
  result += "OperatorNcActivateWrapper(";
  result += "op=";
  result += to_string(*(OperatorNcActivateWrapperInstance.op.get()));
  result += ")";
  return result;
};
std::string to_string(
    OperatorActivationReduceWrapper &OperatorActivationReduceWrapperInstance) {
  std::string result;
  result += "OperatorActivationReduceWrapper(";
  result += "op=";
  result += to_string(*(OperatorActivationReduceWrapperInstance.op.get()));
  result += ")";
  return result;
};
std::string
to_string(OperatorAffineSelectWrapper &OperatorAffineSelectWrapperInstance) {
  std::string result;
  result += "OperatorAffineSelectWrapper(";
  result += "op=";
  result += to_string(*(OperatorAffineSelectWrapperInstance.op.get()));
  result += ")";
  return result;
};
std::string to_string(
    OperatorNcAffineSelectWrapper &OperatorNcAffineSelectWrapperInstance) {
  std::string result;
  result += "OperatorNcAffineSelectWrapper(";
  result += "op=";
  result += to_string(*(OperatorNcAffineSelectWrapperInstance.op.get()));
  result += ")";
  return result;
};
std::string to_string(OperatorBatchNormAggregateWrapper
                          &OperatorBatchNormAggregateWrapperInstance) {
  std::string result;
  result += "OperatorBatchNormAggregateWrapper(";
  result += "op=";
  result += to_string(*(OperatorBatchNormAggregateWrapperInstance.op.get()));
  result += ")";
  return result;
};
std::string to_string(
    OperatorBatchNormStatsWrapper &OperatorBatchNormStatsWrapperInstance) {
  std::string result;
  result += "OperatorBatchNormStatsWrapper(";
  result += "op=";
  result += to_string(*(OperatorBatchNormStatsWrapperInstance.op.get()));
  result += ")";
  return result;
};
std::string to_string(OperatorCopyWrapper &OperatorCopyWrapperInstance) {
  std::string result;
  result += "OperatorCopyWrapper(";
  result += "op=";
  result += to_string(*(OperatorCopyWrapperInstance.op.get()));
  result += ")";
  return result;
};
std::string to_string(OperatorNcCopyWrapper &OperatorNcCopyWrapperInstance) {
  std::string result;
  result += "OperatorNcCopyWrapper(";
  result += "op=";
  result += to_string(*(OperatorNcCopyWrapperInstance.op.get()));
  result += ")";
  return result;
};
std::string to_string(
    OperatorCopyPredicatedWrapper &OperatorCopyPredicatedWrapperInstance) {
  std::string result;
  result += "OperatorCopyPredicatedWrapper(";
  result += "op=";
  result += to_string(*(OperatorCopyPredicatedWrapperInstance.op.get()));
  result += ")";
  return result;
};
std::string to_string(OperatorDmaCopyWrapper &OperatorDmaCopyWrapperInstance) {
  std::string result;
  result += "OperatorDmaCopyWrapper(";
  result += "op=";
  result += to_string(*(OperatorDmaCopyWrapperInstance.op.get()));
  result += ")";
  return result;
};
std::string
to_string(OperatorNcDmaCopyWrapper &OperatorNcDmaCopyWrapperInstance) {
  std::string result;
  result += "OperatorNcDmaCopyWrapper(";
  result += "op=";
  result += to_string(*(OperatorNcDmaCopyWrapperInstance.op.get()));
  result += ")";
  return result;
};
std::string
to_string(OperatorDmaTransposeWrapper &OperatorDmaTransposeWrapperInstance) {
  std::string result;
  result += "OperatorDmaTransposeWrapper(";
  result += "op=";
  result += to_string(*(OperatorDmaTransposeWrapperInstance.op.get()));
  result += ")";
  return result;
};
std::string to_string(OperatorDropoutWrapper &OperatorDropoutWrapperInstance) {
  std::string result;
  result += "OperatorDropoutWrapper(";
  result += "op=";
  result += to_string(*(OperatorDropoutWrapperInstance.op.get()));
  result += ")";
  return result;
};
std::string
to_string(OperatorFindIndex8Wrapper &OperatorFindIndex8WrapperInstance) {
  std::string result;
  result += "OperatorFindIndex8Wrapper(";
  result += "op=";
  result += to_string(*(OperatorFindIndex8WrapperInstance.op.get()));
  result += ")";
  return result;
};
std::string to_string(OperatorIotaWrapper &OperatorIotaWrapperInstance) {
  std::string result;
  result += "OperatorIotaWrapper(";
  result += "op=";
  result += to_string(*(OperatorIotaWrapperInstance.op.get()));
  result += ")";
  return result;
};
std::string to_string(
    OperatorLoadMaskRegisterWrapper &OperatorLoadMaskRegisterWrapperInstance) {
  std::string result;
  result += "OperatorLoadMaskRegisterWrapper(";
  result += "op=";
  result += to_string(*(OperatorLoadMaskRegisterWrapperInstance.op.get()));
  result += ")";
  return result;
};
std::string to_string(
    OperatorLoadStationaryWrapper &OperatorLoadStationaryWrapperInstance) {
  std::string result;
  result += "OperatorLoadStationaryWrapper(";
  result += "op=";
  result += to_string(*(OperatorLoadStationaryWrapperInstance.op.get()));
  result += ")";
  return result;
};
std::string
to_string(OperatorLocalGatherWrapper &OperatorLocalGatherWrapperInstance) {
  std::string result;
  result += "OperatorLocalGatherWrapper(";
  result += "op=";
  result += to_string(*(OperatorLocalGatherWrapperInstance.op.get()));
  result += ")";
  return result;
};
std::string
to_string(OperatorNcLocalGatherWrapper &OperatorNcLocalGatherWrapperInstance) {
  std::string result;
  result += "OperatorNcLocalGatherWrapper(";
  result += "op=";
  result += to_string(*(OperatorNcLocalGatherWrapperInstance.op.get()));
  result += ")";
  return result;
};
std::string to_string(OperatorMatMulWrapper &OperatorMatMulWrapperInstance) {
  std::string result;
  result += "OperatorMatMulWrapper(";
  result += "op=";
  result += to_string(*(OperatorMatMulWrapperInstance.op.get()));
  result += ")";
  return result;
};
std::string
to_string(OperatorNcMatMulWrapper &OperatorNcMatMulWrapperInstance) {
  std::string result;
  result += "OperatorNcMatMulWrapper(";
  result += "op=";
  result += to_string(*(OperatorNcMatMulWrapperInstance.op.get()));
  result += ")";
  return result;
};
std::string
to_string(OperatorMatchReplace8Wrapper &OperatorMatchReplace8WrapperInstance) {
  std::string result;
  result += "OperatorMatchReplace8Wrapper(";
  result += "op=";
  result += to_string(*(OperatorMatchReplace8WrapperInstance.op.get()));
  result += ")";
  return result;
};
std::string to_string(
    OperatorMatchValueLoadWrapper &OperatorMatchValueLoadWrapperInstance) {
  std::string result;
  result += "OperatorMatchValueLoadWrapper(";
  result += "op=";
  result += to_string(*(OperatorMatchValueLoadWrapperInstance.op.get()));
  result += ")";
  return result;
};
std::string to_string(OperatorMax8Wrapper &OperatorMax8WrapperInstance) {
  std::string result;
  result += "OperatorMax8Wrapper(";
  result += "op=";
  result += to_string(*(OperatorMax8WrapperInstance.op.get()));
  result += ")";
  return result;
};
std::string to_string(OperatorMemSetWrapper &OperatorMemSetWrapperInstance) {
  std::string result;
  result += "OperatorMemSetWrapper(";
  result += "op=";
  result += to_string(*(OperatorMemSetWrapperInstance.op.get()));
  result += ")";
  return result;
};
std::string
to_string(OperatorRangeSelectWrapper &OperatorRangeSelectWrapperInstance) {
  std::string result;
  result += "OperatorRangeSelectWrapper(";
  result += "op=";
  result += to_string(*(OperatorRangeSelectWrapperInstance.op.get()));
  result += ")";
  return result;
};
std::string
to_string(OperatorNcRangeSelectWrapper &OperatorNcRangeSelectWrapperInstance) {
  std::string result;
  result += "OperatorNcRangeSelectWrapper(";
  result += "op=";
  result += to_string(*(OperatorNcRangeSelectWrapperInstance.op.get()));
  result += ")";
  return result;
};
std::string
to_string(OperatorReciprocalWrapper &OperatorReciprocalWrapperInstance) {
  std::string result;
  result += "OperatorReciprocalWrapper(";
  result += "op=";
  result += to_string(*(OperatorReciprocalWrapperInstance.op.get()));
  result += ")";
  return result;
};
std::string to_string(OperatorScalarTensorTensorWrapper
                          &OperatorScalarTensorTensorWrapperInstance) {
  std::string result;
  result += "OperatorScalarTensorTensorWrapper(";
  result += "op=";
  result += to_string(*(OperatorScalarTensorTensorWrapperInstance.op.get()));
  result += ")";
  return result;
};
std::string to_string(OperatorNcScalarTensorTensorWrapper
                          &OperatorNcScalarTensorTensorWrapperInstance) {
  std::string result;
  result += "OperatorNcScalarTensorTensorWrapper(";
  result += "op=";
  result += to_string(*(OperatorNcScalarTensorTensorWrapperInstance.op.get()));
  result += ")";
  return result;
};
std::string to_string(OperatorShuffleWrapper &OperatorShuffleWrapperInstance) {
  std::string result;
  result += "OperatorShuffleWrapper(";
  result += "op=";
  result += to_string(*(OperatorShuffleWrapperInstance.op.get()));
  result += ")";
  return result;
};
std::string
to_string(OperatorTensorReduceWrapper &OperatorTensorReduceWrapperInstance) {
  std::string result;
  result += "OperatorTensorReduceWrapper(";
  result += "op=";
  result += to_string(*(OperatorTensorReduceWrapperInstance.op.get()));
  result += ")";
  return result;
};
std::string
to_string(OperatorTensorScalarWrapper &OperatorTensorScalarWrapperInstance) {
  std::string result;
  result += "OperatorTensorScalarWrapper(";
  result += "op=";
  result += to_string(*(OperatorTensorScalarWrapperInstance.op.get()));
  result += ")";
  return result;
};
std::string
to_string(OperatorTensorTensorWrapper &OperatorTensorTensorWrapperInstance) {
  std::string result;
  result += "OperatorTensorTensorWrapper(";
  result += "op=";
  result += to_string(*(OperatorTensorTensorWrapperInstance.op.get()));
  result += ")";
  return result;
};
std::string to_string(
    OperatorTensorTensorScanWrapper &OperatorTensorTensorScanWrapperInstance) {
  std::string result;
  result += "OperatorTensorTensorScanWrapper(";
  result += "op=";
  result += to_string(*(OperatorTensorTensorScanWrapperInstance.op.get()));
  result += ")";
  return result;
};
std::string to_string(OperatorTensorPartitionReduceWrapper
                          &OperatorTensorPartitionReduceWrapperInstance) {
  std::string result;
  result += "OperatorTensorPartitionReduceWrapper(";
  result += "op=";
  result += to_string(*(OperatorTensorPartitionReduceWrapperInstance.op.get()));
  result += ")";
  return result;
};
std::string to_string(OperatorTensorScalarReduceWrapper
                          &OperatorTensorScalarReduceWrapperInstance) {
  std::string result;
  result += "OperatorTensorScalarReduceWrapper(";
  result += "op=";
  result += to_string(*(OperatorTensorScalarReduceWrapperInstance.op.get()));
  result += ")";
  return result;
};
std::string
to_string(OperatorTransposeWrapper &OperatorTransposeWrapperInstance) {
  std::string result;
  result += "OperatorTransposeWrapper(";
  result += "op=";
  result += to_string(*(OperatorTransposeWrapperInstance.op.get()));
  result += ")";
  return result;
};
std::string
to_string(OperatorSelectReduceWrapper &OperatorSelectReduceWrapperInstance) {
  std::string result;
  result += "OperatorSelectReduceWrapper(";
  result += "op=";
  result += to_string(*(OperatorSelectReduceWrapperInstance.op.get()));
  result += ")";
  return result;
};
std::string to_string(
    OperatorSequenceBoundsWrapper &OperatorSequenceBoundsWrapperInstance) {
  std::string result;
  result += "OperatorSequenceBoundsWrapper(";
  result += "op=";
  result += to_string(*(OperatorSequenceBoundsWrapperInstance.op.get()));
  result += ")";
  return result;
};
std::string
to_string(OperatorSendRecvWrapper &OperatorSendRecvWrapperInstance) {
  std::string result;
  result += "OperatorSendRecvWrapper(";
  result += "op=";
  result += to_string(*(OperatorSendRecvWrapperInstance.op.get()));
  result += ")";
  return result;
};
std::string to_string(
    OperatorSendRecvComputeWrapper &OperatorSendRecvComputeWrapperInstance) {
  std::string result;
  result += "OperatorSendRecvComputeWrapper(";
  result += "op=";
  result += to_string(*(OperatorSendRecvComputeWrapperInstance.op.get()));
  result += ")";
  return result;
};
std::string
to_string(OperatorTensorLoadWrapper &OperatorTensorLoadWrapperInstance) {
  std::string result;
  result += "OperatorTensorLoadWrapper(";
  result += "op=";
  result += to_string(*(OperatorTensorLoadWrapperInstance.op.get()));
  result += ")";
  return result;
};
std::string
to_string(OperatorTensorStoreWrapper &OperatorTensorStoreWrapperInstance) {
  std::string result;
  result += "OperatorTensorStoreWrapper(";
  result += "op=";
  result += to_string(*(OperatorTensorStoreWrapperInstance.op.get()));
  result += ")";
  return result;
};
std::string
to_string(OperatorRegisterMoveWrapper &OperatorRegisterMoveWrapperInstance) {
  std::string result;
  result += "OperatorRegisterMoveWrapper(";
  result += "op=";
  result += to_string(*(OperatorRegisterMoveWrapperInstance.op.get()));
  result += ")";
  return result;
};
std::string
to_string(OperatorCmpBranchWrapper &OperatorCmpBranchWrapperInstance) {
  std::string result;
  result += "OperatorCmpBranchWrapper(";
  result += "op=";
  result += to_string(*(OperatorCmpBranchWrapperInstance.op.get()));
  result += ")";
  return result;
};
std::string
to_string(OperatorRegisterAluOpWrapper &OperatorRegisterAluOpWrapperInstance) {
  std::string result;
  result += "OperatorRegisterAluOpWrapper(";
  result += "op=";
  result += to_string(*(OperatorRegisterAluOpWrapperInstance.op.get()));
  result += ")";
  return result;
};
std::string
to_string(OperatorQuantizeMXWrapper &OperatorQuantizeMXWrapperInstance) {
  std::string result;
  result += "OperatorQuantizeMXWrapper(";
  result += "op=";
  result += to_string(*(OperatorQuantizeMXWrapperInstance.op.get()));
  result += ")";
  return result;
};
std::string
to_string(OperatorNcMatMulMXWrapper &OperatorNcMatMulMXWrapperInstance) {
  std::string result;
  result += "OperatorNcMatMulMXWrapper(";
  result += "op=";
  result += to_string(*(OperatorNcMatMulMXWrapperInstance.op.get()));
  result += ")";
  return result;
};
std::string
to_string(OperatorDmaComputeWrapper &OperatorDmaComputeWrapperInstance) {
  std::string result;
  result += "OperatorDmaComputeWrapper(";
  result += "op=";
  result += to_string(*(OperatorDmaComputeWrapperInstance.op.get()));
  result += ")";
  return result;
};
std::string
to_string(OperatorAllReduceWrapper &OperatorAllReduceWrapperInstance) {
  std::string result;
  result += "OperatorAllReduceWrapper(";
  result += "op=";
  result += to_string(*(OperatorAllReduceWrapperInstance.op.get()));
  result += ")";
  return result;
};
std::string
to_string(OperatorAllGatherWrapper &OperatorAllGatherWrapperInstance) {
  std::string result;
  result += "OperatorAllGatherWrapper(";
  result += "op=";
  result += to_string(*(OperatorAllGatherWrapperInstance.op.get()));
  result += ")";
  return result;
};
std::string
to_string(OperatorReduceScatterWrapper &OperatorReduceScatterWrapperInstance) {
  std::string result;
  result += "OperatorReduceScatterWrapper(";
  result += "op=";
  result += to_string(*(OperatorReduceScatterWrapperInstance.op.get()));
  result += ")";
  return result;
};
std::string to_string(OperatorCollectivePermuteWrapper
                          &OperatorCollectivePermuteWrapperInstance) {
  std::string result;
  result += "OperatorCollectivePermuteWrapper(";
  result += "op=";
  result += to_string(*(OperatorCollectivePermuteWrapperInstance.op.get()));
  result += ")";
  return result;
};
std::string to_string(OperatorCollectivePermuteImplicitWrapper
                          &OperatorCollectivePermuteImplicitWrapperInstance) {
  std::string result;
  result += "OperatorCollectivePermuteImplicitWrapper(";
  result += "op=";
  result +=
      to_string(*(OperatorCollectivePermuteImplicitWrapperInstance.op.get()));
  result += ")";
  return result;
};
std::string
to_string(OperatorCollectivePermuteImplicitReduceWrapper
              &OperatorCollectivePermuteImplicitReduceWrapperInstance) {
  std::string result;
  result += "OperatorCollectivePermuteImplicitReduceWrapper(";
  result += "op=";
  result += to_string(
      *(OperatorCollectivePermuteImplicitReduceWrapperInstance.op.get()));
  result += ")";
  return result;
};
std::string
to_string(OperatorBroadcastWrapper &OperatorBroadcastWrapperInstance) {
  std::string result;
  result += "OperatorBroadcastWrapper(";
  result += "op=";
  result += to_string(*(OperatorBroadcastWrapperInstance.op.get()));
  result += ")";
  return result;
};
std::string
to_string(OperatorAllToAllWrapper &OperatorAllToAllWrapperInstance) {
  std::string result;
  result += "OperatorAllToAllWrapper(";
  result += "op=";
  result += to_string(*(OperatorAllToAllWrapperInstance.op.get()));
  result += ")";
  return result;
};
std::string to_string(OperatorRankIdWrapper &OperatorRankIdWrapperInstance) {
  std::string result;
  result += "OperatorRankIdWrapper(";
  result += "op=";
  result += to_string(*(OperatorRankIdWrapperInstance.op.get()));
  result += ")";
  return result;
};
std::string to_string(OperatorCurrentProcessingRankIdWrapper
                          &OperatorCurrentProcessingRankIdWrapperInstance) {
  std::string result;
  result += "OperatorCurrentProcessingRankIdWrapper(";
  result += "op=";
  result +=
      to_string(*(OperatorCurrentProcessingRankIdWrapperInstance.op.get()));
  result += ")";
  return result;
};
std::string to_string(OperatorSendWrapper &OperatorSendWrapperInstance) {
  std::string result;
  result += "OperatorSendWrapper(";
  result += "op=";
  result += to_string(*(OperatorSendWrapperInstance.op.get()));
  result += ")";
  return result;
};
std::string to_string(OperatorRecvWrapper &OperatorRecvWrapperInstance) {
  std::string result;
  result += "OperatorRecvWrapper(";
  result += "op=";
  result += to_string(*(OperatorRecvWrapperInstance.op.get()));
  result += ")";
  return result;
};
std::string
to_string(OperatorCoreBarrierWrapper &OperatorCoreBarrierWrapperInstance) {
  std::string result;
  result += "OperatorCoreBarrierWrapper(";
  result += "op=";
  result += to_string(*(OperatorCoreBarrierWrapperInstance.op.get()));
  result += ")";
  return result;
};
std::string to_string(OperatorRngWrapper &OperatorRngWrapperInstance) {
  std::string result;
  result += "OperatorRngWrapper(";
  result += "op=";
  result += to_string(*(OperatorRngWrapperInstance.op.get()));
  result += ")";
  return result;
};
std::string to_string(OperatorRand2Wrapper &OperatorRand2WrapperInstance) {
  std::string result;
  result += "OperatorRand2Wrapper(";
  result += "op=";
  result += to_string(*(OperatorRand2WrapperInstance.op.get()));
  result += ")";
  return result;
};
std::string
to_string(OperatorRandGetStateWrapper &OperatorRandGetStateWrapperInstance) {
  std::string result;
  result += "OperatorRandGetStateWrapper(";
  result += "op=";
  result += to_string(*(OperatorRandGetStateWrapperInstance.op.get()));
  result += ")";
  return result;
};
std::string
to_string(OperatorSetRngSeedWrapper &OperatorSetRngSeedWrapperInstance) {
  std::string result;
  result += "OperatorSetRngSeedWrapper(";
  result += "op=";
  result += to_string(*(OperatorSetRngSeedWrapperInstance.op.get()));
  result += ")";
  return result;
};
std::string
to_string(OperatorRandSetStateWrapper &OperatorRandSetStateWrapperInstance) {
  std::string result;
  result += "OperatorRandSetStateWrapper(";
  result += "op=";
  result += to_string(*(OperatorRandSetStateWrapperInstance.op.get()));
  result += ")";
  return result;
};
std::string
to_string(OperatorExtendedInstWrapper &OperatorExtendedInstWrapperInstance) {
  std::string result;
  result += "OperatorExtendedInstWrapper(";
  result += "op=";
  result += to_string(*(OperatorExtendedInstWrapperInstance.op.get()));
  result += ")";
  return result;
};
std::string to_string(OperatorTensorScalarCumulativeWrapper
                          &OperatorTensorScalarCumulativeWrapperInstance) {
  std::string result;
  result += "OperatorTensorScalarCumulativeWrapper(";
  result += "op=";
  result +=
      to_string(*(OperatorTensorScalarCumulativeWrapperInstance.op.get()));
  result += ")";
  return result;
};
std::string
to_string(OperatorNcNGatherWrapper &OperatorNcNGatherWrapperInstance) {
  std::string result;
  result += "OperatorNcNGatherWrapper(";
  result += "op=";
  result += to_string(*(OperatorNcNGatherWrapperInstance.op.get()));
  result += ")";
  return result;
};
std::string to_string(
    OperatorNonzeroWithCountWrapper &OperatorNonzeroWithCountWrapperInstance) {
  std::string result;
  result += "OperatorNonzeroWithCountWrapper(";
  result += "op=";
  result += to_string(*(OperatorNonzeroWithCountWrapperInstance.op.get()));
  result += ")";
  return result;
};
std::string
to_string(OperatorDevicePrintWrapper &OperatorDevicePrintWrapperInstance) {
  std::string result;
  result += "OperatorDevicePrintWrapper(";
  result += "op=";
  result += to_string(*(OperatorDevicePrintWrapperInstance.op.get()));
  result += ")";
  return result;
};
std::string
to_string(OperatorExponentialWrapper &OperatorExponentialWrapperInstance) {
  std::string result;
  result += "OperatorExponentialWrapper(";
  result += "op=";
  result += to_string(*(OperatorExponentialWrapperInstance.op.get()));
  result += ")";
  return result;
};
std::string
to_string(OperatorActivate2Wrapper &OperatorActivate2WrapperInstance) {
  std::string result;
  result += "OperatorActivate2Wrapper(";
  result += "op=";
  result += to_string(*(OperatorActivate2WrapperInstance.op.get()));
  result += ")";
  return result;
};
std::string to_string(OperatorDveReadAccumulatorWrapper
                          &OperatorDveReadAccumulatorWrapperInstance) {
  std::string result;
  result += "OperatorDveReadAccumulatorWrapper(";
  result += "op=";
  result += to_string(*(OperatorDveReadAccumulatorWrapperInstance.op.get()));
  result += ")";
  return result;
};
std::string to_string(Operator &OperatorInstance) {
  switch (OperatorInstance.tag) {
  case (Operator::Tag::activate): {
    OperatorActivateWrapper &derivedRef =
        static_cast<OperatorActivateWrapper &>(OperatorInstance);
    return to_string(derivedRef);
  }
  case (Operator::Tag::ncActivate): {
    OperatorNcActivateWrapper &derivedRef =
        static_cast<OperatorNcActivateWrapper &>(OperatorInstance);
    return to_string(derivedRef);
  }
  case (Operator::Tag::activationReduce): {
    OperatorActivationReduceWrapper &derivedRef =
        static_cast<OperatorActivationReduceWrapper &>(OperatorInstance);
    return to_string(derivedRef);
  }
  case (Operator::Tag::affineSelect): {
    OperatorAffineSelectWrapper &derivedRef =
        static_cast<OperatorAffineSelectWrapper &>(OperatorInstance);
    return to_string(derivedRef);
  }
  case (Operator::Tag::ncAffineSelect): {
    OperatorNcAffineSelectWrapper &derivedRef =
        static_cast<OperatorNcAffineSelectWrapper &>(OperatorInstance);
    return to_string(derivedRef);
  }
  case (Operator::Tag::batchNormAggregate): {
    OperatorBatchNormAggregateWrapper &derivedRef =
        static_cast<OperatorBatchNormAggregateWrapper &>(OperatorInstance);
    return to_string(derivedRef);
  }
  case (Operator::Tag::batchNormStats): {
    OperatorBatchNormStatsWrapper &derivedRef =
        static_cast<OperatorBatchNormStatsWrapper &>(OperatorInstance);
    return to_string(derivedRef);
  }
  case (Operator::Tag::copy): {
    OperatorCopyWrapper &derivedRef =
        static_cast<OperatorCopyWrapper &>(OperatorInstance);
    return to_string(derivedRef);
  }
  case (Operator::Tag::ncCopy): {
    OperatorNcCopyWrapper &derivedRef =
        static_cast<OperatorNcCopyWrapper &>(OperatorInstance);
    return to_string(derivedRef);
  }
  case (Operator::Tag::copyPredicated): {
    OperatorCopyPredicatedWrapper &derivedRef =
        static_cast<OperatorCopyPredicatedWrapper &>(OperatorInstance);
    return to_string(derivedRef);
  }
  case (Operator::Tag::dmaCopy): {
    OperatorDmaCopyWrapper &derivedRef =
        static_cast<OperatorDmaCopyWrapper &>(OperatorInstance);
    return to_string(derivedRef);
  }
  case (Operator::Tag::ncDmaCopy): {
    OperatorNcDmaCopyWrapper &derivedRef =
        static_cast<OperatorNcDmaCopyWrapper &>(OperatorInstance);
    return to_string(derivedRef);
  }
  case (Operator::Tag::dmaTranspose): {
    OperatorDmaTransposeWrapper &derivedRef =
        static_cast<OperatorDmaTransposeWrapper &>(OperatorInstance);
    return to_string(derivedRef);
  }
  case (Operator::Tag::dropout): {
    OperatorDropoutWrapper &derivedRef =
        static_cast<OperatorDropoutWrapper &>(OperatorInstance);
    return to_string(derivedRef);
  }
  case (Operator::Tag::findIndex8): {
    OperatorFindIndex8Wrapper &derivedRef =
        static_cast<OperatorFindIndex8Wrapper &>(OperatorInstance);
    return to_string(derivedRef);
  }
  case (Operator::Tag::iota): {
    OperatorIotaWrapper &derivedRef =
        static_cast<OperatorIotaWrapper &>(OperatorInstance);
    return to_string(derivedRef);
  }
  case (Operator::Tag::loadMaskRegister): {
    OperatorLoadMaskRegisterWrapper &derivedRef =
        static_cast<OperatorLoadMaskRegisterWrapper &>(OperatorInstance);
    return to_string(derivedRef);
  }
  case (Operator::Tag::loadStationary): {
    OperatorLoadStationaryWrapper &derivedRef =
        static_cast<OperatorLoadStationaryWrapper &>(OperatorInstance);
    return to_string(derivedRef);
  }
  case (Operator::Tag::localGather): {
    OperatorLocalGatherWrapper &derivedRef =
        static_cast<OperatorLocalGatherWrapper &>(OperatorInstance);
    return to_string(derivedRef);
  }
  case (Operator::Tag::ncLocalGather): {
    OperatorNcLocalGatherWrapper &derivedRef =
        static_cast<OperatorNcLocalGatherWrapper &>(OperatorInstance);
    return to_string(derivedRef);
  }
  case (Operator::Tag::matMul): {
    OperatorMatMulWrapper &derivedRef =
        static_cast<OperatorMatMulWrapper &>(OperatorInstance);
    return to_string(derivedRef);
  }
  case (Operator::Tag::ncMatMul): {
    OperatorNcMatMulWrapper &derivedRef =
        static_cast<OperatorNcMatMulWrapper &>(OperatorInstance);
    return to_string(derivedRef);
  }
  case (Operator::Tag::matchReplace8): {
    OperatorMatchReplace8Wrapper &derivedRef =
        static_cast<OperatorMatchReplace8Wrapper &>(OperatorInstance);
    return to_string(derivedRef);
  }
  case (Operator::Tag::matchValueLoad): {
    OperatorMatchValueLoadWrapper &derivedRef =
        static_cast<OperatorMatchValueLoadWrapper &>(OperatorInstance);
    return to_string(derivedRef);
  }
  case (Operator::Tag::max8): {
    OperatorMax8Wrapper &derivedRef =
        static_cast<OperatorMax8Wrapper &>(OperatorInstance);
    return to_string(derivedRef);
  }
  case (Operator::Tag::memSet): {
    OperatorMemSetWrapper &derivedRef =
        static_cast<OperatorMemSetWrapper &>(OperatorInstance);
    return to_string(derivedRef);
  }
  case (Operator::Tag::rangeSelect): {
    OperatorRangeSelectWrapper &derivedRef =
        static_cast<OperatorRangeSelectWrapper &>(OperatorInstance);
    return to_string(derivedRef);
  }
  case (Operator::Tag::ncRangeSelect): {
    OperatorNcRangeSelectWrapper &derivedRef =
        static_cast<OperatorNcRangeSelectWrapper &>(OperatorInstance);
    return to_string(derivedRef);
  }
  case (Operator::Tag::reciprocal): {
    OperatorReciprocalWrapper &derivedRef =
        static_cast<OperatorReciprocalWrapper &>(OperatorInstance);
    return to_string(derivedRef);
  }
  case (Operator::Tag::scalarTensorTensor): {
    OperatorScalarTensorTensorWrapper &derivedRef =
        static_cast<OperatorScalarTensorTensorWrapper &>(OperatorInstance);
    return to_string(derivedRef);
  }
  case (Operator::Tag::ncScalarTensorTensor): {
    OperatorNcScalarTensorTensorWrapper &derivedRef =
        static_cast<OperatorNcScalarTensorTensorWrapper &>(OperatorInstance);
    return to_string(derivedRef);
  }
  case (Operator::Tag::shuffle): {
    OperatorShuffleWrapper &derivedRef =
        static_cast<OperatorShuffleWrapper &>(OperatorInstance);
    return to_string(derivedRef);
  }
  case (Operator::Tag::tensorReduce): {
    OperatorTensorReduceWrapper &derivedRef =
        static_cast<OperatorTensorReduceWrapper &>(OperatorInstance);
    return to_string(derivedRef);
  }
  case (Operator::Tag::tensorScalar): {
    OperatorTensorScalarWrapper &derivedRef =
        static_cast<OperatorTensorScalarWrapper &>(OperatorInstance);
    return to_string(derivedRef);
  }
  case (Operator::Tag::tensorTensor): {
    OperatorTensorTensorWrapper &derivedRef =
        static_cast<OperatorTensorTensorWrapper &>(OperatorInstance);
    return to_string(derivedRef);
  }
  case (Operator::Tag::tensorTensorScan): {
    OperatorTensorTensorScanWrapper &derivedRef =
        static_cast<OperatorTensorTensorScanWrapper &>(OperatorInstance);
    return to_string(derivedRef);
  }
  case (Operator::Tag::tensorPartitionReduce): {
    OperatorTensorPartitionReduceWrapper &derivedRef =
        static_cast<OperatorTensorPartitionReduceWrapper &>(OperatorInstance);
    return to_string(derivedRef);
  }
  case (Operator::Tag::tensorScalarReduce): {
    OperatorTensorScalarReduceWrapper &derivedRef =
        static_cast<OperatorTensorScalarReduceWrapper &>(OperatorInstance);
    return to_string(derivedRef);
  }
  case (Operator::Tag::transpose): {
    OperatorTransposeWrapper &derivedRef =
        static_cast<OperatorTransposeWrapper &>(OperatorInstance);
    return to_string(derivedRef);
  }
  case (Operator::Tag::selectReduce): {
    OperatorSelectReduceWrapper &derivedRef =
        static_cast<OperatorSelectReduceWrapper &>(OperatorInstance);
    return to_string(derivedRef);
  }
  case (Operator::Tag::sequenceBounds): {
    OperatorSequenceBoundsWrapper &derivedRef =
        static_cast<OperatorSequenceBoundsWrapper &>(OperatorInstance);
    return to_string(derivedRef);
  }
  case (Operator::Tag::sendRecv): {
    OperatorSendRecvWrapper &derivedRef =
        static_cast<OperatorSendRecvWrapper &>(OperatorInstance);
    return to_string(derivedRef);
  }
  case (Operator::Tag::sendRecvCompute): {
    OperatorSendRecvComputeWrapper &derivedRef =
        static_cast<OperatorSendRecvComputeWrapper &>(OperatorInstance);
    return to_string(derivedRef);
  }
  case (Operator::Tag::tensorLoad): {
    OperatorTensorLoadWrapper &derivedRef =
        static_cast<OperatorTensorLoadWrapper &>(OperatorInstance);
    return to_string(derivedRef);
  }
  case (Operator::Tag::tensorStore): {
    OperatorTensorStoreWrapper &derivedRef =
        static_cast<OperatorTensorStoreWrapper &>(OperatorInstance);
    return to_string(derivedRef);
  }
  case (Operator::Tag::registerMove): {
    OperatorRegisterMoveWrapper &derivedRef =
        static_cast<OperatorRegisterMoveWrapper &>(OperatorInstance);
    return to_string(derivedRef);
  }
  case (Operator::Tag::cmpBranch): {
    OperatorCmpBranchWrapper &derivedRef =
        static_cast<OperatorCmpBranchWrapper &>(OperatorInstance);
    return to_string(derivedRef);
  }
  case (Operator::Tag::registerAluOp): {
    OperatorRegisterAluOpWrapper &derivedRef =
        static_cast<OperatorRegisterAluOpWrapper &>(OperatorInstance);
    return to_string(derivedRef);
  }
  case (Operator::Tag::quantizeMX): {
    OperatorQuantizeMXWrapper &derivedRef =
        static_cast<OperatorQuantizeMXWrapper &>(OperatorInstance);
    return to_string(derivedRef);
  }
  case (Operator::Tag::ncMatMulMX): {
    OperatorNcMatMulMXWrapper &derivedRef =
        static_cast<OperatorNcMatMulMXWrapper &>(OperatorInstance);
    return to_string(derivedRef);
  }
  case (Operator::Tag::dmaCompute): {
    OperatorDmaComputeWrapper &derivedRef =
        static_cast<OperatorDmaComputeWrapper &>(OperatorInstance);
    return to_string(derivedRef);
  }
  case (Operator::Tag::allReduce): {
    OperatorAllReduceWrapper &derivedRef =
        static_cast<OperatorAllReduceWrapper &>(OperatorInstance);
    return to_string(derivedRef);
  }
  case (Operator::Tag::allGather): {
    OperatorAllGatherWrapper &derivedRef =
        static_cast<OperatorAllGatherWrapper &>(OperatorInstance);
    return to_string(derivedRef);
  }
  case (Operator::Tag::reduceScatter): {
    OperatorReduceScatterWrapper &derivedRef =
        static_cast<OperatorReduceScatterWrapper &>(OperatorInstance);
    return to_string(derivedRef);
  }
  case (Operator::Tag::collectivePermute): {
    OperatorCollectivePermuteWrapper &derivedRef =
        static_cast<OperatorCollectivePermuteWrapper &>(OperatorInstance);
    return to_string(derivedRef);
  }
  case (Operator::Tag::collectivePermuteImplicit): {
    OperatorCollectivePermuteImplicitWrapper &derivedRef =
        static_cast<OperatorCollectivePermuteImplicitWrapper &>(
            OperatorInstance);
    return to_string(derivedRef);
  }
  case (Operator::Tag::collectivePermuteImplicitReduce): {
    OperatorCollectivePermuteImplicitReduceWrapper &derivedRef =
        static_cast<OperatorCollectivePermuteImplicitReduceWrapper &>(
            OperatorInstance);
    return to_string(derivedRef);
  }
  case (Operator::Tag::broadcast): {
    OperatorBroadcastWrapper &derivedRef =
        static_cast<OperatorBroadcastWrapper &>(OperatorInstance);
    return to_string(derivedRef);
  }
  case (Operator::Tag::allToAll): {
    OperatorAllToAllWrapper &derivedRef =
        static_cast<OperatorAllToAllWrapper &>(OperatorInstance);
    return to_string(derivedRef);
  }
  case (Operator::Tag::rankId): {
    OperatorRankIdWrapper &derivedRef =
        static_cast<OperatorRankIdWrapper &>(OperatorInstance);
    return to_string(derivedRef);
  }
  case (Operator::Tag::currentProcessingRankId): {
    OperatorCurrentProcessingRankIdWrapper &derivedRef =
        static_cast<OperatorCurrentProcessingRankIdWrapper &>(OperatorInstance);
    return to_string(derivedRef);
  }
  case (Operator::Tag::send): {
    OperatorSendWrapper &derivedRef =
        static_cast<OperatorSendWrapper &>(OperatorInstance);
    return to_string(derivedRef);
  }
  case (Operator::Tag::recv): {
    OperatorRecvWrapper &derivedRef =
        static_cast<OperatorRecvWrapper &>(OperatorInstance);
    return to_string(derivedRef);
  }
  case (Operator::Tag::coreBarrier): {
    OperatorCoreBarrierWrapper &derivedRef =
        static_cast<OperatorCoreBarrierWrapper &>(OperatorInstance);
    return to_string(derivedRef);
  }
  case (Operator::Tag::rng): {
    OperatorRngWrapper &derivedRef =
        static_cast<OperatorRngWrapper &>(OperatorInstance);
    return to_string(derivedRef);
  }
  case (Operator::Tag::rand2): {
    OperatorRand2Wrapper &derivedRef =
        static_cast<OperatorRand2Wrapper &>(OperatorInstance);
    return to_string(derivedRef);
  }
  case (Operator::Tag::randGetState): {
    OperatorRandGetStateWrapper &derivedRef =
        static_cast<OperatorRandGetStateWrapper &>(OperatorInstance);
    return to_string(derivedRef);
  }
  case (Operator::Tag::setRngSeed): {
    OperatorSetRngSeedWrapper &derivedRef =
        static_cast<OperatorSetRngSeedWrapper &>(OperatorInstance);
    return to_string(derivedRef);
  }
  case (Operator::Tag::randSetState): {
    OperatorRandSetStateWrapper &derivedRef =
        static_cast<OperatorRandSetStateWrapper &>(OperatorInstance);
    return to_string(derivedRef);
  }
  case (Operator::Tag::extendedInst): {
    OperatorExtendedInstWrapper &derivedRef =
        static_cast<OperatorExtendedInstWrapper &>(OperatorInstance);
    return to_string(derivedRef);
  }
  case (Operator::Tag::tensorScalarCumulative): {
    OperatorTensorScalarCumulativeWrapper &derivedRef =
        static_cast<OperatorTensorScalarCumulativeWrapper &>(OperatorInstance);
    return to_string(derivedRef);
  }
  case (Operator::Tag::ncNGather): {
    OperatorNcNGatherWrapper &derivedRef =
        static_cast<OperatorNcNGatherWrapper &>(OperatorInstance);
    return to_string(derivedRef);
  }
  case (Operator::Tag::nonzeroWithCount): {
    OperatorNonzeroWithCountWrapper &derivedRef =
        static_cast<OperatorNonzeroWithCountWrapper &>(OperatorInstance);
    return to_string(derivedRef);
  }
  case (Operator::Tag::devicePrint): {
    OperatorDevicePrintWrapper &derivedRef =
        static_cast<OperatorDevicePrintWrapper &>(OperatorInstance);
    return to_string(derivedRef);
  }
  case (Operator::Tag::exponential): {
    OperatorExponentialWrapper &derivedRef =
        static_cast<OperatorExponentialWrapper &>(OperatorInstance);
    return to_string(derivedRef);
  }
  case (Operator::Tag::activate2): {
    OperatorActivate2Wrapper &derivedRef =
        static_cast<OperatorActivate2Wrapper &>(OperatorInstance);
    return to_string(derivedRef);
  }
  case (Operator::Tag::dveReadAccumulator): {
    OperatorDveReadAccumulatorWrapper &derivedRef =
        static_cast<OperatorDveReadAccumulatorWrapper &>(OperatorInstance);
    return to_string(derivedRef);
  }
  default:
    return "UNABLE TO PRINT";
  }
};

std::string to_string(StmtOperWrapper &StmtOperWrapperInstance) {
  std::string result;
  result += "StmtOperWrapper(";
  result += "op=";
  result += to_string(*(StmtOperWrapperInstance.op.get()));
  result += ", ";
  result += "name=";
  if (StmtOperWrapperInstance.name.has_value()) {
    result += StmtOperWrapperInstance.name.value();
  } else {
    result += "None";
  }
  result += ", ";
  result += "pos=";
  result += to_string(*(StmtOperWrapperInstance.pos.get()));
  result += ")";
  return result;
};
std::string to_string(Stmt &StmtInstance) {
  switch (StmtInstance.tag) {
  case (Stmt::Tag::oper): {
    StmtOperWrapper &derivedRef = static_cast<StmtOperWrapper &>(StmtInstance);
    return to_string(derivedRef);
  }
  default:
    return "UNABLE TO PRINT";
  }
};

std::string to_string(Block &BlockInstance) {
  std::string result;
  result += "Block(";
  result += "label=";
  result += BlockInstance.label;
  result += ", ";
  result += "body=";
  {
    size_t i1 = 0;
    for (Ptr<Stmt> printListLoopItem1 : BlockInstance.body) {
      result += to_string(*(printListLoopItem1.get()));
      i1++;
      if (i1 < BlockInstance.body.size())
        result += ", ";
    }
  }
  result += ")";
  return result;
};

std::string to_string(Kernel &KernelInstance) {
  std::string result;
  result += "Kernel(";
  result += "name=";
  result += KernelInstance.name;
  result += ", ";
  result += "inputs=";
  {
    size_t i1 = 0;
    for (Ptr<TensorName> printListLoopItem1 : KernelInstance.inputs) {
      result += to_string(*(printListLoopItem1.get()));
      i1++;
      if (i1 < KernelInstance.inputs.size())
        result += ", ";
    }
  }
  result += ", ";
  result += "outputs=";
  {
    size_t i1 = 0;
    for (Ptr<TensorName> printListLoopItem1 : KernelInstance.outputs) {
      result += to_string(*(printListLoopItem1.get()));
      i1++;
      if (i1 < KernelInstance.outputs.size())
        result += ", ";
    }
  }
  result += ", ";
  result += "body=";
  {
    size_t i1 = 0;
    for (Ptr<Block> printListLoopItem1 : KernelInstance.body) {
      result += to_string(*(printListLoopItem1.get()));
      i1++;
      if (i1 < KernelInstance.body.size())
        result += ", ";
    }
  }
  result += ")";
  return result;
};

std::string to_string(SharedConstantFile &SharedConstantFileInstance) {
  std::string result;
  result += "SharedConstantFile(";
  result += "name=";
  result += SharedConstantFileInstance.name;
  result += ", ";
  result += "fileName=";
  result += SharedConstantFileInstance.fileName;
  result += ")";
  return result;
};

std::string to_string(Edges &EdgesInstance) {
  std::string result;
  result += "Edges(";
  result += "fromEdge=";
  result += EdgesInstance.fromEdge;
  result += ", ";
  result += "toEdges=";
  {
    size_t i1 = 0;
    for (String printListLoopItem1 : EdgesInstance.toEdges) {
      result += printListLoopItem1;
      i1++;
      if (i1 < EdgesInstance.toEdges.size())
        result += ", ";
    }
  }
  result += ")";
  return result;
};

std::string to_string(LncKernel &LncKernelInstance) {
  std::string result;
  result += "LncKernel(";
  result += "name=";
  result += LncKernelInstance.name;
  result += ", ";
  result += "inputs=";
  {
    size_t i1 = 0;
    for (Ptr<TensorName> printListLoopItem1 : LncKernelInstance.inputs) {
      result += to_string(*(printListLoopItem1.get()));
      i1++;
      if (i1 < LncKernelInstance.inputs.size())
        result += ", ";
    }
  }
  result += ", ";
  result += "outputs=";
  {
    size_t i1 = 0;
    for (Ptr<TensorName> printListLoopItem1 : LncKernelInstance.outputs) {
      result += to_string(*(printListLoopItem1.get()));
      i1++;
      if (i1 < LncKernelInstance.outputs.size())
        result += ", ";
    }
  }
  result += ", ";
  result += "bodies=";
  {
    size_t i1 = 0;
    for (List<Ptr<Block>> printListLoopItem1 : LncKernelInstance.bodies) {
      {
        size_t i2 = 0;
        for (Ptr<Block> printListLoopItem2 : printListLoopItem1) {
          result += to_string(*(printListLoopItem2.get()));
          i2++;
          if (i2 < printListLoopItem1.size())
            result += ", ";
        }
      }
      i1++;
      if (i1 < LncKernelInstance.bodies.size())
        result += ", ";
    }
  }
  result += ", ";
  result += "sharedConstants=";
  {
    size_t i1 = 0;
    for (Ptr<SharedConstantFile> printListLoopItem1 :
         LncKernelInstance.sharedConstants) {
      result += to_string(*(printListLoopItem1.get()));
      i1++;
      if (i1 < LncKernelInstance.sharedConstants.size())
        result += ", ";
    }
  }
  result += ", ";
  result += "sharedBuffers=";
  {
    size_t i1 = 0;
    for (Ptr<TensorName> printListLoopItem1 : LncKernelInstance.sharedBuffers) {
      result += to_string(*(printListLoopItem1.get()));
      i1++;
      if (i1 < LncKernelInstance.sharedBuffers.size())
        result += ", ";
    }
  }
  result += ", ";
  result += "edges=";
  {
    size_t i1 = 0;
    for (Ptr<Edges> printListLoopItem1 : LncKernelInstance.edges) {
      result += to_string(*(printListLoopItem1.get()));
      i1++;
      if (i1 < LncKernelInstance.edges.size())
        result += ", ";
    }
  }
  result += ")";
  return result;
};

std::string to_string(KLRFile &KLRFileInstance) {
  std::string result;
  result += "KLRFile(";
  result += "major=";
  result += std::to_string(KLRFileInstance.major);
  result += ", ";
  result += "minor=";
  result += std::to_string(KLRFileInstance.minor);
  result += ", ";
  result += "patch=";
  result += std::to_string(KLRFileInstance.patch);
  result += ")";
  return result;
};

std::string to_string(KLRMetaData &KLRMetaDataInstance) {
  std::string result;
  result += "KLRMetaData(";
  result += "format=";
  result += KLRMetaDataInstance.format;
  result += ")";
  return result;
};

std::string to_string(ContentsPythonWrapper &ContentsPythonWrapperInstance) {
  std::string result;
  result += "ContentsPythonWrapper(";
  result += "kernel=";
  result += to_string(*(ContentsPythonWrapperInstance.kernel.get()));
  result += ")";
  return result;
};
std::string to_string(ContentsNkiWrapper &ContentsNkiWrapperInstance) {
  std::string result;
  result += "ContentsNkiWrapper(";
  result += "kernel=";
  result += to_string(*(ContentsNkiWrapperInstance.kernel.get()));
  result += ")";
  return result;
};
std::string to_string(ContentsKernelWrapper &ContentsKernelWrapperInstance) {
  std::string result;
  result += "ContentsKernelWrapper(";
  result += "kernel=";
  result += to_string(*(ContentsKernelWrapperInstance.kernel.get()));
  result += ")";
  return result;
};
std::string to_string(ContentsLncWrapper &ContentsLncWrapperInstance) {
  std::string result;
  result += "ContentsLncWrapper(";
  result += "kernel=";
  result += to_string(*(ContentsLncWrapperInstance.kernel.get()));
  result += ")";
  return result;
};
std::string to_string(ContentsHloWrapper &ContentsHloWrapperInstance) {
  std::string result;
  result += "ContentsHloWrapper(";
  result += "name=";
  result += ContentsHloWrapperInstance.name;
  result += ")";
  return result;
};
std::string to_string(Contents &ContentsInstance) {
  switch (ContentsInstance.tag) {
  case (Contents::Tag::python): {
    ContentsPythonWrapper &derivedRef =
        static_cast<ContentsPythonWrapper &>(ContentsInstance);
    return to_string(derivedRef);
  }
  case (Contents::Tag::nki): {
    ContentsNkiWrapper &derivedRef =
        static_cast<ContentsNkiWrapper &>(ContentsInstance);
    return to_string(derivedRef);
  }
  case (Contents::Tag::kernel): {
    ContentsKernelWrapper &derivedRef =
        static_cast<ContentsKernelWrapper &>(ContentsInstance);
    return to_string(derivedRef);
  }
  case (Contents::Tag::lnc): {
    ContentsLncWrapper &derivedRef =
        static_cast<ContentsLncWrapper &>(ContentsInstance);
    return to_string(derivedRef);
  }
  case (Contents::Tag::hlo): {
    ContentsHloWrapper &derivedRef =
        static_cast<ContentsHloWrapper &>(ContentsInstance);
    return to_string(derivedRef);
  }
  default:
    return "UNABLE TO PRINT";
  }
};
} // namespace klr
