/*
Copyright (c) 2025 Amazon.com, Inc. or its affiliates. All Rights Reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Written by the KLR Contributors (https://github.com/leanprover/KLR)
*/
#pragma once

// This file is automatically generated from KLR.
// Manual edits to this file will be overwritten.

#include "klir_common.hpp"
#include "klir_ast.hpp"

namespace klr {

bool List_Bool_ser(FILE *out, const List<Bool> &value);
bool List_Nat_ser(FILE *out, const List<Nat> &value);
bool List_Int_ser(FILE *out, const List<Int> &value);
bool List_Float_ser(FILE *out, const List<Float> &value);
bool List_String_ser(FILE *out, const List<String> &value);
bool Option_Bool_ser(FILE *out, const Option<Bool> &value);
bool Option_Nat_ser(FILE *out, const Option<Nat> &value);
bool Option_Int_ser(FILE *out, const Option<Int> &value);
bool Option_Float_ser(FILE *out, const Option<Float> &value);
bool Option_String_ser(FILE *out, const Option<String> &value);
bool Option_List_Bool_ser(FILE *out, const Option<List<Bool>> &value);
bool Option_List_Nat_ser(FILE *out, const Option<List<Nat>> &value);
bool Option_List_Int_ser(FILE *out, const Option<List<Int>> &value);
bool Option_List_Float_ser(FILE *out, const Option<List<Float>> &value);
bool Option_List_String_ser(FILE *out, const Option<List<String>> &value);
bool List_List_Bool_ser(FILE *out, const List<List<Bool>> &value);
bool List_List_Nat_ser(FILE *out, const List<List<Nat>> &value);
bool List_List_Int_ser(FILE *out, const List<List<Int>> &value);
bool List_List_Float_ser(FILE *out, const List<List<Float>> &value);
bool List_List_String_ser(FILE *out, const List<List<String>> &value);
bool Option_List_List_Bool_ser(FILE *out,
                               const Option<List<List<Bool>>> &value);
bool Option_List_List_Nat_ser(FILE *out, const Option<List<List<Nat>>> &value);
bool Option_List_List_Int_ser(FILE *out, const Option<List<List<Int>>> &value);
bool Option_List_List_Float_ser(FILE *out,
                                const Option<List<List<Float>>> &value);
bool Option_List_List_String_ser(FILE *out,
                                 const Option<List<List<String>>> &value);
bool Pos_ser(FILE *out, const Ptr<Pos> &value);

List<Bool> List_Bool_des(FILE *in);
List<Nat> List_Nat_des(FILE *in);
List<Int> List_Int_des(FILE *in);
List<Float> List_Float_des(FILE *in);
List<String> List_String_des(FILE *in);
Option<Bool> Option_Bool_des(FILE *in);
Option<Nat> Option_Nat_des(FILE *in);
Option<Int> Option_Int_des(FILE *in);
Option<Float> Option_Float_des(FILE *in);
Option<String> Option_String_des(FILE *in);
Option<List<Bool>> Option_List_Bool_des(FILE *in);
Option<List<Nat>> Option_List_Nat_des(FILE *in);
Option<List<Int>> Option_List_Int_des(FILE *in);
Option<List<Float>> Option_List_Float_des(FILE *in);
Option<List<String>> Option_List_String_des(FILE *in);
List<List<Bool>> List_List_Bool_des(FILE *in);
List<List<Nat>> List_List_Nat_des(FILE *in);
List<List<Int>> List_List_Int_des(FILE *in);
List<List<Float>> List_List_Float_des(FILE *in);
List<List<String>> List_List_String_des(FILE *in);
Option<List<List<Bool>>> Option_List_List_Bool_des(FILE *in);
Option<List<List<Nat>>> Option_List_List_Nat_des(FILE *in);
Option<List<List<Int>>> Option_List_List_Int_des(FILE *in);
Option<List<List<Float>>> Option_List_List_Float_des(FILE *in);
Option<List<List<String>>> Option_List_List_String_des(FILE *in);
Ptr<Pos> Pos_des(FILE *in);
bool Immediate_ser(FILE *out, const Ptr<Immediate> &value);
bool Memory_ser(FILE *out, const Memory &value);
bool Dtype_ser(FILE *out, const Dtype &value);
bool Shape_ser(FILE *out, const Ptr<Shape> &value);
bool Address_ser(FILE *out, const Ptr<Address> &value);
bool TensorName_ser(FILE *out, const Ptr<TensorName> &value);
bool Slice_ser(FILE *out, const Ptr<Slice> &value);
bool Index_ser(FILE *out, const Ptr<Index> &value);
bool AccessBasic_ser(FILE *out, const Ptr<AccessBasic> &value);
bool APPair_ser(FILE *out, const Ptr<APPair> &value);
bool AccessPattern_ser(FILE *out, const Ptr<AccessPattern> &value);
bool ScalarOffset_ser(FILE *out, const Ptr<ScalarOffset> &value);
bool BirAccessPattern_ser(FILE *out, const Ptr<BirAccessPattern> &value);
bool Access_ser(FILE *out, const Ptr<Access> &value);
bool TensorHbm_ser(FILE *out, const Ptr<TensorHbm> &value);
bool TensorSram_ser(FILE *out, const Ptr<TensorSram> &value);
bool TensorRef_ser(FILE *out, const Ptr<TensorRef> &value);
bool MatmulPerfMode_ser(FILE *out, const MatmulPerfMode &value);
bool Engine_ser(FILE *out, const Engine &value);
bool ActivationImm_ser(FILE *out, const Ptr<ActivationImm> &value);
bool Operand_ser(FILE *out, const Ptr<Operand> &value);
bool DataPattern_ser(FILE *out, const Ptr<DataPattern> &value);
bool AluOp_ser(FILE *out, const AluOp &value);
bool DropoutThresholdType_ser(FILE *out, const DropoutThresholdType &value);
bool AccumCmd_ser(FILE *out, const AccumCmd &value);
bool ActivationFunc_ser(FILE *out, const ActivationFunc &value);
bool AffineSelectCmp_ser(FILE *out, const AffineSelectCmp &value);
bool DgeComputeOp_ser(FILE *out, const DgeComputeOp &value);
bool DmaBounds_ser(FILE *out, const Ptr<DmaBounds> &value);
bool MatmulGroupElement_ser(FILE *out, const MatmulGroupElement &value);
bool IndexMissBehavior_ser(FILE *out, const Ptr<IndexMissBehavior> &value);
bool TensorScalarReverseOps_ser(FILE *out, const TensorScalarReverseOps &value);
bool TensorSubDim_ser(FILE *out, const TensorSubDim &value);
bool TransposeOps_ser(FILE *out, const TransposeOps &value);
bool Dropout_ser(FILE *out, const Ptr<Dropout> &value);
bool Activate_ser(FILE *out, const Ptr<Activate> &value);
bool AffineSelect_ser(FILE *out, const Ptr<AffineSelect> &value);
bool DmaCopy_ser(FILE *out, const Ptr<DmaCopy> &value);
bool DmaTranspose_ser(FILE *out, const Ptr<DmaTranspose> &value);
bool Transpose_ser(FILE *out, const Ptr<Transpose> &value);
bool LoadMaskRegister_ser(FILE *out, const Ptr<LoadMaskRegister> &value);
bool Shuffle_ser(FILE *out, const Ptr<Shuffle> &value);
bool MemSet_ser(FILE *out, const Ptr<MemSet> &value);
bool Iota_ser(FILE *out, const Ptr<Iota> &value);
bool LoadStationary_ser(FILE *out, const Ptr<LoadStationary> &value);
bool MatMul_ser(FILE *out, const Ptr<MatMul> &value);
bool LocalGather_ser(FILE *out, const Ptr<LocalGather> &value);
bool RangeSelect_ser(FILE *out, const Ptr<RangeSelect> &value);
bool ScalarTensorTensor_ser(FILE *out, const Ptr<ScalarTensorTensor> &value);
bool CopyPredicated_ser(FILE *out, const Ptr<CopyPredicated> &value);
bool TensorTensorScan_ser(FILE *out, const Ptr<TensorTensorScan> &value);
bool MatchValueLoad_ser(FILE *out, const Ptr<MatchValueLoad> &value);
bool FindIndex8_ser(FILE *out, const Ptr<FindIndex8> &value);
bool MatchReplace8_ser(FILE *out, const Ptr<MatchReplace8> &value);
bool Max8_ser(FILE *out, const Ptr<Max8> &value);
bool BatchNormAggregate_ser(FILE *out, const Ptr<BatchNormAggregate> &value);
bool BatchNormStats_ser(FILE *out, const Ptr<BatchNormStats> &value);
bool Reciprocal_ser(FILE *out, const Ptr<Reciprocal> &value);
bool Copy_ser(FILE *out, const Ptr<Copy> &value);
bool TensorReduce_ser(FILE *out, const Ptr<TensorReduce> &value);
bool TensorScalar_ser(FILE *out, const Ptr<TensorScalar> &value);
bool TensorTensor_ser(FILE *out, const Ptr<TensorTensor> &value);
bool NcMatMul_ser(FILE *out, const Ptr<NcMatMul> &value);
bool TensorScalarReduce_ser(FILE *out, const Ptr<TensorScalarReduce> &value);
bool TensorPartitionReduce_ser(FILE *out,
                               const Ptr<TensorPartitionReduce> &value);
bool NcActivate_ser(FILE *out, const Ptr<NcActivate> &value);
bool NcAffineSelect_ser(FILE *out, const Ptr<NcAffineSelect> &value);
bool NcDmaCopy_ser(FILE *out, const Ptr<NcDmaCopy> &value);
bool NcLocalGather_ser(FILE *out, const Ptr<NcLocalGather> &value);
bool NcRangeSelect_ser(FILE *out, const Ptr<NcRangeSelect> &value);
bool NcScalarTensorTensor_ser(FILE *out,
                              const Ptr<NcScalarTensorTensor> &value);
bool NcCopy_ser(FILE *out, const Ptr<NcCopy> &value);
bool SelectReduce_ser(FILE *out, const Ptr<SelectReduce> &value);
bool SequenceBounds_ser(FILE *out, const Ptr<SequenceBounds> &value);
bool SendRecv_ser(FILE *out, const Ptr<SendRecv> &value);
bool SendRecvCompute_ser(FILE *out, const Ptr<SendRecvCompute> &value);
bool QuantizeMX_ser(FILE *out, const Ptr<QuantizeMX> &value);
bool MatMulMX_ser(FILE *out, const Ptr<MatMulMX> &value);
bool DmaCompute_ser(FILE *out, const Ptr<DmaCompute> &value);
bool ReplicaGroup_ser(FILE *out, const Ptr<ReplicaGroup> &value);
bool CollectiveOp_ser(FILE *out, const Ptr<CollectiveOp> &value);
bool RankId_ser(FILE *out, const Ptr<RankId> &value);
bool CurrentProcessingRankId_ser(FILE *out,
                                 const Ptr<CurrentProcessingRankId> &value);
bool Send_ser(FILE *out, const Ptr<Send> &value);
bool Recv_ser(FILE *out, const Ptr<Recv> &value);
bool BrCmpOp_ser(FILE *out, const BrCmpOp &value);
bool TensorLoad_ser(FILE *out, const Ptr<TensorLoad> &value);
bool TensorStore_ser(FILE *out, const Ptr<TensorStore> &value);
bool RegisterMove_ser(FILE *out, const Ptr<RegisterMove> &value);
bool CmpBranch_ser(FILE *out, const Ptr<CmpBranch> &value);
bool RegisterAluOp_ser(FILE *out, const Ptr<RegisterAluOp> &value);
bool CoreBarrier_ser(FILE *out, const Ptr<CoreBarrier> &value);
bool Rng_ser(FILE *out, const Ptr<Rng> &value);
bool Rand2_ser(FILE *out, const Ptr<Rand2> &value);
bool RandGetState_ser(FILE *out, const Ptr<RandGetState> &value);
bool SetRngSeed_ser(FILE *out, const Ptr<SetRngSeed> &value);
bool RandSetState_ser(FILE *out, const Ptr<RandSetState> &value);
bool ExtendedInst_ser(FILE *out, const Ptr<ExtendedInst> &value);
bool TensorScalarCumulative_ser(FILE *out,
                                const Ptr<TensorScalarCumulative> &value);
bool NcNGather_ser(FILE *out, const Ptr<NcNGather> &value);
bool NonzeroWithCount_ser(FILE *out, const Ptr<NonzeroWithCount> &value);
bool PrintOutputBuffer_ser(FILE *out, const PrintOutputBuffer &value);
bool DevicePrint_ser(FILE *out, const Ptr<DevicePrint> &value);
bool Operator_ser(FILE *out, const Ptr<Operator> &value);
bool Stmt_ser(FILE *out, const Ptr<Stmt> &value);
bool Block_ser(FILE *out, const Ptr<Block> &value);
bool Kernel_ser(FILE *out, const Ptr<Kernel> &value);
bool SharedConstantFile_ser(FILE *out, const Ptr<SharedConstantFile> &value);
bool Edges_ser(FILE *out, const Ptr<Edges> &value);
bool LncKernel_ser(FILE *out, const Ptr<LncKernel> &value);
bool List_Index_ser(FILE *out, const List<Ptr<Index>> &value);
bool List_APPair_ser(FILE *out, const List<Ptr<APPair>> &value);
bool Option_ScalarOffset_ser(FILE *out, const Option<Ptr<ScalarOffset>> &value);
bool Option_Access_ser(FILE *out, const Option<Ptr<Access>> &value);
bool Option_Dtype_ser(FILE *out, const Option<Dtype> &value);
bool List_Immediate_ser(FILE *out, const List<Ptr<Immediate>> &value);
bool Option_TensorRef_ser(FILE *out, const Option<Ptr<TensorRef>> &value);
bool Option_TensorSubDim_ser(FILE *out, const Option<TensorSubDim> &value);
bool Option_Operand_ser(FILE *out, const Option<Ptr<Operand>> &value);
bool Option_AluOp_ser(FILE *out, const Option<AluOp> &value);
bool Option_Immediate_ser(FILE *out, const Option<Ptr<Immediate>> &value);
bool List_TensorRef_ser(FILE *out, const List<Ptr<TensorRef>> &value);
bool List_Stmt_ser(FILE *out, const List<Ptr<Stmt>> &value);
bool List_TensorName_ser(FILE *out, const List<Ptr<TensorName>> &value);
bool List_Block_ser(FILE *out, const List<Ptr<Block>> &value);
bool List_List_Block_ser(FILE *out, const List<List<Ptr<Block>>> &value);
bool List_SharedConstantFile_ser(FILE *out,
                                 const List<Ptr<SharedConstantFile>> &value);
bool List_Edges_ser(FILE *out, const List<Ptr<Edges>> &value);

Ptr<Immediate> Immediate_des(FILE *in);
Memory Memory_des(FILE *in);
Dtype Dtype_des(FILE *in);
Ptr<Shape> Shape_des(FILE *in);
Ptr<Address> Address_des(FILE *in);
Ptr<TensorName> TensorName_des(FILE *in);
Ptr<Slice> Slice_des(FILE *in);
Ptr<Index> Index_des(FILE *in);
Ptr<AccessBasic> AccessBasic_des(FILE *in);
Ptr<APPair> APPair_des(FILE *in);
Ptr<AccessPattern> AccessPattern_des(FILE *in);
Ptr<ScalarOffset> ScalarOffset_des(FILE *in);
Ptr<BirAccessPattern> BirAccessPattern_des(FILE *in);
Ptr<Access> Access_des(FILE *in);
Ptr<TensorHbm> TensorHbm_des(FILE *in);
Ptr<TensorSram> TensorSram_des(FILE *in);
Ptr<TensorRef> TensorRef_des(FILE *in);
MatmulPerfMode MatmulPerfMode_des(FILE *in);
Engine Engine_des(FILE *in);
Ptr<ActivationImm> ActivationImm_des(FILE *in);
Ptr<Operand> Operand_des(FILE *in);
Ptr<DataPattern> DataPattern_des(FILE *in);
AluOp AluOp_des(FILE *in);
DropoutThresholdType DropoutThresholdType_des(FILE *in);
AccumCmd AccumCmd_des(FILE *in);
ActivationFunc ActivationFunc_des(FILE *in);
AffineSelectCmp AffineSelectCmp_des(FILE *in);
DgeComputeOp DgeComputeOp_des(FILE *in);
Ptr<DmaBounds> DmaBounds_des(FILE *in);
MatmulGroupElement MatmulGroupElement_des(FILE *in);
Ptr<IndexMissBehavior> IndexMissBehavior_des(FILE *in);
TensorScalarReverseOps TensorScalarReverseOps_des(FILE *in);
TensorSubDim TensorSubDim_des(FILE *in);
TransposeOps TransposeOps_des(FILE *in);
Ptr<Dropout> Dropout_des(FILE *in);
Ptr<Activate> Activate_des(FILE *in);
Ptr<AffineSelect> AffineSelect_des(FILE *in);
Ptr<DmaCopy> DmaCopy_des(FILE *in);
Ptr<DmaTranspose> DmaTranspose_des(FILE *in);
Ptr<Transpose> Transpose_des(FILE *in);
Ptr<LoadMaskRegister> LoadMaskRegister_des(FILE *in);
Ptr<Shuffle> Shuffle_des(FILE *in);
Ptr<MemSet> MemSet_des(FILE *in);
Ptr<Iota> Iota_des(FILE *in);
Ptr<LoadStationary> LoadStationary_des(FILE *in);
Ptr<MatMul> MatMul_des(FILE *in);
Ptr<LocalGather> LocalGather_des(FILE *in);
Ptr<RangeSelect> RangeSelect_des(FILE *in);
Ptr<ScalarTensorTensor> ScalarTensorTensor_des(FILE *in);
Ptr<CopyPredicated> CopyPredicated_des(FILE *in);
Ptr<TensorTensorScan> TensorTensorScan_des(FILE *in);
Ptr<MatchValueLoad> MatchValueLoad_des(FILE *in);
Ptr<FindIndex8> FindIndex8_des(FILE *in);
Ptr<MatchReplace8> MatchReplace8_des(FILE *in);
Ptr<Max8> Max8_des(FILE *in);
Ptr<BatchNormAggregate> BatchNormAggregate_des(FILE *in);
Ptr<BatchNormStats> BatchNormStats_des(FILE *in);
Ptr<Reciprocal> Reciprocal_des(FILE *in);
Ptr<Copy> Copy_des(FILE *in);
Ptr<TensorReduce> TensorReduce_des(FILE *in);
Ptr<TensorScalar> TensorScalar_des(FILE *in);
Ptr<TensorTensor> TensorTensor_des(FILE *in);
Ptr<NcMatMul> NcMatMul_des(FILE *in);
Ptr<TensorScalarReduce> TensorScalarReduce_des(FILE *in);
Ptr<TensorPartitionReduce> TensorPartitionReduce_des(FILE *in);
Ptr<NcActivate> NcActivate_des(FILE *in);
Ptr<NcAffineSelect> NcAffineSelect_des(FILE *in);
Ptr<NcDmaCopy> NcDmaCopy_des(FILE *in);
Ptr<NcLocalGather> NcLocalGather_des(FILE *in);
Ptr<NcRangeSelect> NcRangeSelect_des(FILE *in);
Ptr<NcScalarTensorTensor> NcScalarTensorTensor_des(FILE *in);
Ptr<NcCopy> NcCopy_des(FILE *in);
Ptr<SelectReduce> SelectReduce_des(FILE *in);
Ptr<SequenceBounds> SequenceBounds_des(FILE *in);
Ptr<SendRecv> SendRecv_des(FILE *in);
Ptr<SendRecvCompute> SendRecvCompute_des(FILE *in);
Ptr<QuantizeMX> QuantizeMX_des(FILE *in);
Ptr<MatMulMX> MatMulMX_des(FILE *in);
Ptr<DmaCompute> DmaCompute_des(FILE *in);
Ptr<ReplicaGroup> ReplicaGroup_des(FILE *in);
Ptr<CollectiveOp> CollectiveOp_des(FILE *in);
Ptr<RankId> RankId_des(FILE *in);
Ptr<CurrentProcessingRankId> CurrentProcessingRankId_des(FILE *in);
Ptr<Send> Send_des(FILE *in);
Ptr<Recv> Recv_des(FILE *in);
BrCmpOp BrCmpOp_des(FILE *in);
Ptr<TensorLoad> TensorLoad_des(FILE *in);
Ptr<TensorStore> TensorStore_des(FILE *in);
Ptr<RegisterMove> RegisterMove_des(FILE *in);
Ptr<CmpBranch> CmpBranch_des(FILE *in);
Ptr<RegisterAluOp> RegisterAluOp_des(FILE *in);
Ptr<CoreBarrier> CoreBarrier_des(FILE *in);
Ptr<Rng> Rng_des(FILE *in);
Ptr<Rand2> Rand2_des(FILE *in);
Ptr<RandGetState> RandGetState_des(FILE *in);
Ptr<SetRngSeed> SetRngSeed_des(FILE *in);
Ptr<RandSetState> RandSetState_des(FILE *in);
Ptr<ExtendedInst> ExtendedInst_des(FILE *in);
Ptr<TensorScalarCumulative> TensorScalarCumulative_des(FILE *in);
Ptr<NcNGather> NcNGather_des(FILE *in);
Ptr<NonzeroWithCount> NonzeroWithCount_des(FILE *in);
PrintOutputBuffer PrintOutputBuffer_des(FILE *in);
Ptr<DevicePrint> DevicePrint_des(FILE *in);
Ptr<Operator> Operator_des(FILE *in);
Ptr<Stmt> Stmt_des(FILE *in);
Ptr<Block> Block_des(FILE *in);
Ptr<Kernel> Kernel_des(FILE *in);
Ptr<SharedConstantFile> SharedConstantFile_des(FILE *in);
Ptr<Edges> Edges_des(FILE *in);
Ptr<LncKernel> LncKernel_des(FILE *in);
List<Ptr<Index>> List_Index_des(FILE *in);
List<Ptr<APPair>> List_APPair_des(FILE *in);
Option<Ptr<ScalarOffset>> Option_ScalarOffset_des(FILE *in);
Option<Ptr<Access>> Option_Access_des(FILE *in);
Option<Dtype> Option_Dtype_des(FILE *in);
List<Ptr<Immediate>> List_Immediate_des(FILE *in);
Option<Ptr<TensorRef>> Option_TensorRef_des(FILE *in);
Option<TensorSubDim> Option_TensorSubDim_des(FILE *in);
Option<Ptr<Operand>> Option_Operand_des(FILE *in);
Option<AluOp> Option_AluOp_des(FILE *in);
Option<Ptr<Immediate>> Option_Immediate_des(FILE *in);
List<Ptr<TensorRef>> List_TensorRef_des(FILE *in);
List<Ptr<Stmt>> List_Stmt_des(FILE *in);
List<Ptr<TensorName>> List_TensorName_des(FILE *in);
List<Ptr<Block>> List_Block_des(FILE *in);
List<List<Ptr<Block>>> List_List_Block_des(FILE *in);
List<Ptr<SharedConstantFile>> List_SharedConstantFile_des(FILE *in);
List<Ptr<Edges>> List_Edges_des(FILE *in);
bool KLRFile_ser(FILE *out, const Ptr<KLRFile> &value);
bool KLRMetaData_ser(FILE *out, const Ptr<KLRMetaData> &value);
bool Contents_ser(FILE *out, const Ptr<Contents> &value);

Ptr<KLRFile> KLRFile_des(FILE *in);
Ptr<KLRMetaData> KLRMetaData_des(FILE *in);
Ptr<Contents> Contents_des(FILE *in);
} // namespace klr
