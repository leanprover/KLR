/*
Copyright (c) 2025 Amazon.com, Inc. or its affiliates. All Rights Reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Paul Govereau, Sean McLaughlin
*/

// This file is automatically generated from KLR.
// Manual edits to this file will be overwritten.

#include "stdc.h"
#include "region.h"
#include "cbor.h"
#include "serde_common.h"
#include "serde_klir.h"

bool Core_Memory_ser(FILE *out, enum Core_Memory x) {
  switch (x) {
  case Core_Memory_hbm:
    if (!cbor_encode_tag(out, 110, 0, 0))
      return false;
    break;
  case Core_Memory_sbuf:
    if (!cbor_encode_tag(out, 110, 1, 0))
      return false;
    break;
  case Core_Memory_pmem:
    if (!cbor_encode_tag(out, 110, 2, 0))
      return false;
    break;
  case Core_Memory_reg:
    if (!cbor_encode_tag(out, 110, 3, 0))
      return false;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_Dtype_ser(FILE *out, enum Core_Dtype x) {
  switch (x) {
  case Core_Dtype_bfloat16:
    if (!cbor_encode_tag(out, 111, 0, 0))
      return false;
    break;
  case Core_Dtype_float8e3:
    if (!cbor_encode_tag(out, 111, 1, 0))
      return false;
    break;
  case Core_Dtype_float8e4:
    if (!cbor_encode_tag(out, 111, 2, 0))
      return false;
    break;
  case Core_Dtype_float8e5:
    if (!cbor_encode_tag(out, 111, 3, 0))
      return false;
    break;
  case Core_Dtype_float16:
    if (!cbor_encode_tag(out, 111, 4, 0))
      return false;
    break;
  case Core_Dtype_float32:
    if (!cbor_encode_tag(out, 111, 5, 0))
      return false;
    break;
  case Core_Dtype_float32r:
    if (!cbor_encode_tag(out, 111, 6, 0))
      return false;
    break;
  case Core_Dtype_int8:
    if (!cbor_encode_tag(out, 111, 7, 0))
      return false;
    break;
  case Core_Dtype_int16:
    if (!cbor_encode_tag(out, 111, 8, 0))
      return false;
    break;
  case Core_Dtype_int64:
    if (!cbor_encode_tag(out, 111, 9, 0))
      return false;
    break;
  case Core_Dtype_int32:
    if (!cbor_encode_tag(out, 111, 10, 0))
      return false;
    break;
  case Core_Dtype_uint8:
    if (!cbor_encode_tag(out, 111, 11, 0))
      return false;
    break;
  case Core_Dtype_uint16:
    if (!cbor_encode_tag(out, 111, 12, 0))
      return false;
    break;
  case Core_Dtype_uint32:
    if (!cbor_encode_tag(out, 111, 13, 0))
      return false;
    break;
  case Core_Dtype_uint64:
    if (!cbor_encode_tag(out, 111, 14, 0))
      return false;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_Shape_ser(FILE *out, struct Core_Shape *x) {
  if (!cbor_encode_tag(out, 112, 0, 2))
    return false;
  if (!cbor_encode_uint(out, x->parDim))
    return false;
  if (!Nat_List_ser(out, x->freeDims))
    return false;
  return true;
}

bool Core_Address_ser(FILE *out, struct Core_Address *x) {
  if (!cbor_encode_tag(out, 113, 0, 5))
    return false;
  if (!Core_Memory_ser(out, x->memory))
    return false;
  if (!cbor_encode_uint(out, x->parSize))
    return false;
  if (!cbor_encode_uint(out, x->freeSize))
    return false;
  if (!Nat_Option_ser(out, x->parOffset))
    return false;
  if (!Nat_Option_ser(out, x->freeOffset))
    return false;
  return true;
}

bool Core_TensorSram_ser(FILE *out, struct Core_TensorSram *x) {
  if (!cbor_encode_tag(out, 114, 0, 6))
    return false;
  if (!String_ser(out, x->name))
    return false;
  if (!Core_Dtype_ser(out, x->dtype))
    return false;
  if (!Core_Shape_ser(out, x->shape))
    return false;
  if (!Core_Address_ser(out, x->address))
    return false;
  if (!Prop_ser(out, x->parWF))
    return false;
  if (!Prop_ser(out, x->freeWF))
    return false;
  return true;
}

bool Core_Slice_ser(FILE *out, struct Core_Slice *x) {
  if (!cbor_encode_tag(out, 115, 0, 4))
    return false;
  if (!cbor_encode_uint(out, x->l))
    return false;
  if (!cbor_encode_uint(out, x->u))
    return false;
  if (!cbor_encode_int(out, x->step))
    return false;
  if (!Prop_ser(out, x->wf))
    return false;
  return true;
}

bool Core_Index_ser(FILE *out, struct Core_Index *x) {
  switch (x->tag) {
  case Core_Index_coord:
    if (!cbor_encode_tag(out, 116, 0, 1))
      return false;
    if (!cbor_encode_uint(out, x->coord.e))
      return false;
    break;
  case Core_Index_slice:
    if (!cbor_encode_tag(out, 116, 1, 1))
      return false;
    if (!Core_Slice_ser(out, x->slice.slice))
      return false;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_AccessBasic_ser(FILE *out, struct Core_AccessBasic *x) {
  if (!cbor_encode_tag(out, 117, 0, 3))
    return false;
  if (!Core_TensorSram_ser(out, x->tensor))
    return false;
  if (!Core_Index_List_ser(out, x->indexes))
    return false;
  if (!Prop_ser(out, x->lenWF))
    return false;
  return true;
}

bool Core_APPair_ser(FILE *out, struct Core_APPair *x) {
  if (!cbor_encode_tag(out, 118, 0, 2))
    return false;
  if (!cbor_encode_int(out, x->step))
    return false;
  if (!cbor_encode_uint(out, x->num))
    return false;
  return true;
}

bool Core_AccessPattern_ser(FILE *out, struct Core_AccessPattern *x) {
  if (!cbor_encode_tag(out, 119, 0, 4))
    return false;
  if (!Core_TensorSram_ser(out, x->tensor))
    return false;
  if (!cbor_encode_uint(out, x->parNum))
    return false;
  if (!Core_APPair_List_ser(out, x->freePattern))
    return false;
  if (!cbor_encode_uint(out, x->offset))
    return false;
  return true;
}

bool Core_Access_ser(FILE *out, struct Core_Access *x) {
  switch (x->tag) {
  case Core_Access_simple:
    if (!cbor_encode_tag(out, 120, 0, 1))
      return false;
    if (!Core_TensorSram_ser(out, x->simple.tensor))
      return false;
    break;
  case Core_Access_basic:
    if (!cbor_encode_tag(out, 120, 1, 1))
      return false;
    if (!Core_AccessBasic_ser(out, x->basic.access))
      return false;
    break;
  case Core_Access_pattern:
    if (!cbor_encode_tag(out, 120, 2, 1))
      return false;
    if (!Core_AccessPattern_ser(out, x->pattern.access))
      return false;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_TensorHbm_ser(FILE *out, struct Core_TensorHbm *x) {
  if (!cbor_encode_tag(out, 121, 0, 4))
    return false;
  if (!Core_Dtype_ser(out, x->dtype))
    return false;
  if (!cbor_encode_uint(out, x->address))
    return false;
  if (!Nat_List_ser(out, x->shape))
    return false;
  if (!Nat_List_ser(out, x->strides))
    return false;
  return true;
}

bool Core_ParQuadrant_ser(FILE *out, enum Core_ParQuadrant x) {
  switch (x) {
  case Core_ParQuadrant_par0:
    if (!cbor_encode_tag(out, 122, 0, 0))
      return false;
    break;
  case Core_ParQuadrant_par32:
    if (!cbor_encode_tag(out, 122, 1, 0))
      return false;
    break;
  case Core_ParQuadrant_par64:
    if (!cbor_encode_tag(out, 122, 2, 0))
      return false;
    break;
  case Core_ParQuadrant_par96:
    if (!cbor_encode_tag(out, 122, 3, 0))
      return false;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_TensorView_ser(FILE *out, struct Core_TensorView *x) {
  if (!cbor_encode_tag(out, 123, 0, 6))
    return false;
  if (!String_ser(out, x->name))
    return false;
  if (!Core_Dtype_ser(out, x->dtype))
    return false;
  if (!Core_ParQuadrant_ser(out, x->parQuadrant))
    return false;
  if (!cbor_encode_uint(out, x->parDim))
    return false;
  if (!cbor_encode_uint(out, x->freeOffset))
    return false;
  if (!Core_APPair_List_ser(out, x->freePattern))
    return false;
  return true;
}

bool Core_TensorRef_ser(FILE *out, struct Core_TensorRef *x) {
  switch (x->tag) {
  case Core_TensorRef_abstract:
    if (!cbor_encode_tag(out, 124, 0, 1))
      return false;
    if (!Core_Access_ser(out, x->abstract.access))
      return false;
    break;
  case Core_TensorRef_literal:
    if (!cbor_encode_tag(out, 124, 1, 1))
      return false;
    if (!Core_TensorView_ser(out, x->literal.view))
      return false;
    break;
  case Core_TensorRef_register:
    if (!cbor_encode_tag(out, 124, 2, 1))
      return false;
    if (!cbor_encode_uint(out, x->r.reg))
      return false;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_TensorArg_ser(FILE *out, struct Core_TensorArg *x) {
  switch (x->tag) {
  case Core_TensorArg_hbm:
    if (!cbor_encode_tag(out, 125, 0, 1))
      return false;
    if (!Core_TensorHbm_ser(out, x->hbm.tensor))
      return false;
    break;
  case Core_TensorArg_sram:
    if (!cbor_encode_tag(out, 125, 1, 1))
      return false;
    if (!Core_TensorSram_ser(out, x->sram.tensor))
      return false;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_Engine_ser(FILE *out, enum Core_Engine x) {
  switch (x) {
  case Core_Engine_unassigned:
    if (!cbor_encode_tag(out, 130, 0, 0))
      return false;
    break;
  case Core_Engine_act:
    if (!cbor_encode_tag(out, 130, 1, 0))
      return false;
    break;
  case Core_Engine_dma:
    if (!cbor_encode_tag(out, 130, 2, 0))
      return false;
    break;
  case Core_Engine_dve:
    if (!cbor_encode_tag(out, 130, 3, 0))
      return false;
    break;
  case Core_Engine_pe:
    if (!cbor_encode_tag(out, 130, 4, 0))
      return false;
    break;
  case Core_Engine_pool:
    if (!cbor_encode_tag(out, 130, 5, 0))
      return false;
    break;
  case Core_Engine_sp:
    if (!cbor_encode_tag(out, 130, 6, 0))
      return false;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_Immediate_ser(FILE *out, struct Core_Immediate *x) {
  switch (x->tag) {
  case Core_Immediate_register:
    if (!cbor_encode_tag(out, 131, 0, 1))
      return false;
    if (!cbor_encode_uint(out, x->r.reg))
      return false;
    break;
  case Core_Immediate_pointer:
    if (!cbor_encode_tag(out, 131, 1, 0))
      return false;
    break;
  case Core_Immediate_int:
    if (!cbor_encode_tag(out, 131, 2, 1))
      return false;
    if (!cbor_encode_int(out, x->i.i))
      return false;
    break;
  case Core_Immediate_float:
    if (!cbor_encode_tag(out, 131, 3, 1))
      return false;
    if (!cbor_encode_float(out, x->f.f))
      return false;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_ActivationImm_ser(FILE *out, struct Core_ActivationImm *x) {
  switch (x->tag) {
  case Core_ActivationImm_register:
    if (!cbor_encode_tag(out, 132, 0, 1))
      return false;
    if (!cbor_encode_uint(out, x->r.reg))
      return false;
    break;
  case Core_ActivationImm_pointer:
    if (!cbor_encode_tag(out, 132, 1, 0))
      return false;
    break;
  case Core_ActivationImm_float:
    if (!cbor_encode_tag(out, 132, 2, 1))
      return false;
    if (!cbor_encode_float(out, x->f.f))
      return false;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_DataPattern_ser(FILE *out, struct Core_DataPattern *x) {
  if (!cbor_encode_tag(out, 133, 0, 2))
    return false;
  if (!cbor_encode_uint(out, x->offset))
    return false;
  if (!Core_APPair_List_ser(out, x->pattern))
    return false;
  return true;
}

bool Core_AluOp_ser(FILE *out, enum Core_AluOp x) {
  switch (x) {
  case Core_AluOp_abs:
    if (!cbor_encode_tag(out, 134, 0, 0))
      return false;
    break;
  case Core_AluOp_add:
    if (!cbor_encode_tag(out, 134, 1, 0))
      return false;
    break;
  case Core_AluOp_arith_shift_left:
    if (!cbor_encode_tag(out, 134, 2, 0))
      return false;
    break;
  case Core_AluOp_arith_shift_right:
    if (!cbor_encode_tag(out, 134, 3, 0))
      return false;
    break;
  case Core_AluOp_average:
    if (!cbor_encode_tag(out, 134, 4, 0))
      return false;
    break;
  case Core_AluOp_bitwise_and:
    if (!cbor_encode_tag(out, 134, 5, 0))
      return false;
    break;
  case Core_AluOp_bitwise_not:
    if (!cbor_encode_tag(out, 134, 6, 0))
      return false;
    break;
  case Core_AluOp_bitwise_or:
    if (!cbor_encode_tag(out, 134, 7, 0))
      return false;
    break;
  case Core_AluOp_bitwise_xor:
    if (!cbor_encode_tag(out, 134, 8, 0))
      return false;
    break;
  case Core_AluOp_bypass:
    if (!cbor_encode_tag(out, 134, 9, 0))
      return false;
    break;
  case Core_AluOp_divide:
    if (!cbor_encode_tag(out, 134, 10, 0))
      return false;
    break;
  case Core_AluOp_is_equal:
    if (!cbor_encode_tag(out, 134, 11, 0))
      return false;
    break;
  case Core_AluOp_is_ge:
    if (!cbor_encode_tag(out, 134, 12, 0))
      return false;
    break;
  case Core_AluOp_is_gt:
    if (!cbor_encode_tag(out, 134, 13, 0))
      return false;
    break;
  case Core_AluOp_is_le:
    if (!cbor_encode_tag(out, 134, 14, 0))
      return false;
    break;
  case Core_AluOp_is_lt:
    if (!cbor_encode_tag(out, 134, 15, 0))
      return false;
    break;
  case Core_AluOp_logical_and:
    if (!cbor_encode_tag(out, 134, 16, 0))
      return false;
    break;
  case Core_AluOp_logical_or:
    if (!cbor_encode_tag(out, 134, 17, 0))
      return false;
    break;
  case Core_AluOp_logical_shift_left:
    if (!cbor_encode_tag(out, 134, 18, 0))
      return false;
    break;
  case Core_AluOp_logical_shift_right:
    if (!cbor_encode_tag(out, 134, 19, 0))
      return false;
    break;
  case Core_AluOp_logical_xor:
    if (!cbor_encode_tag(out, 134, 20, 0))
      return false;
    break;
  case Core_AluOp_max:
    if (!cbor_encode_tag(out, 134, 21, 0))
      return false;
    break;
  case Core_AluOp_min:
    if (!cbor_encode_tag(out, 134, 22, 0))
      return false;
    break;
  case Core_AluOp_mod:
    if (!cbor_encode_tag(out, 134, 23, 0))
      return false;
    break;
  case Core_AluOp_mult:
    if (!cbor_encode_tag(out, 134, 24, 0))
      return false;
    break;
  case Core_AluOp_not_equal:
    if (!cbor_encode_tag(out, 134, 25, 0))
      return false;
    break;
  case Core_AluOp_pow:
    if (!cbor_encode_tag(out, 134, 26, 0))
      return false;
    break;
  case Core_AluOp_rsqrt:
    if (!cbor_encode_tag(out, 134, 27, 0))
      return false;
    break;
  case Core_AluOp_subtract:
    if (!cbor_encode_tag(out, 134, 28, 0))
      return false;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_DropoutThresholdType_ser(FILE *out,
                                   enum Core_DropoutThresholdType x) {
  switch (x) {
  case Core_DropoutThresholdType_DropRate:
    if (!cbor_encode_tag(out, 135, 0, 0))
      return false;
    break;
  case Core_DropoutThresholdType_KeepRate:
    if (!cbor_encode_tag(out, 135, 1, 0))
      return false;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_AccumCmd_ser(FILE *out, enum Core_AccumCmd x) {
  switch (x) {
  case Core_AccumCmd_Idle:
    if (!cbor_encode_tag(out, 136, 0, 0))
      return false;
    break;
  case Core_AccumCmd_Zero:
    if (!cbor_encode_tag(out, 136, 1, 0))
      return false;
    break;
  case Core_AccumCmd_Accumulate:
    if (!cbor_encode_tag(out, 136, 2, 0))
      return false;
    break;
  case Core_AccumCmd_ZeroAccumulate:
    if (!cbor_encode_tag(out, 136, 3, 0))
      return false;
    break;
  case Core_AccumCmd_LoadAccumulate:
    if (!cbor_encode_tag(out, 136, 4, 0))
      return false;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_ActivationFunc_ser(FILE *out, enum Core_ActivationFunc x) {
  switch (x) {
  case Core_ActivationFunc_abs:
    if (!cbor_encode_tag(out, 137, 0, 0))
      return false;
    break;
  case Core_ActivationFunc_arctan:
    if (!cbor_encode_tag(out, 137, 1, 0))
      return false;
    break;
  case Core_ActivationFunc_copy:
    if (!cbor_encode_tag(out, 137, 2, 0))
      return false;
    break;
  case Core_ActivationFunc_erf:
    if (!cbor_encode_tag(out, 137, 3, 0))
      return false;
    break;
  case Core_ActivationFunc_erf_dx:
    if (!cbor_encode_tag(out, 137, 4, 0))
      return false;
    break;
  case Core_ActivationFunc_exp:
    if (!cbor_encode_tag(out, 137, 5, 0))
      return false;
    break;
  case Core_ActivationFunc_gelu:
    if (!cbor_encode_tag(out, 137, 6, 0))
      return false;
    break;
  case Core_ActivationFunc_gelu_apprx_tanh:
    if (!cbor_encode_tag(out, 137, 7, 0))
      return false;
    break;
  case Core_ActivationFunc_gelu_dx:
    if (!cbor_encode_tag(out, 137, 8, 0))
      return false;
    break;
  case Core_ActivationFunc_log:
    if (!cbor_encode_tag(out, 137, 9, 0))
      return false;
    break;
  case Core_ActivationFunc_mish:
    if (!cbor_encode_tag(out, 137, 10, 0))
      return false;
    break;
  case Core_ActivationFunc_reciprocal:
    if (!cbor_encode_tag(out, 137, 11, 0))
      return false;
    break;
  case Core_ActivationFunc_relu:
    if (!cbor_encode_tag(out, 137, 12, 0))
      return false;
    break;
  case Core_ActivationFunc_rsqrt:
    if (!cbor_encode_tag(out, 137, 13, 0))
      return false;
    break;
  case Core_ActivationFunc_sigmoid:
    if (!cbor_encode_tag(out, 137, 14, 0))
      return false;
    break;
  case Core_ActivationFunc_sign:
    if (!cbor_encode_tag(out, 137, 15, 0))
      return false;
    break;
  case Core_ActivationFunc_silu:
    if (!cbor_encode_tag(out, 137, 16, 0))
      return false;
    break;
  case Core_ActivationFunc_silu_dx:
    if (!cbor_encode_tag(out, 137, 17, 0))
      return false;
    break;
  case Core_ActivationFunc_sin:
    if (!cbor_encode_tag(out, 137, 18, 0))
      return false;
    break;
  case Core_ActivationFunc_softplus:
    if (!cbor_encode_tag(out, 137, 19, 0))
      return false;
    break;
  case Core_ActivationFunc_sqrt:
    if (!cbor_encode_tag(out, 137, 20, 0))
      return false;
    break;
  case Core_ActivationFunc_square:
    if (!cbor_encode_tag(out, 137, 21, 0))
      return false;
    break;
  case Core_ActivationFunc_tanh:
    if (!cbor_encode_tag(out, 137, 22, 0))
      return false;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_AffineSelectCmp_ser(FILE *out, enum Core_AffineSelectCmp x) {
  switch (x) {
  case Core_AffineSelectCmp_GreaterThan:
    if (!cbor_encode_tag(out, 138, 0, 0))
      return false;
    break;
  case Core_AffineSelectCmp_GreaterThanEq:
    if (!cbor_encode_tag(out, 138, 1, 0))
      return false;
    break;
  case Core_AffineSelectCmp_Eq:
    if (!cbor_encode_tag(out, 138, 2, 0))
      return false;
    break;
  case Core_AffineSelectCmp_NotEq:
    if (!cbor_encode_tag(out, 138, 3, 0))
      return false;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_DgeComputeOp_ser(FILE *out, enum Core_DgeComputeOp x) {
  switch (x) {
  case Core_DgeComputeOp_none:
    if (!cbor_encode_tag(out, 139, 0, 0))
      return false;
    break;
  case Core_DgeComputeOp_add:
    if (!cbor_encode_tag(out, 139, 1, 0))
      return false;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_DmaBounds_ser(FILE *out, struct Core_DmaBounds *x) {
  switch (x->tag) {
  case Core_DmaBounds_disable:
    if (!cbor_encode_tag(out, 140, 0, 0))
      return false;
    break;
  case Core_DmaBounds_enable:
    if (!cbor_encode_tag(out, 140, 1, 0))
      return false;
    break;
  case Core_DmaBounds_reg:
    if (!cbor_encode_tag(out, 140, 2, 1))
      return false;
    if (!cbor_encode_uint(out, x->reg.reg))
      return false;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_MatmulGroupElement_ser(FILE *out, enum Core_MatmulGroupElement x) {
  switch (x) {
  case Core_MatmulGroupElement_first:
    if (!cbor_encode_tag(out, 141, 0, 0))
      return false;
    break;
  case Core_MatmulGroupElement_middle:
    if (!cbor_encode_tag(out, 141, 1, 0))
      return false;
    break;
  case Core_MatmulGroupElement_last:
    if (!cbor_encode_tag(out, 141, 2, 0))
      return false;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_IndexMissBehavior_ser(FILE *out, struct Core_IndexMissBehavior *x) {
  switch (x->tag) {
  case Core_IndexMissBehavior_imm:
    if (!cbor_encode_tag(out, 142, 0, 1))
      return false;
    if (!Core_Immediate_ser(out, x->imm.value))
      return false;
    break;
  case Core_IndexMissBehavior_skip:
    if (!cbor_encode_tag(out, 142, 1, 0))
      return false;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_TensorScalarReverseOps_ser(FILE *out,
                                     enum Core_TensorScalarReverseOps x) {
  switch (x) {
  case Core_TensorScalarReverseOps_none:
    if (!cbor_encode_tag(out, 143, 0, 0))
      return false;
    break;
  case Core_TensorScalarReverseOps_first:
    if (!cbor_encode_tag(out, 143, 1, 0))
      return false;
    break;
  case Core_TensorScalarReverseOps_second:
    if (!cbor_encode_tag(out, 143, 2, 0))
      return false;
    break;
  case Core_TensorScalarReverseOps_both:
    if (!cbor_encode_tag(out, 143, 3, 0))
      return false;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_TensorSubDim_ser(FILE *out, enum Core_TensorSubDim x) {
  switch (x) {
  case Core_TensorSubDim_X:
    if (!cbor_encode_tag(out, 144, 0, 0))
      return false;
    break;
  case Core_TensorSubDim_XY:
    if (!cbor_encode_tag(out, 144, 1, 0))
      return false;
    break;
  case Core_TensorSubDim_XYZ:
    if (!cbor_encode_tag(out, 144, 2, 0))
      return false;
    break;
  case Core_TensorSubDim_XYZW:
    if (!cbor_encode_tag(out, 144, 3, 0))
      return false;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_Dropout_ser(FILE *out, struct Core_Dropout *x) {
  if (!cbor_encode_tag(out, 145, 0, 4))
    return false;
  if (!Core_TensorRef_ser(out, x->dst))
    return false;
  if (!Core_TensorRef_ser(out, x->src))
    return false;
  if (!Core_DropoutThresholdType_ser(out, x->thresholdType))
    return false;
  if (!Core_Immediate_ser(out, x->threshold))
    return false;
  return true;
}

bool Core_Activate_ser(FILE *out, struct Core_Activate *x) {
  if (!cbor_encode_tag(out, 146, 0, 7))
    return false;
  if (!Core_TensorRef_ser(out, x->dst))
    return false;
  if (!Core_TensorRef_ser(out, x->src))
    return false;
  if (!Core_AccumCmd_ser(out, x->accumulatorCmd))
    return false;
  if (!Core_ActivationFunc_ser(out, x->activationFunc))
    return false;
  if (!Core_Immediate_ser(out, x->scale))
    return false;
  if (!Core_Immediate_ser(out, x->bias))
    return false;
  if (!Core_Immediate_ser(out, x->imm))
    return false;
  return true;
}

bool Core_AffineSelect_ser(FILE *out, struct Core_AffineSelect *x) {
  if (!cbor_encode_tag(out, 147, 0, 5))
    return false;
  if (!Core_TensorRef_ser(out, x->dst))
    return false;
  if (!Core_TensorRef_ser(out, x->src))
    return false;
  if (!Core_AffineSelectCmp_ser(out, x->fillMode))
    return false;
  if (!cbor_encode_uint(out, x->fillReg))
    return false;
  if (!Core_DataPattern_ser(out, x->maskPattern))
    return false;
  return true;
}

bool Core_DmaCopy_ser(FILE *out, struct Core_DmaCopy *x) {
  if (!cbor_encode_tag(out, 148, 0, 5))
    return false;
  if (!Core_TensorRef_ser(out, x->dst))
    return false;
  if (!Core_TensorRef_ser(out, x->src))
    return false;
  if (!Core_DgeComputeOp_ser(out, x->compute_op))
    return false;
  if (!Core_DmaBounds_ser(out, x->dstBoundsCheck))
    return false;
  if (!Core_DmaBounds_ser(out, x->srcBoundsCheck))
    return false;
  return true;
}

bool Core_DmaTranspose_ser(FILE *out, struct Core_DmaTranspose *x) {
  if (!cbor_encode_tag(out, 149, 0, 2))
    return false;
  if (!Core_TensorRef_ser(out, x->dst))
    return false;
  if (!Core_TensorRef_ser(out, x->src))
    return false;
  return true;
}

bool Core_Transpose_ser(FILE *out, struct Core_Transpose *x) {
  if (!cbor_encode_tag(out, 150, 0, 2))
    return false;
  if (!Core_TensorRef_ser(out, x->dst))
    return false;
  if (!Core_TensorRef_ser(out, x->src))
    return false;
  return true;
}

bool Core_LoadMaskRegister_ser(FILE *out, struct Core_LoadMaskRegister *x) {
  if (!cbor_encode_tag(out, 151, 0, 1))
    return false;
  if (!cbor_encode_uint(out, x->regNum))
    return false;
  return true;
}

bool Core_Shuffle_ser(FILE *out, struct Core_Shuffle *x) {
  if (!cbor_encode_tag(out, 152, 0, 2))
    return false;
  if (!Core_TensorRef_ser(out, x->dst))
    return false;
  if (!Core_TensorRef_ser(out, x->src))
    return false;
  return true;
}

bool Core_MemSet_ser(FILE *out, struct Core_MemSet *x) {
  if (!cbor_encode_tag(out, 153, 0, 3))
    return false;
  if (!Core_TensorRef_ser(out, x->dst))
    return false;
  if (!cbor_encode_uint(out, x->value))
    return false;
  if (!cbor_encode_uint(out, x->count))
    return false;
  return true;
}

bool Core_Iota_ser(FILE *out, struct Core_Iota *x) {
  if (!cbor_encode_tag(out, 154, 0, 2))
    return false;
  if (!Core_TensorRef_ser(out, x->dst))
    return false;
  if (!Core_DataPattern_ser(out, x->pattern))
    return false;
  return true;
}

bool Core_LoadStationary_ser(FILE *out, struct Core_LoadStationary *x) {
  if (!cbor_encode_tag(out, 155, 0, 2))
    return false;
  if (!Core_TensorRef_ser(out, x->src))
    return false;
  if (!cbor_encode_bool(out, x->isTranspose))
    return false;
  return true;
}

bool Core_MatMul_ser(FILE *out, struct Core_MatMul *x) {
  if (!cbor_encode_tag(out, 156, 0, 3))
    return false;
  if (!Core_TensorRef_ser(out, x->dst))
    return false;
  if (!Core_TensorRef_ser(out, x->moving))
    return false;
  if (!Core_MatmulGroupElement_ser(out, x->psumAccumulateFlag))
    return false;
  return true;
}

bool Core_LocalGather_ser(FILE *out, struct Core_LocalGather *x) {
  if (!cbor_encode_tag(out, 157, 0, 4))
    return false;
  if (!Core_TensorRef_ser(out, x->dst))
    return false;
  if (!Core_TensorRef_ser(out, x->src))
    return false;
  if (!Core_IndexMissBehavior_ser(out, x->indexMissBehavior))
    return false;
  if (!cbor_encode_bool(out, x->freePoolBuffer))
    return false;
  return true;
}

bool Core_RangeSelect_ser(FILE *out, struct Core_RangeSelect *x) {
  if (!cbor_encode_tag(out, 158, 0, 10))
    return false;
  if (!Core_TensorRef_ser(out, x->dst))
    return false;
  if (!Core_TensorRef_ser(out, x->src))
    return false;
  if (!Core_AccumCmd_ser(out, x->reduceCommand))
    return false;
  if (!Core_AluOp_ser(out, x->reduceOp))
    return false;
  if (!cbor_encode_float(out, x->base))
    return false;
  if (!cbor_encode_float(out, x->fillValue))
    return false;
  if (!Core_AluOp_ser(out, x->compOp0))
    return false;
  if (!Core_AluOp_ser(out, x->compOp1))
    return false;
  if (!Core_Immediate_ser(out, x->bound0))
    return false;
  if (!Core_Immediate_ser(out, x->bound1))
    return false;
  return true;
}

bool Core_ScalarTensorTensor_ser(FILE *out, struct Core_ScalarTensorTensor *x) {
  if (!cbor_encode_tag(out, 159, 0, 8))
    return false;
  if (!Core_TensorRef_ser(out, x->dst))
    return false;
  if (!Core_TensorRef_ser(out, x->src0))
    return false;
  if (!Core_TensorRef_ser(out, x->src1))
    return false;
  if (!Core_AluOp_ser(out, x->op0))
    return false;
  if (!Core_AluOp_ser(out, x->op1))
    return false;
  if (!Core_TensorScalarReverseOps_ser(out, x->reverseOperands))
    return false;
  if (!Core_Immediate_ser(out, x->imm0))
    return false;
  if (!Core_AccumCmd_ser(out, x->accumulatorCmd))
    return false;
  return true;
}

bool Core_CopyPredicated_ser(FILE *out, struct Core_CopyPredicated *x) {
  if (!cbor_encode_tag(out, 160, 0, 3))
    return false;
  if (!Core_TensorRef_ser(out, x->dst))
    return false;
  if (!Core_TensorRef_ser(out, x->src))
    return false;
  if (!Core_TensorRef_ser(out, x->predicate))
    return false;
  return true;
}

bool Core_TensorTensorScan_ser(FILE *out, struct Core_TensorTensorScan *x) {
  if (!cbor_encode_tag(out, 161, 0, 8))
    return false;
  if (!Core_TensorRef_ser(out, x->dst))
    return false;
  if (!Core_TensorRef_ser(out, x->src0))
    return false;
  if (!Core_TensorRef_ser(out, x->src1))
    return false;
  if (!Core_AluOp_ser(out, x->op0))
    return false;
  if (!Core_AluOp_ser(out, x->op1))
    return false;
  if (!Core_TensorScalarReverseOps_ser(out, x->reverseOperands))
    return false;
  if (!Core_Immediate_ser(out, x->imm0))
    return false;
  if (!Core_AccumCmd_ser(out, x->accumulatorCmd))
    return false;
  return true;
}

bool Core_MatchValueLoad_ser(FILE *out, struct Core_MatchValueLoad *x) {
  if (!cbor_encode_tag(out, 162, 0, 1))
    return false;
  if (!Core_TensorRef_ser(out, x->src))
    return false;
  return true;
}

bool Core_FindIndex8_ser(FILE *out, struct Core_FindIndex8 *x) {
  if (!cbor_encode_tag(out, 163, 0, 2))
    return false;
  if (!Core_TensorRef_ser(out, x->dst))
    return false;
  if (!Core_TensorRef_ser(out, x->src))
    return false;
  return true;
}

bool Core_MatchReplace8_ser(FILE *out, struct Core_MatchReplace8 *x) {
  if (!cbor_encode_tag(out, 164, 0, 3))
    return false;
  if (!Core_TensorRef_ser(out, x->dst))
    return false;
  if (!Core_TensorRef_ser(out, x->src))
    return false;
  if (!cbor_encode_float(out, x->replaceValue))
    return false;
  return true;
}

bool Core_Max8_ser(FILE *out, struct Core_Max8 *x) {
  if (!cbor_encode_tag(out, 165, 0, 2))
    return false;
  if (!Core_TensorRef_ser(out, x->dst))
    return false;
  if (!Core_TensorRef_ser(out, x->src))
    return false;
  return true;
}

bool Core_BatchNormAggregate_ser(FILE *out, struct Core_BatchNormAggregate *x) {
  if (!cbor_encode_tag(out, 166, 0, 2))
    return false;
  if (!Core_TensorRef_ser(out, x->dst))
    return false;
  if (!Core_TensorRef_ser(out, x->src))
    return false;
  return true;
}

bool Core_BatchNormStats_ser(FILE *out, struct Core_BatchNormStats *x) {
  if (!cbor_encode_tag(out, 167, 0, 2))
    return false;
  if (!Core_TensorRef_ser(out, x->dst))
    return false;
  if (!Core_TensorRef_ser(out, x->src))
    return false;
  return true;
}

bool Core_Reciprocal_ser(FILE *out, struct Core_Reciprocal *x) {
  if (!cbor_encode_tag(out, 168, 0, 2))
    return false;
  if (!Core_TensorRef_ser(out, x->dst))
    return false;
  if (!Core_TensorRef_ser(out, x->src))
    return false;
  return true;
}

bool Core_Copy_ser(FILE *out, struct Core_Copy *x) {
  if (!cbor_encode_tag(out, 169, 0, 3))
    return false;
  if (!Core_TensorRef_ser(out, x->dst))
    return false;
  if (!Core_TensorRef_ser(out, x->src))
    return false;
  if (!Core_TensorSubDim_Option_ser(out, x->opDim))
    return false;
  return true;
}

bool Core_TensorReduce_ser(FILE *out, struct Core_TensorReduce *x) {
  if (!cbor_encode_tag(out, 170, 0, 5))
    return false;
  if (!Core_TensorRef_ser(out, x->dst))
    return false;
  if (!Core_TensorRef_ser(out, x->src))
    return false;
  if (!Core_AluOp_ser(out, x->op))
    return false;
  if (!Core_TensorSubDim_ser(out, x->opDim))
    return false;
  if (!cbor_encode_bool(out, x->negated))
    return false;
  return true;
}

bool Core_Operator_ser(FILE *out, struct Core_Operator *x) {
  switch (x->tag) {
  case Core_Operator_Activate:
    if (!cbor_encode_tag(out, 171, 0, 1))
      return false;
    if (!Core_Activate_ser(out, x->Activate.op))
      return false;
    break;
  case Core_Operator_AffineSelect:
    if (!cbor_encode_tag(out, 171, 1, 1))
      return false;
    if (!Core_AffineSelect_ser(out, x->AffineSelect.op))
      return false;
    break;
  case Core_Operator_BatchNormAggregate:
    if (!cbor_encode_tag(out, 171, 2, 1))
      return false;
    if (!Core_BatchNormAggregate_ser(out, x->BatchNormAggregate.op))
      return false;
    break;
  case Core_Operator_BatchNormStats:
    if (!cbor_encode_tag(out, 171, 3, 1))
      return false;
    if (!Core_BatchNormStats_ser(out, x->BatchNormStats.op))
      return false;
    break;
  case Core_Operator_Copy:
    if (!cbor_encode_tag(out, 171, 4, 1))
      return false;
    if (!Core_Copy_ser(out, x->Copy.op))
      return false;
    break;
  case Core_Operator_CopyPredicated:
    if (!cbor_encode_tag(out, 171, 5, 1))
      return false;
    if (!Core_CopyPredicated_ser(out, x->CopyPredicated.op))
      return false;
    break;
  case Core_Operator_DmaCopy:
    if (!cbor_encode_tag(out, 171, 6, 1))
      return false;
    if (!Core_DmaCopy_ser(out, x->DmaCopy.op))
      return false;
    break;
  case Core_Operator_DmaTranspose:
    if (!cbor_encode_tag(out, 171, 7, 1))
      return false;
    if (!Core_DmaTranspose_ser(out, x->DmaTranspose.op))
      return false;
    break;
  case Core_Operator_Dropout:
    if (!cbor_encode_tag(out, 171, 8, 1))
      return false;
    if (!Core_Dropout_ser(out, x->Dropout.op))
      return false;
    break;
  case Core_Operator_FindIndex8:
    if (!cbor_encode_tag(out, 171, 9, 1))
      return false;
    if (!Core_FindIndex8_ser(out, x->FindIndex8.op))
      return false;
    break;
  case Core_Operator_Iota:
    if (!cbor_encode_tag(out, 171, 10, 1))
      return false;
    if (!Core_Iota_ser(out, x->Iota.op))
      return false;
    break;
  case Core_Operator_LoadMaskRegister:
    if (!cbor_encode_tag(out, 171, 11, 1))
      return false;
    if (!Core_LoadMaskRegister_ser(out, x->LoadMaskRegister.op))
      return false;
    break;
  case Core_Operator_LoadStationary:
    if (!cbor_encode_tag(out, 171, 12, 1))
      return false;
    if (!Core_LoadStationary_ser(out, x->LoadStationary.op))
      return false;
    break;
  case Core_Operator_LocalGather:
    if (!cbor_encode_tag(out, 171, 13, 1))
      return false;
    if (!Core_LocalGather_ser(out, x->LocalGather.op))
      return false;
    break;
  case Core_Operator_MatMul:
    if (!cbor_encode_tag(out, 171, 14, 1))
      return false;
    if (!Core_MatMul_ser(out, x->MatMul.op))
      return false;
    break;
  case Core_Operator_MatchReplace8:
    if (!cbor_encode_tag(out, 171, 15, 1))
      return false;
    if (!Core_MatchReplace8_ser(out, x->MatchReplace8.op))
      return false;
    break;
  case Core_Operator_MatchValueLoad:
    if (!cbor_encode_tag(out, 171, 16, 1))
      return false;
    if (!Core_MatchValueLoad_ser(out, x->MatchValueLoad.op))
      return false;
    break;
  case Core_Operator_Max8:
    if (!cbor_encode_tag(out, 171, 17, 1))
      return false;
    if (!Core_Max8_ser(out, x->Max8.op))
      return false;
    break;
  case Core_Operator_MemSet:
    if (!cbor_encode_tag(out, 171, 18, 1))
      return false;
    if (!Core_MemSet_ser(out, x->MemSet.op))
      return false;
    break;
  case Core_Operator_RangeSelect:
    if (!cbor_encode_tag(out, 171, 19, 1))
      return false;
    if (!Core_RangeSelect_ser(out, x->RangeSelect.op))
      return false;
    break;
  case Core_Operator_Reciprocal:
    if (!cbor_encode_tag(out, 171, 20, 1))
      return false;
    if (!Core_Reciprocal_ser(out, x->Reciprocal.op))
      return false;
    break;
  case Core_Operator_ScalarTensorTensor:
    if (!cbor_encode_tag(out, 171, 21, 1))
      return false;
    if (!Core_ScalarTensorTensor_ser(out, x->ScalarTensorTensor.op))
      return false;
    break;
  case Core_Operator_Shuffle:
    if (!cbor_encode_tag(out, 171, 22, 1))
      return false;
    if (!Core_Shuffle_ser(out, x->Shuffle.op))
      return false;
    break;
  case Core_Operator_TensorReduce:
    if (!cbor_encode_tag(out, 171, 23, 1))
      return false;
    if (!Core_TensorReduce_ser(out, x->TensorReduce.op))
      return false;
    break;
  case Core_Operator_TensorTensorScan:
    if (!cbor_encode_tag(out, 171, 24, 1))
      return false;
    if (!Core_TensorTensorScan_ser(out, x->TensorTensorScan.op))
      return false;
    break;
  case Core_Operator_Transpose:
    if (!cbor_encode_tag(out, 171, 25, 1))
      return false;
    if (!Core_Transpose_ser(out, x->Transpose.op))
      return false;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_Value_ser(FILE *out, struct Core_Value *x) {
  switch (x->tag) {
  case Core_Value_var:
    if (!cbor_encode_tag(out, 101, 0, 1))
      return false;
    if (!String_ser(out, x->var.x))
      return false;
    break;
  case Core_Value_bool:
    if (!cbor_encode_tag(out, 101, 1, 1))
      return false;
    if (!cbor_encode_bool(out, x->b.value))
      return false;
    break;
  case Core_Value_int:
    if (!cbor_encode_tag(out, 101, 2, 1))
      return false;
    if (!cbor_encode_int(out, x->i.value))
      return false;
    break;
  case Core_Value_float:
    if (!cbor_encode_tag(out, 101, 3, 1))
      return false;
    if (!cbor_encode_float(out, x->f.value))
      return false;
    break;
  case Core_Value_access:
    if (!cbor_encode_tag(out, 101, 4, 1))
      return false;
    if (!Core_Access_ser(out, x->access.a))
      return false;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_Keyword_ser(FILE *out, struct Core_Keyword *x) {
  if (!cbor_encode_tag(out, 102, 0, 2))
    return false;
  if (!String_ser(out, x->name))
    return false;
  if (!Core_Value_ser(out, x->value))
    return false;
  return true;
}

bool Core_Expr_ser(FILE *out, struct Core_Expr *x) {
  switch (x->tag) {
  case Core_Expr_value:
    if (!cbor_encode_tag(out, 103, 0, 1))
      return false;
    if (!Core_Value_ser(out, x->value.v))
      return false;
    break;
  case Core_Expr_call:
    if (!cbor_encode_tag(out, 103, 1, 3))
      return false;
    if (!String_ser(out, x->call.f))
      return false;
    if (!Core_Value_List_ser(out, x->call.args))
      return false;
    if (!Core_Keyword_List_ser(out, x->call.kwargs))
      return false;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_Stmt_ser(FILE *out, struct Core_Stmt *x) {
  switch (x->tag) {
  case Core_Stmt_ret:
    if (!cbor_encode_tag(out, 104, 0, 1))
      return false;
    if (!Core_Value_ser(out, x->ret.v))
      return false;
    break;
  case Core_Stmt_assign:
    if (!cbor_encode_tag(out, 104, 1, 2))
      return false;
    if (!String_ser(out, x->assign.x))
      return false;
    if (!Core_Expr_ser(out, x->assign.e))
      return false;
    break;
  case Core_Stmt_store:
    if (!cbor_encode_tag(out, 104, 2, 3))
      return false;
    if (!Core_Access_ser(out, x->store.dst))
      return false;
    if (!Core_Operator_ser(out, x->store.op))
      return false;
    if (!Core_Value_List_ser(out, x->store.args))
      return false;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_Kernel_ser(FILE *out, struct Core_Kernel *x) {
  if (!cbor_encode_tag(out, 105, 0, 4))
    return false;
  if (!String_ser(out, x->name))
    return false;
  if (!Core_TensorArg_List_ser(out, x->inputs))
    return false;
  if (!Core_TensorArg_List_ser(out, x->outputs))
    return false;
  if (!Core_Stmt_List_ser(out, x->body))
    return false;
  return true;
}

bool Core_Index_List_ser(FILE *out, struct Core_Index_List *x) {
  u64 count = 0;
  for (struct Core_Index_List *node = x; node; node = node->next)
    count++;
  if (!cbor_encode_array_start(out, count))
    return false;
  for (struct Core_Index_List *node = x; node; node = node->next)
    if (!Core_Index_ser(out, node->index))
      return false;
  return true;
}

bool Core_APPair_List_ser(FILE *out, struct Core_APPair_List *x) {
  u64 count = 0;
  for (struct Core_APPair_List *node = x; node; node = node->next)
    count++;
  if (!cbor_encode_array_start(out, count))
    return false;
  for (struct Core_APPair_List *node = x; node; node = node->next)
    if (!Core_APPair_ser(out, node->appair))
      return false;
  return true;
}

bool Core_TensorSubDim_Option_ser(FILE *out, enum Core_TensorSubDim x) {
  if (!x) {
    return cbor_encode_option(out, false);
  } else {
    return cbor_encode_option(out, true) && Core_TensorSubDim_ser(out, x);
  }
  return true;
}

bool Core_Value_List_ser(FILE *out, struct Core_Value_List *x) {
  u64 count = 0;
  for (struct Core_Value_List *node = x; node; node = node->next)
    count++;
  if (!cbor_encode_array_start(out, count))
    return false;
  for (struct Core_Value_List *node = x; node; node = node->next)
    if (!Core_Value_ser(out, node->value))
      return false;
  return true;
}

bool Core_Keyword_List_ser(FILE *out, struct Core_Keyword_List *x) {
  u64 count = 0;
  for (struct Core_Keyword_List *node = x; node; node = node->next)
    count++;
  if (!cbor_encode_array_start(out, count))
    return false;
  for (struct Core_Keyword_List *node = x; node; node = node->next)
    if (!Core_Keyword_ser(out, node->keyword))
      return false;
  return true;
}

bool Core_TensorArg_List_ser(FILE *out, struct Core_TensorArg_List *x) {
  u64 count = 0;
  for (struct Core_TensorArg_List *node = x; node; node = node->next)
    count++;
  if (!cbor_encode_array_start(out, count))
    return false;
  for (struct Core_TensorArg_List *node = x; node; node = node->next)
    if (!Core_TensorArg_ser(out, node->tensorarg))
      return false;
  return true;
}

bool Core_Stmt_List_ser(FILE *out, struct Core_Stmt_List *x) {
  u64 count = 0;
  for (struct Core_Stmt_List *node = x; node; node = node->next)
    count++;
  if (!cbor_encode_array_start(out, count))
    return false;
  for (struct Core_Stmt_List *node = x; node; node = node->next)
    if (!Core_Stmt_ser(out, node->stmt))
      return false;
  return true;
}

bool Core_Memory_des(FILE *in, struct region *region, enum Core_Memory *x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 110)
    return false;
  (void)region;
  switch (c) {
  case 0:
    if (l != 0)
      return false;
    *x = Core_Memory_hbm;
    break;
  case 1:
    if (l != 0)
      return false;
    *x = Core_Memory_sbuf;
    break;
  case 2:
    if (l != 0)
      return false;
    *x = Core_Memory_pmem;
    break;
  case 3:
    if (l != 0)
      return false;
    *x = Core_Memory_reg;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_Dtype_des(FILE *in, struct region *region, enum Core_Dtype *x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 111)
    return false;
  (void)region;
  switch (c) {
  case 0:
    if (l != 0)
      return false;
    *x = Core_Dtype_bfloat16;
    break;
  case 1:
    if (l != 0)
      return false;
    *x = Core_Dtype_float8e3;
    break;
  case 2:
    if (l != 0)
      return false;
    *x = Core_Dtype_float8e4;
    break;
  case 3:
    if (l != 0)
      return false;
    *x = Core_Dtype_float8e5;
    break;
  case 4:
    if (l != 0)
      return false;
    *x = Core_Dtype_float16;
    break;
  case 5:
    if (l != 0)
      return false;
    *x = Core_Dtype_float32;
    break;
  case 6:
    if (l != 0)
      return false;
    *x = Core_Dtype_float32r;
    break;
  case 7:
    if (l != 0)
      return false;
    *x = Core_Dtype_int8;
    break;
  case 8:
    if (l != 0)
      return false;
    *x = Core_Dtype_int16;
    break;
  case 9:
    if (l != 0)
      return false;
    *x = Core_Dtype_int64;
    break;
  case 10:
    if (l != 0)
      return false;
    *x = Core_Dtype_int32;
    break;
  case 11:
    if (l != 0)
      return false;
    *x = Core_Dtype_uint8;
    break;
  case 12:
    if (l != 0)
      return false;
    *x = Core_Dtype_uint16;
    break;
  case 13:
    if (l != 0)
      return false;
    *x = Core_Dtype_uint32;
    break;
  case 14:
    if (l != 0)
      return false;
    *x = Core_Dtype_uint64;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_Shape_des(FILE *in, struct region *region, struct Core_Shape **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 112 || c != 0 || l != 2)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Nat_des(in, region, &(*x)->parDim))
    return false;
  if (!Nat_List_des(in, region, &(*x)->freeDims))
    return false;
  return true;
}

bool Core_Address_des(FILE *in, struct region *region,
                      struct Core_Address **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 113 || c != 0 || l != 5)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Core_Memory_des(in, region, &(*x)->memory))
    return false;
  if (!Nat_des(in, region, &(*x)->parSize))
    return false;
  if (!Nat_des(in, region, &(*x)->freeSize))
    return false;
  if (!Nat_Option_des(in, region, &(*x)->parOffset))
    return false;
  if (!Nat_Option_des(in, region, &(*x)->freeOffset))
    return false;
  return true;
}

bool Core_TensorSram_des(FILE *in, struct region *region,
                         struct Core_TensorSram **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 114 || c != 0 || l != 6)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!String_des(in, region, &(*x)->name))
    return false;
  if (!Core_Dtype_des(in, region, &(*x)->dtype))
    return false;
  if (!Core_Shape_des(in, region, &(*x)->shape))
    return false;
  if (!Core_Address_des(in, region, &(*x)->address))
    return false;
  if (!Prop_des(in, region, &(*x)->parWF))
    return false;
  if (!Prop_des(in, region, &(*x)->freeWF))
    return false;
  return true;
}

bool Core_Slice_des(FILE *in, struct region *region, struct Core_Slice **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 115 || c != 0 || l != 4)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Nat_des(in, region, &(*x)->l))
    return false;
  if (!Nat_des(in, region, &(*x)->u))
    return false;
  if (!Int_des(in, region, &(*x)->step))
    return false;
  if (!Prop_des(in, region, &(*x)->wf))
    return false;
  return true;
}

bool Core_Index_des(FILE *in, struct region *region, struct Core_Index **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 116)
    return false;
  *x = region_alloc(region, sizeof(**x));
  switch (c) {
  case 0:
    if (l != 1)
      return false;
    if (!Nat_des(in, region, &(*x)->coord.e))
      return false;
    (*x)->tag = Core_Index_coord;
    break;
  case 1:
    if (l != 1)
      return false;
    if (!Core_Slice_des(in, region, &(*x)->slice.slice))
      return false;
    (*x)->tag = Core_Index_slice;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_AccessBasic_des(FILE *in, struct region *region,
                          struct Core_AccessBasic **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 117 || c != 0 || l != 3)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Core_TensorSram_des(in, region, &(*x)->tensor))
    return false;
  if (!Core_Index_List_des(in, region, &(*x)->indexes))
    return false;
  if (!Prop_des(in, region, &(*x)->lenWF))
    return false;
  return true;
}

bool Core_APPair_des(FILE *in, struct region *region, struct Core_APPair **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 118 || c != 0 || l != 2)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Int_des(in, region, &(*x)->step))
    return false;
  if (!Nat_des(in, region, &(*x)->num))
    return false;
  return true;
}

bool Core_AccessPattern_des(FILE *in, struct region *region,
                            struct Core_AccessPattern **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 119 || c != 0 || l != 4)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Core_TensorSram_des(in, region, &(*x)->tensor))
    return false;
  if (!Nat_des(in, region, &(*x)->parNum))
    return false;
  if (!Core_APPair_List_des(in, region, &(*x)->freePattern))
    return false;
  if (!Nat_des(in, region, &(*x)->offset))
    return false;
  return true;
}

bool Core_Access_des(FILE *in, struct region *region, struct Core_Access **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 120)
    return false;
  *x = region_alloc(region, sizeof(**x));
  switch (c) {
  case 0:
    if (l != 1)
      return false;
    if (!Core_TensorSram_des(in, region, &(*x)->simple.tensor))
      return false;
    (*x)->tag = Core_Access_simple;
    break;
  case 1:
    if (l != 1)
      return false;
    if (!Core_AccessBasic_des(in, region, &(*x)->basic.access))
      return false;
    (*x)->tag = Core_Access_basic;
    break;
  case 2:
    if (l != 1)
      return false;
    if (!Core_AccessPattern_des(in, region, &(*x)->pattern.access))
      return false;
    (*x)->tag = Core_Access_pattern;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_TensorHbm_des(FILE *in, struct region *region,
                        struct Core_TensorHbm **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 121 || c != 0 || l != 4)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Core_Dtype_des(in, region, &(*x)->dtype))
    return false;
  if (!Nat_des(in, region, &(*x)->address))
    return false;
  if (!Nat_List_des(in, region, &(*x)->shape))
    return false;
  if (!Nat_List_des(in, region, &(*x)->strides))
    return false;
  return true;
}

bool Core_ParQuadrant_des(FILE *in, struct region *region,
                          enum Core_ParQuadrant *x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 122)
    return false;
  (void)region;
  switch (c) {
  case 0:
    if (l != 0)
      return false;
    *x = Core_ParQuadrant_par0;
    break;
  case 1:
    if (l != 0)
      return false;
    *x = Core_ParQuadrant_par32;
    break;
  case 2:
    if (l != 0)
      return false;
    *x = Core_ParQuadrant_par64;
    break;
  case 3:
    if (l != 0)
      return false;
    *x = Core_ParQuadrant_par96;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_TensorView_des(FILE *in, struct region *region,
                         struct Core_TensorView **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 123 || c != 0 || l != 6)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!String_des(in, region, &(*x)->name))
    return false;
  if (!Core_Dtype_des(in, region, &(*x)->dtype))
    return false;
  if (!Core_ParQuadrant_des(in, region, &(*x)->parQuadrant))
    return false;
  if (!Nat_des(in, region, &(*x)->parDim))
    return false;
  if (!Nat_des(in, region, &(*x)->freeOffset))
    return false;
  if (!Core_APPair_List_des(in, region, &(*x)->freePattern))
    return false;
  return true;
}

bool Core_TensorRef_des(FILE *in, struct region *region,
                        struct Core_TensorRef **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 124)
    return false;
  *x = region_alloc(region, sizeof(**x));
  switch (c) {
  case 0:
    if (l != 1)
      return false;
    if (!Core_Access_des(in, region, &(*x)->abstract.access))
      return false;
    (*x)->tag = Core_TensorRef_abstract;
    break;
  case 1:
    if (l != 1)
      return false;
    if (!Core_TensorView_des(in, region, &(*x)->literal.view))
      return false;
    (*x)->tag = Core_TensorRef_literal;
    break;
  case 2:
    if (l != 1)
      return false;
    if (!Nat_des(in, region, &(*x)->r.reg))
      return false;
    (*x)->tag = Core_TensorRef_register;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_TensorArg_des(FILE *in, struct region *region,
                        struct Core_TensorArg **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 125)
    return false;
  *x = region_alloc(region, sizeof(**x));
  switch (c) {
  case 0:
    if (l != 1)
      return false;
    if (!Core_TensorHbm_des(in, region, &(*x)->hbm.tensor))
      return false;
    (*x)->tag = Core_TensorArg_hbm;
    break;
  case 1:
    if (l != 1)
      return false;
    if (!Core_TensorSram_des(in, region, &(*x)->sram.tensor))
      return false;
    (*x)->tag = Core_TensorArg_sram;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_Engine_des(FILE *in, struct region *region, enum Core_Engine *x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 130)
    return false;
  (void)region;
  switch (c) {
  case 0:
    if (l != 0)
      return false;
    *x = Core_Engine_unassigned;
    break;
  case 1:
    if (l != 0)
      return false;
    *x = Core_Engine_act;
    break;
  case 2:
    if (l != 0)
      return false;
    *x = Core_Engine_dma;
    break;
  case 3:
    if (l != 0)
      return false;
    *x = Core_Engine_dve;
    break;
  case 4:
    if (l != 0)
      return false;
    *x = Core_Engine_pe;
    break;
  case 5:
    if (l != 0)
      return false;
    *x = Core_Engine_pool;
    break;
  case 6:
    if (l != 0)
      return false;
    *x = Core_Engine_sp;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_Immediate_des(FILE *in, struct region *region,
                        struct Core_Immediate **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 131)
    return false;
  *x = region_alloc(region, sizeof(**x));
  switch (c) {
  case 0:
    if (l != 1)
      return false;
    if (!Nat_des(in, region, &(*x)->r.reg))
      return false;
    (*x)->tag = Core_Immediate_register;
    break;
  case 1:
    if (l != 0)
      return false;
    (*x)->tag = Core_Immediate_pointer;
    break;
  case 2:
    if (l != 1)
      return false;
    if (!Int_des(in, region, &(*x)->i.i))
      return false;
    (*x)->tag = Core_Immediate_int;
    break;
  case 3:
    if (l != 1)
      return false;
    if (!Float_des(in, region, &(*x)->f.f))
      return false;
    (*x)->tag = Core_Immediate_float;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_ActivationImm_des(FILE *in, struct region *region,
                            struct Core_ActivationImm **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 132)
    return false;
  *x = region_alloc(region, sizeof(**x));
  switch (c) {
  case 0:
    if (l != 1)
      return false;
    if (!Nat_des(in, region, &(*x)->r.reg))
      return false;
    (*x)->tag = Core_ActivationImm_register;
    break;
  case 1:
    if (l != 0)
      return false;
    (*x)->tag = Core_ActivationImm_pointer;
    break;
  case 2:
    if (l != 1)
      return false;
    if (!Float_des(in, region, &(*x)->f.f))
      return false;
    (*x)->tag = Core_ActivationImm_float;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_DataPattern_des(FILE *in, struct region *region,
                          struct Core_DataPattern **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 133 || c != 0 || l != 2)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Nat_des(in, region, &(*x)->offset))
    return false;
  if (!Core_APPair_List_des(in, region, &(*x)->pattern))
    return false;
  return true;
}

bool Core_AluOp_des(FILE *in, struct region *region, enum Core_AluOp *x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 134)
    return false;
  (void)region;
  switch (c) {
  case 0:
    if (l != 0)
      return false;
    *x = Core_AluOp_abs;
    break;
  case 1:
    if (l != 0)
      return false;
    *x = Core_AluOp_add;
    break;
  case 2:
    if (l != 0)
      return false;
    *x = Core_AluOp_arith_shift_left;
    break;
  case 3:
    if (l != 0)
      return false;
    *x = Core_AluOp_arith_shift_right;
    break;
  case 4:
    if (l != 0)
      return false;
    *x = Core_AluOp_average;
    break;
  case 5:
    if (l != 0)
      return false;
    *x = Core_AluOp_bitwise_and;
    break;
  case 6:
    if (l != 0)
      return false;
    *x = Core_AluOp_bitwise_not;
    break;
  case 7:
    if (l != 0)
      return false;
    *x = Core_AluOp_bitwise_or;
    break;
  case 8:
    if (l != 0)
      return false;
    *x = Core_AluOp_bitwise_xor;
    break;
  case 9:
    if (l != 0)
      return false;
    *x = Core_AluOp_bypass;
    break;
  case 10:
    if (l != 0)
      return false;
    *x = Core_AluOp_divide;
    break;
  case 11:
    if (l != 0)
      return false;
    *x = Core_AluOp_is_equal;
    break;
  case 12:
    if (l != 0)
      return false;
    *x = Core_AluOp_is_ge;
    break;
  case 13:
    if (l != 0)
      return false;
    *x = Core_AluOp_is_gt;
    break;
  case 14:
    if (l != 0)
      return false;
    *x = Core_AluOp_is_le;
    break;
  case 15:
    if (l != 0)
      return false;
    *x = Core_AluOp_is_lt;
    break;
  case 16:
    if (l != 0)
      return false;
    *x = Core_AluOp_logical_and;
    break;
  case 17:
    if (l != 0)
      return false;
    *x = Core_AluOp_logical_or;
    break;
  case 18:
    if (l != 0)
      return false;
    *x = Core_AluOp_logical_shift_left;
    break;
  case 19:
    if (l != 0)
      return false;
    *x = Core_AluOp_logical_shift_right;
    break;
  case 20:
    if (l != 0)
      return false;
    *x = Core_AluOp_logical_xor;
    break;
  case 21:
    if (l != 0)
      return false;
    *x = Core_AluOp_max;
    break;
  case 22:
    if (l != 0)
      return false;
    *x = Core_AluOp_min;
    break;
  case 23:
    if (l != 0)
      return false;
    *x = Core_AluOp_mod;
    break;
  case 24:
    if (l != 0)
      return false;
    *x = Core_AluOp_mult;
    break;
  case 25:
    if (l != 0)
      return false;
    *x = Core_AluOp_not_equal;
    break;
  case 26:
    if (l != 0)
      return false;
    *x = Core_AluOp_pow;
    break;
  case 27:
    if (l != 0)
      return false;
    *x = Core_AluOp_rsqrt;
    break;
  case 28:
    if (l != 0)
      return false;
    *x = Core_AluOp_subtract;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_DropoutThresholdType_des(FILE *in, struct region *region,
                                   enum Core_DropoutThresholdType *x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 135)
    return false;
  (void)region;
  switch (c) {
  case 0:
    if (l != 0)
      return false;
    *x = Core_DropoutThresholdType_DropRate;
    break;
  case 1:
    if (l != 0)
      return false;
    *x = Core_DropoutThresholdType_KeepRate;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_AccumCmd_des(FILE *in, struct region *region, enum Core_AccumCmd *x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 136)
    return false;
  (void)region;
  switch (c) {
  case 0:
    if (l != 0)
      return false;
    *x = Core_AccumCmd_Idle;
    break;
  case 1:
    if (l != 0)
      return false;
    *x = Core_AccumCmd_Zero;
    break;
  case 2:
    if (l != 0)
      return false;
    *x = Core_AccumCmd_Accumulate;
    break;
  case 3:
    if (l != 0)
      return false;
    *x = Core_AccumCmd_ZeroAccumulate;
    break;
  case 4:
    if (l != 0)
      return false;
    *x = Core_AccumCmd_LoadAccumulate;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_ActivationFunc_des(FILE *in, struct region *region,
                             enum Core_ActivationFunc *x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 137)
    return false;
  (void)region;
  switch (c) {
  case 0:
    if (l != 0)
      return false;
    *x = Core_ActivationFunc_abs;
    break;
  case 1:
    if (l != 0)
      return false;
    *x = Core_ActivationFunc_arctan;
    break;
  case 2:
    if (l != 0)
      return false;
    *x = Core_ActivationFunc_copy;
    break;
  case 3:
    if (l != 0)
      return false;
    *x = Core_ActivationFunc_erf;
    break;
  case 4:
    if (l != 0)
      return false;
    *x = Core_ActivationFunc_erf_dx;
    break;
  case 5:
    if (l != 0)
      return false;
    *x = Core_ActivationFunc_exp;
    break;
  case 6:
    if (l != 0)
      return false;
    *x = Core_ActivationFunc_gelu;
    break;
  case 7:
    if (l != 0)
      return false;
    *x = Core_ActivationFunc_gelu_apprx_tanh;
    break;
  case 8:
    if (l != 0)
      return false;
    *x = Core_ActivationFunc_gelu_dx;
    break;
  case 9:
    if (l != 0)
      return false;
    *x = Core_ActivationFunc_log;
    break;
  case 10:
    if (l != 0)
      return false;
    *x = Core_ActivationFunc_mish;
    break;
  case 11:
    if (l != 0)
      return false;
    *x = Core_ActivationFunc_reciprocal;
    break;
  case 12:
    if (l != 0)
      return false;
    *x = Core_ActivationFunc_relu;
    break;
  case 13:
    if (l != 0)
      return false;
    *x = Core_ActivationFunc_rsqrt;
    break;
  case 14:
    if (l != 0)
      return false;
    *x = Core_ActivationFunc_sigmoid;
    break;
  case 15:
    if (l != 0)
      return false;
    *x = Core_ActivationFunc_sign;
    break;
  case 16:
    if (l != 0)
      return false;
    *x = Core_ActivationFunc_silu;
    break;
  case 17:
    if (l != 0)
      return false;
    *x = Core_ActivationFunc_silu_dx;
    break;
  case 18:
    if (l != 0)
      return false;
    *x = Core_ActivationFunc_sin;
    break;
  case 19:
    if (l != 0)
      return false;
    *x = Core_ActivationFunc_softplus;
    break;
  case 20:
    if (l != 0)
      return false;
    *x = Core_ActivationFunc_sqrt;
    break;
  case 21:
    if (l != 0)
      return false;
    *x = Core_ActivationFunc_square;
    break;
  case 22:
    if (l != 0)
      return false;
    *x = Core_ActivationFunc_tanh;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_AffineSelectCmp_des(FILE *in, struct region *region,
                              enum Core_AffineSelectCmp *x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 138)
    return false;
  (void)region;
  switch (c) {
  case 0:
    if (l != 0)
      return false;
    *x = Core_AffineSelectCmp_GreaterThan;
    break;
  case 1:
    if (l != 0)
      return false;
    *x = Core_AffineSelectCmp_GreaterThanEq;
    break;
  case 2:
    if (l != 0)
      return false;
    *x = Core_AffineSelectCmp_Eq;
    break;
  case 3:
    if (l != 0)
      return false;
    *x = Core_AffineSelectCmp_NotEq;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_DgeComputeOp_des(FILE *in, struct region *region,
                           enum Core_DgeComputeOp *x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 139)
    return false;
  (void)region;
  switch (c) {
  case 0:
    if (l != 0)
      return false;
    *x = Core_DgeComputeOp_none;
    break;
  case 1:
    if (l != 0)
      return false;
    *x = Core_DgeComputeOp_add;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_DmaBounds_des(FILE *in, struct region *region,
                        struct Core_DmaBounds **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 140)
    return false;
  *x = region_alloc(region, sizeof(**x));
  switch (c) {
  case 0:
    if (l != 0)
      return false;
    (*x)->tag = Core_DmaBounds_disable;
    break;
  case 1:
    if (l != 0)
      return false;
    (*x)->tag = Core_DmaBounds_enable;
    break;
  case 2:
    if (l != 1)
      return false;
    if (!Nat_des(in, region, &(*x)->reg.reg))
      return false;
    (*x)->tag = Core_DmaBounds_reg;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_MatmulGroupElement_des(FILE *in, struct region *region,
                                 enum Core_MatmulGroupElement *x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 141)
    return false;
  (void)region;
  switch (c) {
  case 0:
    if (l != 0)
      return false;
    *x = Core_MatmulGroupElement_first;
    break;
  case 1:
    if (l != 0)
      return false;
    *x = Core_MatmulGroupElement_middle;
    break;
  case 2:
    if (l != 0)
      return false;
    *x = Core_MatmulGroupElement_last;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_IndexMissBehavior_des(FILE *in, struct region *region,
                                struct Core_IndexMissBehavior **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 142)
    return false;
  *x = region_alloc(region, sizeof(**x));
  switch (c) {
  case 0:
    if (l != 1)
      return false;
    if (!Core_Immediate_des(in, region, &(*x)->imm.value))
      return false;
    (*x)->tag = Core_IndexMissBehavior_imm;
    break;
  case 1:
    if (l != 0)
      return false;
    (*x)->tag = Core_IndexMissBehavior_skip;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_TensorScalarReverseOps_des(FILE *in, struct region *region,
                                     enum Core_TensorScalarReverseOps *x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 143)
    return false;
  (void)region;
  switch (c) {
  case 0:
    if (l != 0)
      return false;
    *x = Core_TensorScalarReverseOps_none;
    break;
  case 1:
    if (l != 0)
      return false;
    *x = Core_TensorScalarReverseOps_first;
    break;
  case 2:
    if (l != 0)
      return false;
    *x = Core_TensorScalarReverseOps_second;
    break;
  case 3:
    if (l != 0)
      return false;
    *x = Core_TensorScalarReverseOps_both;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_TensorSubDim_des(FILE *in, struct region *region,
                           enum Core_TensorSubDim *x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 144)
    return false;
  (void)region;
  switch (c) {
  case 0:
    if (l != 0)
      return false;
    *x = Core_TensorSubDim_X;
    break;
  case 1:
    if (l != 0)
      return false;
    *x = Core_TensorSubDim_XY;
    break;
  case 2:
    if (l != 0)
      return false;
    *x = Core_TensorSubDim_XYZ;
    break;
  case 3:
    if (l != 0)
      return false;
    *x = Core_TensorSubDim_XYZW;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_Dropout_des(FILE *in, struct region *region,
                      struct Core_Dropout **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 145 || c != 0 || l != 4)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Core_TensorRef_des(in, region, &(*x)->dst))
    return false;
  if (!Core_TensorRef_des(in, region, &(*x)->src))
    return false;
  if (!Core_DropoutThresholdType_des(in, region, &(*x)->thresholdType))
    return false;
  if (!Core_Immediate_des(in, region, &(*x)->threshold))
    return false;
  return true;
}

bool Core_Activate_des(FILE *in, struct region *region,
                       struct Core_Activate **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 146 || c != 0 || l != 7)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Core_TensorRef_des(in, region, &(*x)->dst))
    return false;
  if (!Core_TensorRef_des(in, region, &(*x)->src))
    return false;
  if (!Core_AccumCmd_des(in, region, &(*x)->accumulatorCmd))
    return false;
  if (!Core_ActivationFunc_des(in, region, &(*x)->activationFunc))
    return false;
  if (!Core_Immediate_des(in, region, &(*x)->scale))
    return false;
  if (!Core_Immediate_des(in, region, &(*x)->bias))
    return false;
  if (!Core_Immediate_des(in, region, &(*x)->imm))
    return false;
  return true;
}

bool Core_AffineSelect_des(FILE *in, struct region *region,
                           struct Core_AffineSelect **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 147 || c != 0 || l != 5)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Core_TensorRef_des(in, region, &(*x)->dst))
    return false;
  if (!Core_TensorRef_des(in, region, &(*x)->src))
    return false;
  if (!Core_AffineSelectCmp_des(in, region, &(*x)->fillMode))
    return false;
  if (!Nat_des(in, region, &(*x)->fillReg))
    return false;
  if (!Core_DataPattern_des(in, region, &(*x)->maskPattern))
    return false;
  return true;
}

bool Core_DmaCopy_des(FILE *in, struct region *region,
                      struct Core_DmaCopy **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 148 || c != 0 || l != 5)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Core_TensorRef_des(in, region, &(*x)->dst))
    return false;
  if (!Core_TensorRef_des(in, region, &(*x)->src))
    return false;
  if (!Core_DgeComputeOp_des(in, region, &(*x)->compute_op))
    return false;
  if (!Core_DmaBounds_des(in, region, &(*x)->dstBoundsCheck))
    return false;
  if (!Core_DmaBounds_des(in, region, &(*x)->srcBoundsCheck))
    return false;
  return true;
}

bool Core_DmaTranspose_des(FILE *in, struct region *region,
                           struct Core_DmaTranspose **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 149 || c != 0 || l != 2)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Core_TensorRef_des(in, region, &(*x)->dst))
    return false;
  if (!Core_TensorRef_des(in, region, &(*x)->src))
    return false;
  return true;
}

bool Core_Transpose_des(FILE *in, struct region *region,
                        struct Core_Transpose **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 150 || c != 0 || l != 2)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Core_TensorRef_des(in, region, &(*x)->dst))
    return false;
  if (!Core_TensorRef_des(in, region, &(*x)->src))
    return false;
  return true;
}

bool Core_LoadMaskRegister_des(FILE *in, struct region *region,
                               struct Core_LoadMaskRegister **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 151 || c != 0 || l != 1)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Nat_des(in, region, &(*x)->regNum))
    return false;
  return true;
}

bool Core_Shuffle_des(FILE *in, struct region *region,
                      struct Core_Shuffle **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 152 || c != 0 || l != 2)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Core_TensorRef_des(in, region, &(*x)->dst))
    return false;
  if (!Core_TensorRef_des(in, region, &(*x)->src))
    return false;
  return true;
}

bool Core_MemSet_des(FILE *in, struct region *region, struct Core_MemSet **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 153 || c != 0 || l != 3)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Core_TensorRef_des(in, region, &(*x)->dst))
    return false;
  if (!Nat_des(in, region, &(*x)->value))
    return false;
  if (!Nat_des(in, region, &(*x)->count))
    return false;
  return true;
}

bool Core_Iota_des(FILE *in, struct region *region, struct Core_Iota **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 154 || c != 0 || l != 2)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Core_TensorRef_des(in, region, &(*x)->dst))
    return false;
  if (!Core_DataPattern_des(in, region, &(*x)->pattern))
    return false;
  return true;
}

bool Core_LoadStationary_des(FILE *in, struct region *region,
                             struct Core_LoadStationary **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 155 || c != 0 || l != 2)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Core_TensorRef_des(in, region, &(*x)->src))
    return false;
  if (!Bool_des(in, region, &(*x)->isTranspose))
    return false;
  return true;
}

bool Core_MatMul_des(FILE *in, struct region *region, struct Core_MatMul **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 156 || c != 0 || l != 3)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Core_TensorRef_des(in, region, &(*x)->dst))
    return false;
  if (!Core_TensorRef_des(in, region, &(*x)->moving))
    return false;
  if (!Core_MatmulGroupElement_des(in, region, &(*x)->psumAccumulateFlag))
    return false;
  return true;
}

bool Core_LocalGather_des(FILE *in, struct region *region,
                          struct Core_LocalGather **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 157 || c != 0 || l != 4)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Core_TensorRef_des(in, region, &(*x)->dst))
    return false;
  if (!Core_TensorRef_des(in, region, &(*x)->src))
    return false;
  if (!Core_IndexMissBehavior_des(in, region, &(*x)->indexMissBehavior))
    return false;
  if (!Bool_des(in, region, &(*x)->freePoolBuffer))
    return false;
  return true;
}

bool Core_RangeSelect_des(FILE *in, struct region *region,
                          struct Core_RangeSelect **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 158 || c != 0 || l != 10)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Core_TensorRef_des(in, region, &(*x)->dst))
    return false;
  if (!Core_TensorRef_des(in, region, &(*x)->src))
    return false;
  if (!Core_AccumCmd_des(in, region, &(*x)->reduceCommand))
    return false;
  if (!Core_AluOp_des(in, region, &(*x)->reduceOp))
    return false;
  if (!Float_des(in, region, &(*x)->base))
    return false;
  if (!Float_des(in, region, &(*x)->fillValue))
    return false;
  if (!Core_AluOp_des(in, region, &(*x)->compOp0))
    return false;
  if (!Core_AluOp_des(in, region, &(*x)->compOp1))
    return false;
  if (!Core_Immediate_des(in, region, &(*x)->bound0))
    return false;
  if (!Core_Immediate_des(in, region, &(*x)->bound1))
    return false;
  return true;
}

bool Core_ScalarTensorTensor_des(FILE *in, struct region *region,
                                 struct Core_ScalarTensorTensor **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 159 || c != 0 || l != 8)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Core_TensorRef_des(in, region, &(*x)->dst))
    return false;
  if (!Core_TensorRef_des(in, region, &(*x)->src0))
    return false;
  if (!Core_TensorRef_des(in, region, &(*x)->src1))
    return false;
  if (!Core_AluOp_des(in, region, &(*x)->op0))
    return false;
  if (!Core_AluOp_des(in, region, &(*x)->op1))
    return false;
  if (!Core_TensorScalarReverseOps_des(in, region, &(*x)->reverseOperands))
    return false;
  if (!Core_Immediate_des(in, region, &(*x)->imm0))
    return false;
  if (!Core_AccumCmd_des(in, region, &(*x)->accumulatorCmd))
    return false;
  return true;
}

bool Core_CopyPredicated_des(FILE *in, struct region *region,
                             struct Core_CopyPredicated **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 160 || c != 0 || l != 3)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Core_TensorRef_des(in, region, &(*x)->dst))
    return false;
  if (!Core_TensorRef_des(in, region, &(*x)->src))
    return false;
  if (!Core_TensorRef_des(in, region, &(*x)->predicate))
    return false;
  return true;
}

bool Core_TensorTensorScan_des(FILE *in, struct region *region,
                               struct Core_TensorTensorScan **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 161 || c != 0 || l != 8)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Core_TensorRef_des(in, region, &(*x)->dst))
    return false;
  if (!Core_TensorRef_des(in, region, &(*x)->src0))
    return false;
  if (!Core_TensorRef_des(in, region, &(*x)->src1))
    return false;
  if (!Core_AluOp_des(in, region, &(*x)->op0))
    return false;
  if (!Core_AluOp_des(in, region, &(*x)->op1))
    return false;
  if (!Core_TensorScalarReverseOps_des(in, region, &(*x)->reverseOperands))
    return false;
  if (!Core_Immediate_des(in, region, &(*x)->imm0))
    return false;
  if (!Core_AccumCmd_des(in, region, &(*x)->accumulatorCmd))
    return false;
  return true;
}

bool Core_MatchValueLoad_des(FILE *in, struct region *region,
                             struct Core_MatchValueLoad **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 162 || c != 0 || l != 1)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Core_TensorRef_des(in, region, &(*x)->src))
    return false;
  return true;
}

bool Core_FindIndex8_des(FILE *in, struct region *region,
                         struct Core_FindIndex8 **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 163 || c != 0 || l != 2)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Core_TensorRef_des(in, region, &(*x)->dst))
    return false;
  if (!Core_TensorRef_des(in, region, &(*x)->src))
    return false;
  return true;
}

bool Core_MatchReplace8_des(FILE *in, struct region *region,
                            struct Core_MatchReplace8 **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 164 || c != 0 || l != 3)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Core_TensorRef_des(in, region, &(*x)->dst))
    return false;
  if (!Core_TensorRef_des(in, region, &(*x)->src))
    return false;
  if (!Float_des(in, region, &(*x)->replaceValue))
    return false;
  return true;
}

bool Core_Max8_des(FILE *in, struct region *region, struct Core_Max8 **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 165 || c != 0 || l != 2)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Core_TensorRef_des(in, region, &(*x)->dst))
    return false;
  if (!Core_TensorRef_des(in, region, &(*x)->src))
    return false;
  return true;
}

bool Core_BatchNormAggregate_des(FILE *in, struct region *region,
                                 struct Core_BatchNormAggregate **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 166 || c != 0 || l != 2)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Core_TensorRef_des(in, region, &(*x)->dst))
    return false;
  if (!Core_TensorRef_des(in, region, &(*x)->src))
    return false;
  return true;
}

bool Core_BatchNormStats_des(FILE *in, struct region *region,
                             struct Core_BatchNormStats **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 167 || c != 0 || l != 2)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Core_TensorRef_des(in, region, &(*x)->dst))
    return false;
  if (!Core_TensorRef_des(in, region, &(*x)->src))
    return false;
  return true;
}

bool Core_Reciprocal_des(FILE *in, struct region *region,
                         struct Core_Reciprocal **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 168 || c != 0 || l != 2)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Core_TensorRef_des(in, region, &(*x)->dst))
    return false;
  if (!Core_TensorRef_des(in, region, &(*x)->src))
    return false;
  return true;
}

bool Core_Copy_des(FILE *in, struct region *region, struct Core_Copy **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 169 || c != 0 || l != 3)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Core_TensorRef_des(in, region, &(*x)->dst))
    return false;
  if (!Core_TensorRef_des(in, region, &(*x)->src))
    return false;
  if (!Core_TensorSubDim_Option_des(in, region, &(*x)->opDim))
    return false;
  return true;
}

bool Core_TensorReduce_des(FILE *in, struct region *region,
                           struct Core_TensorReduce **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 170 || c != 0 || l != 5)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Core_TensorRef_des(in, region, &(*x)->dst))
    return false;
  if (!Core_TensorRef_des(in, region, &(*x)->src))
    return false;
  if (!Core_AluOp_des(in, region, &(*x)->op))
    return false;
  if (!Core_TensorSubDim_des(in, region, &(*x)->opDim))
    return false;
  if (!Bool_des(in, region, &(*x)->negated))
    return false;
  return true;
}

bool Core_Operator_des(FILE *in, struct region *region,
                       struct Core_Operator **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 171)
    return false;
  *x = region_alloc(region, sizeof(**x));
  switch (c) {
  case 0:
    if (l != 1)
      return false;
    if (!Core_Activate_des(in, region, &(*x)->Activate.op))
      return false;
    (*x)->tag = Core_Operator_Activate;
    break;
  case 1:
    if (l != 1)
      return false;
    if (!Core_AffineSelect_des(in, region, &(*x)->AffineSelect.op))
      return false;
    (*x)->tag = Core_Operator_AffineSelect;
    break;
  case 2:
    if (l != 1)
      return false;
    if (!Core_BatchNormAggregate_des(in, region, &(*x)->BatchNormAggregate.op))
      return false;
    (*x)->tag = Core_Operator_BatchNormAggregate;
    break;
  case 3:
    if (l != 1)
      return false;
    if (!Core_BatchNormStats_des(in, region, &(*x)->BatchNormStats.op))
      return false;
    (*x)->tag = Core_Operator_BatchNormStats;
    break;
  case 4:
    if (l != 1)
      return false;
    if (!Core_Copy_des(in, region, &(*x)->Copy.op))
      return false;
    (*x)->tag = Core_Operator_Copy;
    break;
  case 5:
    if (l != 1)
      return false;
    if (!Core_CopyPredicated_des(in, region, &(*x)->CopyPredicated.op))
      return false;
    (*x)->tag = Core_Operator_CopyPredicated;
    break;
  case 6:
    if (l != 1)
      return false;
    if (!Core_DmaCopy_des(in, region, &(*x)->DmaCopy.op))
      return false;
    (*x)->tag = Core_Operator_DmaCopy;
    break;
  case 7:
    if (l != 1)
      return false;
    if (!Core_DmaTranspose_des(in, region, &(*x)->DmaTranspose.op))
      return false;
    (*x)->tag = Core_Operator_DmaTranspose;
    break;
  case 8:
    if (l != 1)
      return false;
    if (!Core_Dropout_des(in, region, &(*x)->Dropout.op))
      return false;
    (*x)->tag = Core_Operator_Dropout;
    break;
  case 9:
    if (l != 1)
      return false;
    if (!Core_FindIndex8_des(in, region, &(*x)->FindIndex8.op))
      return false;
    (*x)->tag = Core_Operator_FindIndex8;
    break;
  case 10:
    if (l != 1)
      return false;
    if (!Core_Iota_des(in, region, &(*x)->Iota.op))
      return false;
    (*x)->tag = Core_Operator_Iota;
    break;
  case 11:
    if (l != 1)
      return false;
    if (!Core_LoadMaskRegister_des(in, region, &(*x)->LoadMaskRegister.op))
      return false;
    (*x)->tag = Core_Operator_LoadMaskRegister;
    break;
  case 12:
    if (l != 1)
      return false;
    if (!Core_LoadStationary_des(in, region, &(*x)->LoadStationary.op))
      return false;
    (*x)->tag = Core_Operator_LoadStationary;
    break;
  case 13:
    if (l != 1)
      return false;
    if (!Core_LocalGather_des(in, region, &(*x)->LocalGather.op))
      return false;
    (*x)->tag = Core_Operator_LocalGather;
    break;
  case 14:
    if (l != 1)
      return false;
    if (!Core_MatMul_des(in, region, &(*x)->MatMul.op))
      return false;
    (*x)->tag = Core_Operator_MatMul;
    break;
  case 15:
    if (l != 1)
      return false;
    if (!Core_MatchReplace8_des(in, region, &(*x)->MatchReplace8.op))
      return false;
    (*x)->tag = Core_Operator_MatchReplace8;
    break;
  case 16:
    if (l != 1)
      return false;
    if (!Core_MatchValueLoad_des(in, region, &(*x)->MatchValueLoad.op))
      return false;
    (*x)->tag = Core_Operator_MatchValueLoad;
    break;
  case 17:
    if (l != 1)
      return false;
    if (!Core_Max8_des(in, region, &(*x)->Max8.op))
      return false;
    (*x)->tag = Core_Operator_Max8;
    break;
  case 18:
    if (l != 1)
      return false;
    if (!Core_MemSet_des(in, region, &(*x)->MemSet.op))
      return false;
    (*x)->tag = Core_Operator_MemSet;
    break;
  case 19:
    if (l != 1)
      return false;
    if (!Core_RangeSelect_des(in, region, &(*x)->RangeSelect.op))
      return false;
    (*x)->tag = Core_Operator_RangeSelect;
    break;
  case 20:
    if (l != 1)
      return false;
    if (!Core_Reciprocal_des(in, region, &(*x)->Reciprocal.op))
      return false;
    (*x)->tag = Core_Operator_Reciprocal;
    break;
  case 21:
    if (l != 1)
      return false;
    if (!Core_ScalarTensorTensor_des(in, region, &(*x)->ScalarTensorTensor.op))
      return false;
    (*x)->tag = Core_Operator_ScalarTensorTensor;
    break;
  case 22:
    if (l != 1)
      return false;
    if (!Core_Shuffle_des(in, region, &(*x)->Shuffle.op))
      return false;
    (*x)->tag = Core_Operator_Shuffle;
    break;
  case 23:
    if (l != 1)
      return false;
    if (!Core_TensorReduce_des(in, region, &(*x)->TensorReduce.op))
      return false;
    (*x)->tag = Core_Operator_TensorReduce;
    break;
  case 24:
    if (l != 1)
      return false;
    if (!Core_TensorTensorScan_des(in, region, &(*x)->TensorTensorScan.op))
      return false;
    (*x)->tag = Core_Operator_TensorTensorScan;
    break;
  case 25:
    if (l != 1)
      return false;
    if (!Core_Transpose_des(in, region, &(*x)->Transpose.op))
      return false;
    (*x)->tag = Core_Operator_Transpose;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_Value_des(FILE *in, struct region *region, struct Core_Value **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 101)
    return false;
  *x = region_alloc(region, sizeof(**x));
  switch (c) {
  case 0:
    if (l != 1)
      return false;
    if (!String_des(in, region, &(*x)->var.x))
      return false;
    (*x)->tag = Core_Value_var;
    break;
  case 1:
    if (l != 1)
      return false;
    if (!Bool_des(in, region, &(*x)->b.value))
      return false;
    (*x)->tag = Core_Value_bool;
    break;
  case 2:
    if (l != 1)
      return false;
    if (!Int_des(in, region, &(*x)->i.value))
      return false;
    (*x)->tag = Core_Value_int;
    break;
  case 3:
    if (l != 1)
      return false;
    if (!Float_des(in, region, &(*x)->f.value))
      return false;
    (*x)->tag = Core_Value_float;
    break;
  case 4:
    if (l != 1)
      return false;
    if (!Core_Access_des(in, region, &(*x)->access.a))
      return false;
    (*x)->tag = Core_Value_access;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_Keyword_des(FILE *in, struct region *region,
                      struct Core_Keyword **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 102 || c != 0 || l != 2)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!String_des(in, region, &(*x)->name))
    return false;
  if (!Core_Value_des(in, region, &(*x)->value))
    return false;
  return true;
}

bool Core_Expr_des(FILE *in, struct region *region, struct Core_Expr **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 103)
    return false;
  *x = region_alloc(region, sizeof(**x));
  switch (c) {
  case 0:
    if (l != 1)
      return false;
    if (!Core_Value_des(in, region, &(*x)->value.v))
      return false;
    (*x)->tag = Core_Expr_value;
    break;
  case 1:
    if (l != 3)
      return false;
    if (!String_des(in, region, &(*x)->call.f))
      return false;
    if (!Core_Value_List_des(in, region, &(*x)->call.args))
      return false;
    if (!Core_Keyword_List_des(in, region, &(*x)->call.kwargs))
      return false;
    (*x)->tag = Core_Expr_call;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_Stmt_des(FILE *in, struct region *region, struct Core_Stmt **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 104)
    return false;
  *x = region_alloc(region, sizeof(**x));
  switch (c) {
  case 0:
    if (l != 1)
      return false;
    if (!Core_Value_des(in, region, &(*x)->ret.v))
      return false;
    (*x)->tag = Core_Stmt_ret;
    break;
  case 1:
    if (l != 2)
      return false;
    if (!String_des(in, region, &(*x)->assign.x))
      return false;
    if (!Core_Expr_des(in, region, &(*x)->assign.e))
      return false;
    (*x)->tag = Core_Stmt_assign;
    break;
  case 2:
    if (l != 3)
      return false;
    if (!Core_Access_des(in, region, &(*x)->store.dst))
      return false;
    if (!Core_Operator_des(in, region, &(*x)->store.op))
      return false;
    if (!Core_Value_List_des(in, region, &(*x)->store.args))
      return false;
    (*x)->tag = Core_Stmt_store;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_Kernel_des(FILE *in, struct region *region, struct Core_Kernel **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 105 || c != 0 || l != 4)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!String_des(in, region, &(*x)->name))
    return false;
  if (!Core_TensorArg_List_des(in, region, &(*x)->inputs))
    return false;
  if (!Core_TensorArg_List_des(in, region, &(*x)->outputs))
    return false;
  if (!Core_Stmt_List_des(in, region, &(*x)->body))
    return false;
  return true;
}

bool Core_Index_List_des(FILE *in, struct region *region,
                         struct Core_Index_List **x) {
  u64 count = 0;
  if (!cbor_decode_array_start(in, &count))
    return false;
  struct Core_Index_List *current = *x = NULL;
  for (; count > 0; count--) {
    struct Core_Index_List *node = region_alloc(region, sizeof(*node));
    node->next = NULL;
    if (!current) {
      *x = current = node;
    } else {
      current->next = node;
      current = node;
    }
    if (!Core_Index_des(in, region, &node->index))
      return false;
  }
  return true;
}

bool Core_APPair_List_des(FILE *in, struct region *region,
                          struct Core_APPair_List **x) {
  u64 count = 0;
  if (!cbor_decode_array_start(in, &count))
    return false;
  struct Core_APPair_List *current = *x = NULL;
  for (; count > 0; count--) {
    struct Core_APPair_List *node = region_alloc(region, sizeof(*node));
    node->next = NULL;
    if (!current) {
      *x = current = node;
    } else {
      current->next = node;
      current = node;
    }
    if (!Core_APPair_des(in, region, &node->appair))
      return false;
  }
  return true;
}

bool Core_TensorSubDim_Option_des(FILE *in, struct region *region,
                                  enum Core_TensorSubDim *x) {
  bool isSome;
  if (!cbor_decode_option(in, &isSome))
    return false;
  if (!isSome)
    *x = 0;
  else
    return Core_TensorSubDim_des(in, region, x);
  return true;
}

bool Core_Value_List_des(FILE *in, struct region *region,
                         struct Core_Value_List **x) {
  u64 count = 0;
  if (!cbor_decode_array_start(in, &count))
    return false;
  struct Core_Value_List *current = *x = NULL;
  for (; count > 0; count--) {
    struct Core_Value_List *node = region_alloc(region, sizeof(*node));
    node->next = NULL;
    if (!current) {
      *x = current = node;
    } else {
      current->next = node;
      current = node;
    }
    if (!Core_Value_des(in, region, &node->value))
      return false;
  }
  return true;
}

bool Core_Keyword_List_des(FILE *in, struct region *region,
                           struct Core_Keyword_List **x) {
  u64 count = 0;
  if (!cbor_decode_array_start(in, &count))
    return false;
  struct Core_Keyword_List *current = *x = NULL;
  for (; count > 0; count--) {
    struct Core_Keyword_List *node = region_alloc(region, sizeof(*node));
    node->next = NULL;
    if (!current) {
      *x = current = node;
    } else {
      current->next = node;
      current = node;
    }
    if (!Core_Keyword_des(in, region, &node->keyword))
      return false;
  }
  return true;
}

bool Core_TensorArg_List_des(FILE *in, struct region *region,
                             struct Core_TensorArg_List **x) {
  u64 count = 0;
  if (!cbor_decode_array_start(in, &count))
    return false;
  struct Core_TensorArg_List *current = *x = NULL;
  for (; count > 0; count--) {
    struct Core_TensorArg_List *node = region_alloc(region, sizeof(*node));
    node->next = NULL;
    if (!current) {
      *x = current = node;
    } else {
      current->next = node;
      current = node;
    }
    if (!Core_TensorArg_des(in, region, &node->tensorarg))
      return false;
  }
  return true;
}

bool Core_Stmt_List_des(FILE *in, struct region *region,
                        struct Core_Stmt_List **x) {
  u64 count = 0;
  if (!cbor_decode_array_start(in, &count))
    return false;
  struct Core_Stmt_List *current = *x = NULL;
  for (; count > 0; count--) {
    struct Core_Stmt_List *node = region_alloc(region, sizeof(*node));
    node->next = NULL;
    if (!current) {
      *x = current = node;
    } else {
      current->next = node;
      current = node;
    }
    if (!Core_Stmt_des(in, region, &node->stmt))
      return false;
  }
  return true;
}
