/*
Copyright (c) 2025 Amazon.com, Inc. or its affiliates. All Rights Reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Paul Govereau, Sean McLaughlin
*/

// This file is automatically generated from KLR.
// Manual edits to this file will be overwritten.

#include "stdc.h"
#include "region.h"
#include "cbor.h"
#include "serde_common.h"
#include "serde_klir.h"

bool Core_Memory_ser(FILE *out, enum Core_Memory x) {
  switch (x) {
  case Core_Memory_hbm:
    if (!cbor_encode_tag(out, 110, 0, 0))
      return false;
    break;
  case Core_Memory_sbuf:
    if (!cbor_encode_tag(out, 110, 1, 0))
      return false;
    break;
  case Core_Memory_psum:
    if (!cbor_encode_tag(out, 110, 2, 0))
      return false;
    break;
  case Core_Memory_reg:
    if (!cbor_encode_tag(out, 110, 3, 0))
      return false;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_Dtype_ser(FILE *out, enum Core_Dtype x) {
  switch (x) {
  case Core_Dtype_bfloat16:
    if (!cbor_encode_tag(out, 111, 0, 0))
      return false;
    break;
  case Core_Dtype_float8e3:
    if (!cbor_encode_tag(out, 111, 1, 0))
      return false;
    break;
  case Core_Dtype_float8e4:
    if (!cbor_encode_tag(out, 111, 2, 0))
      return false;
    break;
  case Core_Dtype_float8e5:
    if (!cbor_encode_tag(out, 111, 3, 0))
      return false;
    break;
  case Core_Dtype_float16:
    if (!cbor_encode_tag(out, 111, 4, 0))
      return false;
    break;
  case Core_Dtype_float32:
    if (!cbor_encode_tag(out, 111, 5, 0))
      return false;
    break;
  case Core_Dtype_float32r:
    if (!cbor_encode_tag(out, 111, 6, 0))
      return false;
    break;
  case Core_Dtype_int8:
    if (!cbor_encode_tag(out, 111, 7, 0))
      return false;
    break;
  case Core_Dtype_int16:
    if (!cbor_encode_tag(out, 111, 8, 0))
      return false;
    break;
  case Core_Dtype_int64:
    if (!cbor_encode_tag(out, 111, 9, 0))
      return false;
    break;
  case Core_Dtype_int32:
    if (!cbor_encode_tag(out, 111, 10, 0))
      return false;
    break;
  case Core_Dtype_uint8:
    if (!cbor_encode_tag(out, 111, 11, 0))
      return false;
    break;
  case Core_Dtype_uint16:
    if (!cbor_encode_tag(out, 111, 12, 0))
      return false;
    break;
  case Core_Dtype_uint32:
    if (!cbor_encode_tag(out, 111, 13, 0))
      return false;
    break;
  case Core_Dtype_uint64:
    if (!cbor_encode_tag(out, 111, 14, 0))
      return false;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_Shape_ser(FILE *out, struct Core_Shape *x) {
  if (!cbor_encode_tag(out, 112, 0, 2))
    return false;
  if (!cbor_encode_uint(out, x->parDim))
    return false;
  if (!Nat_List_ser(out, x->freeDims))
    return false;
  return true;
}

bool Core_Address_ser(FILE *out, struct Core_Address *x) {
  if (!cbor_encode_tag(out, 113, 0, 5))
    return false;
  if (!Core_Memory_ser(out, x->memory))
    return false;
  if (!cbor_encode_uint(out, x->parSize))
    return false;
  if (!cbor_encode_uint(out, x->freeSize))
    return false;
  if (!Nat_Option_ser(out, x->parOffset))
    return false;
  if (!Nat_Option_ser(out, x->freeOffset))
    return false;
  return true;
}

bool Core_TensorName_ser(FILE *out, struct Core_TensorName *x) {
  if (!cbor_encode_tag(out, 114, 0, 7))
    return false;
  if (!String_ser(out, x->name))
    return false;
  if (!Core_Dtype_ser(out, x->dtype))
    return false;
  if (!Core_Shape_ser(out, x->shape))
    return false;
  if (!Core_Address_ser(out, x->address))
    return false;
  if (!cbor_encode_uint(out, x->freeElements))
    return false;
  if (!Prop_ser(out, x->parWF))
    return false;
  if (!Prop_ser(out, x->freeWF))
    return false;
  return true;
}

bool Core_Slice_ser(FILE *out, struct Core_Slice *x) {
  if (!cbor_encode_tag(out, 115, 0, 4))
    return false;
  if (!cbor_encode_uint(out, x->l))
    return false;
  if (!cbor_encode_uint(out, x->u))
    return false;
  if (!cbor_encode_int(out, x->step))
    return false;
  if (!Prop_ser(out, x->wf))
    return false;
  return true;
}

bool Core_Index_ser(FILE *out, struct Core_Index *x) {
  switch (x->tag) {
  case Core_Index_coord:
    if (!cbor_encode_tag(out, 116, 0, 1))
      return false;
    if (!cbor_encode_uint(out, x->coord.e))
      return false;
    break;
  case Core_Index_slice:
    if (!cbor_encode_tag(out, 116, 1, 1))
      return false;
    if (!Core_Slice_ser(out, x->slice.slice))
      return false;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_AccessBasic_ser(FILE *out, struct Core_AccessBasic *x) {
  if (!cbor_encode_tag(out, 117, 0, 3))
    return false;
  if (!Core_TensorName_ser(out, x->tensor))
    return false;
  if (!Core_Index_List_ser(out, x->indexes))
    return false;
  if (!Prop_ser(out, x->lenWF))
    return false;
  return true;
}

bool Core_APPair_ser(FILE *out, struct Core_APPair *x) {
  if (!cbor_encode_tag(out, 118, 0, 2))
    return false;
  if (!cbor_encode_int(out, x->step))
    return false;
  if (!cbor_encode_uint(out, x->num))
    return false;
  return true;
}

bool Core_AccessPattern_ser(FILE *out, struct Core_AccessPattern *x) {
  if (!cbor_encode_tag(out, 119, 0, 5))
    return false;
  if (!Core_TensorName_ser(out, x->tensor))
    return false;
  if (!cbor_encode_uint(out, x->parNum))
    return false;
  if (!Core_APPair_List_ser(out, x->freePattern))
    return false;
  if (!cbor_encode_uint(out, x->parOffset))
    return false;
  if (!cbor_encode_uint(out, x->freeOffset))
    return false;
  return true;
}

bool Core_Access_ser(FILE *out, struct Core_Access *x) {
  switch (x->tag) {
  case Core_Access_simple:
    if (!cbor_encode_tag(out, 120, 0, 1))
      return false;
    if (!Core_TensorName_ser(out, x->simple.tensor))
      return false;
    break;
  case Core_Access_basic:
    if (!cbor_encode_tag(out, 120, 1, 1))
      return false;
    if (!Core_AccessBasic_ser(out, x->basic.access))
      return false;
    break;
  case Core_Access_pattern:
    if (!cbor_encode_tag(out, 120, 2, 1))
      return false;
    if (!Core_AccessPattern_ser(out, x->pattern.access))
      return false;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_TensorHbm_ser(FILE *out, struct Core_TensorHbm *x) {
  if (!cbor_encode_tag(out, 121, 0, 4))
    return false;
  if (!String_ser(out, x->name))
    return false;
  if (!Core_Dtype_ser(out, x->dtype))
    return false;
  if (!cbor_encode_uint(out, x->address))
    return false;
  if (!Core_APPair_List_ser(out, x->dims))
    return false;
  return true;
}

bool Core_ParQuadrant_ser(FILE *out, enum Core_ParQuadrant x) {
  switch (x) {
  case Core_ParQuadrant_par0:
    if (!cbor_encode_tag(out, 122, 0, 0))
      return false;
    break;
  case Core_ParQuadrant_par32:
    if (!cbor_encode_tag(out, 122, 1, 0))
      return false;
    break;
  case Core_ParQuadrant_par64:
    if (!cbor_encode_tag(out, 122, 2, 0))
      return false;
    break;
  case Core_ParQuadrant_par96:
    if (!cbor_encode_tag(out, 122, 3, 0))
      return false;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_TensorSram_ser(FILE *out, struct Core_TensorSram *x) {
  if (!cbor_encode_tag(out, 123, 0, 6))
    return false;
  if (!String_ser(out, x->name))
    return false;
  if (!Core_Dtype_ser(out, x->dtype))
    return false;
  if (!Core_ParQuadrant_ser(out, x->parQuadrant))
    return false;
  if (!cbor_encode_uint(out, x->parDim))
    return false;
  if (!cbor_encode_uint(out, x->freeOffset))
    return false;
  if (!Core_APPair_List_ser(out, x->freePattern))
    return false;
  return true;
}

bool Core_TensorRef_ser(FILE *out, struct Core_TensorRef *x) {
  switch (x->tag) {
  case Core_TensorRef_abstract:
    if (!cbor_encode_tag(out, 124, 0, 1))
      return false;
    if (!Core_Access_ser(out, x->abstract.access))
      return false;
    break;
  case Core_TensorRef_sbuf:
    if (!cbor_encode_tag(out, 124, 1, 1))
      return false;
    if (!Core_TensorSram_ser(out, x->sbuf.view))
      return false;
    break;
  case Core_TensorRef_psum:
    if (!cbor_encode_tag(out, 124, 2, 1))
      return false;
    if (!Core_TensorSram_ser(out, x->psum.view))
      return false;
    break;
  case Core_TensorRef_hbm:
    if (!cbor_encode_tag(out, 124, 3, 1))
      return false;
    if (!Core_TensorHbm_ser(out, x->hbm.view))
      return false;
    break;
  case Core_TensorRef_register:
    if (!cbor_encode_tag(out, 124, 4, 1))
      return false;
    if (!cbor_encode_uint(out, x->r.reg))
      return false;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_Engine_ser(FILE *out, enum Core_Engine x) {
  switch (x) {
  case Core_Engine_unassigned:
    if (!cbor_encode_tag(out, 130, 0, 0))
      return false;
    break;
  case Core_Engine_act:
    if (!cbor_encode_tag(out, 130, 1, 0))
      return false;
    break;
  case Core_Engine_dma:
    if (!cbor_encode_tag(out, 130, 2, 0))
      return false;
    break;
  case Core_Engine_dve:
    if (!cbor_encode_tag(out, 130, 3, 0))
      return false;
    break;
  case Core_Engine_pe:
    if (!cbor_encode_tag(out, 130, 4, 0))
      return false;
    break;
  case Core_Engine_pool:
    if (!cbor_encode_tag(out, 130, 5, 0))
      return false;
    break;
  case Core_Engine_sp:
    if (!cbor_encode_tag(out, 130, 6, 0))
      return false;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_Immediate_ser(FILE *out, struct Core_Immediate *x) {
  switch (x->tag) {
  case Core_Immediate_register:
    if (!cbor_encode_tag(out, 131, 0, 1))
      return false;
    if (!cbor_encode_uint(out, x->r.reg))
      return false;
    break;
  case Core_Immediate_pointer:
    if (!cbor_encode_tag(out, 131, 1, 0))
      return false;
    break;
  case Core_Immediate_int:
    if (!cbor_encode_tag(out, 131, 2, 1))
      return false;
    if (!cbor_encode_int(out, x->i.i))
      return false;
    break;
  case Core_Immediate_float:
    if (!cbor_encode_tag(out, 131, 3, 1))
      return false;
    if (!cbor_encode_float(out, x->f.f))
      return false;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_ActivationImm_ser(FILE *out, struct Core_ActivationImm *x) {
  switch (x->tag) {
  case Core_ActivationImm_register:
    if (!cbor_encode_tag(out, 132, 0, 1))
      return false;
    if (!cbor_encode_uint(out, x->r.reg))
      return false;
    break;
  case Core_ActivationImm_pointer:
    if (!cbor_encode_tag(out, 132, 1, 0))
      return false;
    break;
  case Core_ActivationImm_float:
    if (!cbor_encode_tag(out, 132, 2, 1))
      return false;
    if (!cbor_encode_float(out, x->f.f))
      return false;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_Operand_ser(FILE *out, struct Core_Operand *x) {
  switch (x->tag) {
  case Core_Operand_imm:
    if (!cbor_encode_tag(out, 133, 0, 1))
      return false;
    if (!Core_Immediate_ser(out, x->imm.i))
      return false;
    break;
  case Core_Operand_tile:
    if (!cbor_encode_tag(out, 133, 1, 1))
      return false;
    if (!Core_TensorRef_ser(out, x->tile.t))
      return false;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_DataPattern_ser(FILE *out, struct Core_DataPattern *x) {
  if (!cbor_encode_tag(out, 134, 0, 2))
    return false;
  if (!cbor_encode_uint(out, x->offset))
    return false;
  if (!Core_APPair_List_ser(out, x->pattern))
    return false;
  return true;
}

bool Core_AluOp_ser(FILE *out, enum Core_AluOp x) {
  switch (x) {
  case Core_AluOp_abs:
    if (!cbor_encode_tag(out, 135, 0, 0))
      return false;
    break;
  case Core_AluOp_add:
    if (!cbor_encode_tag(out, 135, 1, 0))
      return false;
    break;
  case Core_AluOp_arith_shift_left:
    if (!cbor_encode_tag(out, 135, 2, 0))
      return false;
    break;
  case Core_AluOp_arith_shift_right:
    if (!cbor_encode_tag(out, 135, 3, 0))
      return false;
    break;
  case Core_AluOp_average:
    if (!cbor_encode_tag(out, 135, 4, 0))
      return false;
    break;
  case Core_AluOp_bitwise_and:
    if (!cbor_encode_tag(out, 135, 5, 0))
      return false;
    break;
  case Core_AluOp_bitwise_not:
    if (!cbor_encode_tag(out, 135, 6, 0))
      return false;
    break;
  case Core_AluOp_bitwise_or:
    if (!cbor_encode_tag(out, 135, 7, 0))
      return false;
    break;
  case Core_AluOp_bitwise_xor:
    if (!cbor_encode_tag(out, 135, 8, 0))
      return false;
    break;
  case Core_AluOp_bypass:
    if (!cbor_encode_tag(out, 135, 9, 0))
      return false;
    break;
  case Core_AluOp_divide:
    if (!cbor_encode_tag(out, 135, 10, 0))
      return false;
    break;
  case Core_AluOp_is_equal:
    if (!cbor_encode_tag(out, 135, 11, 0))
      return false;
    break;
  case Core_AluOp_is_ge:
    if (!cbor_encode_tag(out, 135, 12, 0))
      return false;
    break;
  case Core_AluOp_is_gt:
    if (!cbor_encode_tag(out, 135, 13, 0))
      return false;
    break;
  case Core_AluOp_is_le:
    if (!cbor_encode_tag(out, 135, 14, 0))
      return false;
    break;
  case Core_AluOp_is_lt:
    if (!cbor_encode_tag(out, 135, 15, 0))
      return false;
    break;
  case Core_AluOp_logical_and:
    if (!cbor_encode_tag(out, 135, 16, 0))
      return false;
    break;
  case Core_AluOp_logical_or:
    if (!cbor_encode_tag(out, 135, 17, 0))
      return false;
    break;
  case Core_AluOp_logical_shift_left:
    if (!cbor_encode_tag(out, 135, 18, 0))
      return false;
    break;
  case Core_AluOp_logical_shift_right:
    if (!cbor_encode_tag(out, 135, 19, 0))
      return false;
    break;
  case Core_AluOp_logical_xor:
    if (!cbor_encode_tag(out, 135, 20, 0))
      return false;
    break;
  case Core_AluOp_max:
    if (!cbor_encode_tag(out, 135, 21, 0))
      return false;
    break;
  case Core_AluOp_min:
    if (!cbor_encode_tag(out, 135, 22, 0))
      return false;
    break;
  case Core_AluOp_mod:
    if (!cbor_encode_tag(out, 135, 23, 0))
      return false;
    break;
  case Core_AluOp_mult:
    if (!cbor_encode_tag(out, 135, 24, 0))
      return false;
    break;
  case Core_AluOp_not_equal:
    if (!cbor_encode_tag(out, 135, 25, 0))
      return false;
    break;
  case Core_AluOp_pow:
    if (!cbor_encode_tag(out, 135, 26, 0))
      return false;
    break;
  case Core_AluOp_rsqrt:
    if (!cbor_encode_tag(out, 135, 27, 0))
      return false;
    break;
  case Core_AluOp_subtract:
    if (!cbor_encode_tag(out, 135, 28, 0))
      return false;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_DropoutThresholdType_ser(FILE *out,
                                   enum Core_DropoutThresholdType x) {
  switch (x) {
  case Core_DropoutThresholdType_DropRate:
    if (!cbor_encode_tag(out, 136, 0, 0))
      return false;
    break;
  case Core_DropoutThresholdType_KeepRate:
    if (!cbor_encode_tag(out, 136, 1, 0))
      return false;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_AccumCmd_ser(FILE *out, enum Core_AccumCmd x) {
  switch (x) {
  case Core_AccumCmd_Idle:
    if (!cbor_encode_tag(out, 137, 0, 0))
      return false;
    break;
  case Core_AccumCmd_Zero:
    if (!cbor_encode_tag(out, 137, 1, 0))
      return false;
    break;
  case Core_AccumCmd_Accumulate:
    if (!cbor_encode_tag(out, 137, 2, 0))
      return false;
    break;
  case Core_AccumCmd_ZeroAccumulate:
    if (!cbor_encode_tag(out, 137, 3, 0))
      return false;
    break;
  case Core_AccumCmd_LoadAccumulate:
    if (!cbor_encode_tag(out, 137, 4, 0))
      return false;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_ActivationFunc_ser(FILE *out, enum Core_ActivationFunc x) {
  switch (x) {
  case Core_ActivationFunc_abs:
    if (!cbor_encode_tag(out, 138, 0, 0))
      return false;
    break;
  case Core_ActivationFunc_arctan:
    if (!cbor_encode_tag(out, 138, 1, 0))
      return false;
    break;
  case Core_ActivationFunc_copy:
    if (!cbor_encode_tag(out, 138, 2, 0))
      return false;
    break;
  case Core_ActivationFunc_erf:
    if (!cbor_encode_tag(out, 138, 3, 0))
      return false;
    break;
  case Core_ActivationFunc_erf_dx:
    if (!cbor_encode_tag(out, 138, 4, 0))
      return false;
    break;
  case Core_ActivationFunc_exp:
    if (!cbor_encode_tag(out, 138, 5, 0))
      return false;
    break;
  case Core_ActivationFunc_gelu:
    if (!cbor_encode_tag(out, 138, 6, 0))
      return false;
    break;
  case Core_ActivationFunc_gelu_apprx_tanh:
    if (!cbor_encode_tag(out, 138, 7, 0))
      return false;
    break;
  case Core_ActivationFunc_gelu_dx:
    if (!cbor_encode_tag(out, 138, 8, 0))
      return false;
    break;
  case Core_ActivationFunc_log:
    if (!cbor_encode_tag(out, 138, 9, 0))
      return false;
    break;
  case Core_ActivationFunc_mish:
    if (!cbor_encode_tag(out, 138, 10, 0))
      return false;
    break;
  case Core_ActivationFunc_reciprocal:
    if (!cbor_encode_tag(out, 138, 11, 0))
      return false;
    break;
  case Core_ActivationFunc_relu:
    if (!cbor_encode_tag(out, 138, 12, 0))
      return false;
    break;
  case Core_ActivationFunc_rsqrt:
    if (!cbor_encode_tag(out, 138, 13, 0))
      return false;
    break;
  case Core_ActivationFunc_sigmoid:
    if (!cbor_encode_tag(out, 138, 14, 0))
      return false;
    break;
  case Core_ActivationFunc_sign:
    if (!cbor_encode_tag(out, 138, 15, 0))
      return false;
    break;
  case Core_ActivationFunc_silu:
    if (!cbor_encode_tag(out, 138, 16, 0))
      return false;
    break;
  case Core_ActivationFunc_silu_dx:
    if (!cbor_encode_tag(out, 138, 17, 0))
      return false;
    break;
  case Core_ActivationFunc_sin:
    if (!cbor_encode_tag(out, 138, 18, 0))
      return false;
    break;
  case Core_ActivationFunc_softplus:
    if (!cbor_encode_tag(out, 138, 19, 0))
      return false;
    break;
  case Core_ActivationFunc_sqrt:
    if (!cbor_encode_tag(out, 138, 20, 0))
      return false;
    break;
  case Core_ActivationFunc_square:
    if (!cbor_encode_tag(out, 138, 21, 0))
      return false;
    break;
  case Core_ActivationFunc_tanh:
    if (!cbor_encode_tag(out, 138, 22, 0))
      return false;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_AffineSelectCmp_ser(FILE *out, enum Core_AffineSelectCmp x) {
  switch (x) {
  case Core_AffineSelectCmp_GreaterThan:
    if (!cbor_encode_tag(out, 139, 0, 0))
      return false;
    break;
  case Core_AffineSelectCmp_GreaterThanEq:
    if (!cbor_encode_tag(out, 139, 1, 0))
      return false;
    break;
  case Core_AffineSelectCmp_Eq:
    if (!cbor_encode_tag(out, 139, 2, 0))
      return false;
    break;
  case Core_AffineSelectCmp_NotEq:
    if (!cbor_encode_tag(out, 139, 3, 0))
      return false;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_DgeComputeOp_ser(FILE *out, enum Core_DgeComputeOp x) {
  switch (x) {
  case Core_DgeComputeOp_none:
    if (!cbor_encode_tag(out, 140, 0, 0))
      return false;
    break;
  case Core_DgeComputeOp_add:
    if (!cbor_encode_tag(out, 140, 1, 0))
      return false;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_DmaBounds_ser(FILE *out, struct Core_DmaBounds *x) {
  switch (x->tag) {
  case Core_DmaBounds_disable:
    if (!cbor_encode_tag(out, 141, 0, 0))
      return false;
    break;
  case Core_DmaBounds_enable:
    if (!cbor_encode_tag(out, 141, 1, 0))
      return false;
    break;
  case Core_DmaBounds_reg:
    if (!cbor_encode_tag(out, 141, 2, 1))
      return false;
    if (!cbor_encode_uint(out, x->reg.reg))
      return false;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_MatmulGroupElement_ser(FILE *out, enum Core_MatmulGroupElement x) {
  switch (x) {
  case Core_MatmulGroupElement_first:
    if (!cbor_encode_tag(out, 142, 0, 0))
      return false;
    break;
  case Core_MatmulGroupElement_middle:
    if (!cbor_encode_tag(out, 142, 1, 0))
      return false;
    break;
  case Core_MatmulGroupElement_last:
    if (!cbor_encode_tag(out, 142, 2, 0))
      return false;
    break;
  case Core_MatmulGroupElement_whole:
    if (!cbor_encode_tag(out, 142, 3, 0))
      return false;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_IndexMissBehavior_ser(FILE *out, struct Core_IndexMissBehavior *x) {
  switch (x->tag) {
  case Core_IndexMissBehavior_imm:
    if (!cbor_encode_tag(out, 143, 0, 1))
      return false;
    if (!Core_Immediate_ser(out, x->imm.value))
      return false;
    break;
  case Core_IndexMissBehavior_skip:
    if (!cbor_encode_tag(out, 143, 1, 0))
      return false;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_TensorScalarReverseOps_ser(FILE *out,
                                     enum Core_TensorScalarReverseOps x) {
  switch (x) {
  case Core_TensorScalarReverseOps_none:
    if (!cbor_encode_tag(out, 144, 0, 0))
      return false;
    break;
  case Core_TensorScalarReverseOps_first:
    if (!cbor_encode_tag(out, 144, 1, 0))
      return false;
    break;
  case Core_TensorScalarReverseOps_second:
    if (!cbor_encode_tag(out, 144, 2, 0))
      return false;
    break;
  case Core_TensorScalarReverseOps_both:
    if (!cbor_encode_tag(out, 144, 3, 0))
      return false;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_TensorSubDim_ser(FILE *out, enum Core_TensorSubDim x) {
  switch (x) {
  case Core_TensorSubDim_X:
    if (!cbor_encode_tag(out, 145, 0, 0))
      return false;
    break;
  case Core_TensorSubDim_XY:
    if (!cbor_encode_tag(out, 145, 1, 0))
      return false;
    break;
  case Core_TensorSubDim_XYZ:
    if (!cbor_encode_tag(out, 145, 2, 0))
      return false;
    break;
  case Core_TensorSubDim_XYZW:
    if (!cbor_encode_tag(out, 145, 3, 0))
      return false;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_TransposeOps_ser(FILE *out, enum Core_TransposeOps x) {
  switch (x) {
  case Core_TransposeOps_None:
    if (!cbor_encode_tag(out, 146, 0, 0))
      return false;
    break;
  case Core_TransposeOps_WZXY:
    if (!cbor_encode_tag(out, 146, 1, 0))
      return false;
    break;
  case Core_TransposeOps_WXZY:
    if (!cbor_encode_tag(out, 146, 2, 0))
      return false;
    break;
  case Core_TransposeOps_WYXZ:
    if (!cbor_encode_tag(out, 146, 3, 0))
      return false;
    break;
  case Core_TransposeOps_ZWYX:
    if (!cbor_encode_tag(out, 146, 4, 0))
      return false;
    break;
  case Core_TransposeOps_ZYWX:
    if (!cbor_encode_tag(out, 146, 5, 0))
      return false;
    break;
  case Core_TransposeOps_ZYXW:
    if (!cbor_encode_tag(out, 146, 6, 0))
      return false;
    break;
  case Core_TransposeOps_YXWZ:
    if (!cbor_encode_tag(out, 146, 7, 0))
      return false;
    break;
  case Core_TransposeOps_YXZW:
    if (!cbor_encode_tag(out, 146, 8, 0))
      return false;
    break;
  case Core_TransposeOps_YWZX:
    if (!cbor_encode_tag(out, 146, 9, 0))
      return false;
    break;
  case Core_TransposeOps_XWZY:
    if (!cbor_encode_tag(out, 146, 10, 0))
      return false;
    break;
  case Core_TransposeOps_XZYW:
    if (!cbor_encode_tag(out, 146, 11, 0))
      return false;
    break;
  case Core_TransposeOps_XYZW:
    if (!cbor_encode_tag(out, 146, 12, 0))
      return false;
    break;
  case Core_TransposeOps_XYWZ:
    if (!cbor_encode_tag(out, 146, 13, 0))
      return false;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_Dropout_ser(FILE *out, struct Core_Dropout *x) {
  if (!cbor_encode_tag(out, 147, 0, 5))
    return false;
  if (!Core_TensorRef_ser(out, x->dst))
    return false;
  if (!Core_TensorRef_ser(out, x->src))
    return false;
  if (!Core_DropoutThresholdType_ser(out, x->thresholdType))
    return false;
  if (!Core_Operand_ser(out, x->threshold))
    return false;
  if (!Core_Dtype_Option_ser(out, x->dtype))
    return false;
  return true;
}

bool Core_Activate_ser(FILE *out, struct Core_Activate *x) {
  if (!cbor_encode_tag(out, 148, 0, 7))
    return false;
  if (!Core_TensorRef_ser(out, x->dst))
    return false;
  if (!Core_TensorRef_ser(out, x->src))
    return false;
  if (!Core_AccumCmd_ser(out, x->accumulatorCmd))
    return false;
  if (!Core_ActivationFunc_ser(out, x->activationFunc))
    return false;
  if (!Core_Immediate_ser(out, x->scale))
    return false;
  if (!Core_Immediate_ser(out, x->bias))
    return false;
  if (!Core_Immediate_ser(out, x->imm))
    return false;
  return true;
}

bool Core_AffineSelect_ser(FILE *out, struct Core_AffineSelect *x) {
  if (!cbor_encode_tag(out, 150, 0, 5))
    return false;
  if (!Core_TensorRef_ser(out, x->dst))
    return false;
  if (!Core_TensorRef_ser(out, x->src))
    return false;
  if (!Core_AffineSelectCmp_ser(out, x->fillMode))
    return false;
  if (!cbor_encode_uint(out, x->fillReg))
    return false;
  if (!Core_DataPattern_ser(out, x->maskPattern))
    return false;
  return true;
}

bool Core_DmaCopy_ser(FILE *out, struct Core_DmaCopy *x) {
  if (!cbor_encode_tag(out, 152, 0, 5))
    return false;
  if (!Core_TensorRef_ser(out, x->dst))
    return false;
  if (!Core_TensorRef_ser(out, x->src))
    return false;
  if (!Core_DgeComputeOp_ser(out, x->compute_op))
    return false;
  if (!Core_DmaBounds_ser(out, x->dstBoundsCheck))
    return false;
  if (!Core_DmaBounds_ser(out, x->srcBoundsCheck))
    return false;
  return true;
}

bool Core_DmaTranspose_ser(FILE *out, struct Core_DmaTranspose *x) {
  if (!cbor_encode_tag(out, 154, 0, 4))
    return false;
  if (!Core_TensorRef_ser(out, x->dst))
    return false;
  if (!Core_TensorRef_ser(out, x->src))
    return false;
  if (!Core_TransposeOps_ser(out, x->axes))
    return false;
  if (!Core_Dtype_Option_ser(out, x->dtype))
    return false;
  return true;
}

bool Core_Transpose_ser(FILE *out, struct Core_Transpose *x) {
  if (!cbor_encode_tag(out, 155, 0, 4))
    return false;
  if (!Core_TensorRef_ser(out, x->dst))
    return false;
  if (!Core_TensorRef_ser(out, x->src))
    return false;
  if (!Core_Dtype_Option_ser(out, x->dtype))
    return false;
  if (!Core_Engine_ser(out, x->engine))
    return false;
  return true;
}

bool Core_LoadMaskRegister_ser(FILE *out, struct Core_LoadMaskRegister *x) {
  if (!cbor_encode_tag(out, 156, 0, 1))
    return false;
  if (!cbor_encode_uint(out, x->regNum))
    return false;
  return true;
}

bool Core_Shuffle_ser(FILE *out, struct Core_Shuffle *x) {
  if (!cbor_encode_tag(out, 157, 0, 4))
    return false;
  if (!Core_TensorRef_ser(out, x->dst))
    return false;
  if (!Core_TensorRef_ser(out, x->src))
    return false;
  if (!Core_Immediate_List_ser(out, x->shuffleMask))
    return false;
  if (!Core_Dtype_Option_ser(out, x->dtype))
    return false;
  return true;
}

bool Core_MemSet_ser(FILE *out, struct Core_MemSet *x) {
  if (!cbor_encode_tag(out, 158, 0, 4))
    return false;
  if (!Core_TensorRef_ser(out, x->dst))
    return false;
  if (!Core_Immediate_ser(out, x->value))
    return false;
  if (!Core_Dtype_ser(out, x->dtype))
    return false;
  if (!Core_Engine_ser(out, x->engine))
    return false;
  return true;
}

bool Core_Iota_ser(FILE *out, struct Core_Iota *x) {
  if (!cbor_encode_tag(out, 159, 0, 3))
    return false;
  if (!Core_TensorRef_ser(out, x->dst))
    return false;
  if (!Core_DataPattern_ser(out, x->pattern))
    return false;
  if (!Core_Dtype_Option_ser(out, x->dtype))
    return false;
  return true;
}

bool Core_LoadStationary_ser(FILE *out, struct Core_LoadStationary *x) {
  if (!cbor_encode_tag(out, 160, 0, 2))
    return false;
  if (!Core_TensorRef_ser(out, x->src))
    return false;
  if (!cbor_encode_bool(out, x->isTranspose))
    return false;
  return true;
}

bool Core_MatMul_ser(FILE *out, struct Core_MatMul *x) {
  if (!cbor_encode_tag(out, 161, 0, 3))
    return false;
  if (!Core_TensorRef_ser(out, x->dst))
    return false;
  if (!Core_TensorRef_ser(out, x->moving))
    return false;
  if (!Core_MatmulGroupElement_ser(out, x->psumAccumulateFlag))
    return false;
  return true;
}

bool Core_LocalGather_ser(FILE *out, struct Core_LocalGather *x) {
  if (!cbor_encode_tag(out, 162, 0, 4))
    return false;
  if (!Core_TensorRef_ser(out, x->dst))
    return false;
  if (!Core_TensorRef_ser(out, x->src))
    return false;
  if (!Core_IndexMissBehavior_ser(out, x->indexMissBehavior))
    return false;
  if (!cbor_encode_bool(out, x->freePoolBuffer))
    return false;
  return true;
}

bool Core_RangeSelect_ser(FILE *out, struct Core_RangeSelect *x) {
  if (!cbor_encode_tag(out, 164, 0, 10))
    return false;
  if (!Core_TensorRef_ser(out, x->dst))
    return false;
  if (!Core_TensorRef_ser(out, x->src))
    return false;
  if (!Core_AccumCmd_ser(out, x->reduceCommand))
    return false;
  if (!Core_AluOp_ser(out, x->reduceOp))
    return false;
  if (!cbor_encode_float(out, x->base))
    return false;
  if (!cbor_encode_float(out, x->fillValue))
    return false;
  if (!Core_AluOp_ser(out, x->compOp0))
    return false;
  if (!Core_AluOp_ser(out, x->compOp1))
    return false;
  if (!Core_Immediate_ser(out, x->bound0))
    return false;
  if (!Core_Immediate_ser(out, x->bound1))
    return false;
  return true;
}

bool Core_ScalarTensorTensor_ser(FILE *out, struct Core_ScalarTensorTensor *x) {
  if (!cbor_encode_tag(out, 166, 0, 8))
    return false;
  if (!Core_TensorRef_ser(out, x->dst))
    return false;
  if (!Core_TensorRef_ser(out, x->src0))
    return false;
  if (!Core_TensorRef_ser(out, x->src1))
    return false;
  if (!Core_AluOp_ser(out, x->op0))
    return false;
  if (!Core_AluOp_ser(out, x->op1))
    return false;
  if (!Core_TensorScalarReverseOps_ser(out, x->reverseOperands))
    return false;
  if (!Core_Immediate_ser(out, x->imm0))
    return false;
  if (!Core_AccumCmd_ser(out, x->accumulatorCmd))
    return false;
  return true;
}

bool Core_CopyPredicated_ser(FILE *out, struct Core_CopyPredicated *x) {
  if (!cbor_encode_tag(out, 168, 0, 5))
    return false;
  if (!Core_TensorRef_ser(out, x->dst))
    return false;
  if (!Core_TensorRef_ser(out, x->src))
    return false;
  if (!Core_TensorRef_ser(out, x->predicate))
    return false;
  if (!Core_Dtype_Option_ser(out, x->dtype))
    return false;
  if (!cbor_encode_bool(out, x->reversePred))
    return false;
  return true;
}

bool Core_TensorTensorScan_ser(FILE *out, struct Core_TensorTensorScan *x) {
  if (!cbor_encode_tag(out, 169, 0, 9))
    return false;
  if (!Core_TensorRef_ser(out, x->dst))
    return false;
  if (!Core_TensorRef_ser(out, x->src0))
    return false;
  if (!Core_TensorRef_ser(out, x->src1))
    return false;
  if (!Core_AluOp_ser(out, x->op0))
    return false;
  if (!Core_AluOp_ser(out, x->op1))
    return false;
  if (!Core_TensorScalarReverseOps_ser(out, x->reverseOperands))
    return false;
  if (!Core_Operand_ser(out, x->imm0))
    return false;
  if (!Core_AccumCmd_ser(out, x->accumulatorCmd))
    return false;
  if (!Core_Dtype_Option_ser(out, x->dtype))
    return false;
  return true;
}

bool Core_MatchValueLoad_ser(FILE *out, struct Core_MatchValueLoad *x) {
  if (!cbor_encode_tag(out, 170, 0, 1))
    return false;
  if (!Core_TensorRef_ser(out, x->src))
    return false;
  return true;
}

bool Core_FindIndex8_ser(FILE *out, struct Core_FindIndex8 *x) {
  if (!cbor_encode_tag(out, 171, 0, 4))
    return false;
  if (!Core_TensorRef_ser(out, x->dst))
    return false;
  if (!Core_TensorRef_ser(out, x->src))
    return false;
  if (!Core_TensorRef_ser(out, x->vals))
    return false;
  if (!Core_Dtype_Option_ser(out, x->dtype))
    return false;
  return true;
}

bool Core_MatchReplace8_ser(FILE *out, struct Core_MatchReplace8 *x) {
  if (!cbor_encode_tag(out, 172, 0, 6))
    return false;
  if (!Core_TensorRef_ser(out, x->dst))
    return false;
  if (!Core_TensorRef_ser(out, x->src))
    return false;
  if (!Core_TensorRef_ser(out, x->vals))
    return false;
  if (!Core_Immediate_ser(out, x->replaceValue))
    return false;
  if (!Core_TensorRef_Option_ser(out, x->dstIdx))
    return false;
  if (!Core_Dtype_Option_ser(out, x->dtype))
    return false;
  return true;
}

bool Core_Max8_ser(FILE *out, struct Core_Max8 *x) {
  if (!cbor_encode_tag(out, 173, 0, 3))
    return false;
  if (!Core_TensorRef_ser(out, x->dst))
    return false;
  if (!Core_TensorRef_ser(out, x->src))
    return false;
  if (!Core_Dtype_Option_ser(out, x->dtype))
    return false;
  return true;
}

bool Core_BatchNormAggregate_ser(FILE *out, struct Core_BatchNormAggregate *x) {
  if (!cbor_encode_tag(out, 174, 0, 3))
    return false;
  if (!Core_TensorRef_ser(out, x->dst))
    return false;
  if (!Core_TensorRef_ser(out, x->src))
    return false;
  if (!Core_Dtype_Option_ser(out, x->dtype))
    return false;
  return true;
}

bool Core_BatchNormStats_ser(FILE *out, struct Core_BatchNormStats *x) {
  if (!cbor_encode_tag(out, 175, 0, 3))
    return false;
  if (!Core_TensorRef_ser(out, x->dst))
    return false;
  if (!Core_TensorRef_ser(out, x->src))
    return false;
  if (!Core_Dtype_Option_ser(out, x->dtype))
    return false;
  return true;
}

bool Core_Reciprocal_ser(FILE *out, struct Core_Reciprocal *x) {
  if (!cbor_encode_tag(out, 176, 0, 3))
    return false;
  if (!Core_TensorRef_ser(out, x->dst))
    return false;
  if (!Core_TensorRef_ser(out, x->src))
    return false;
  if (!Core_Dtype_Option_ser(out, x->dtype))
    return false;
  return true;
}

bool Core_Copy_ser(FILE *out, struct Core_Copy *x) {
  if (!cbor_encode_tag(out, 177, 0, 3))
    return false;
  if (!Core_TensorRef_ser(out, x->dst))
    return false;
  if (!Core_TensorRef_ser(out, x->src))
    return false;
  if (!Core_TensorSubDim_Option_ser(out, x->opDim))
    return false;
  return true;
}

bool Core_TensorReduce_ser(FILE *out, struct Core_TensorReduce *x) {
  if (!cbor_encode_tag(out, 179, 0, 7))
    return false;
  if (!Core_TensorRef_ser(out, x->dst))
    return false;
  if (!Core_TensorRef_ser(out, x->src))
    return false;
  if (!Core_AluOp_ser(out, x->op))
    return false;
  if (!Core_TensorSubDim_ser(out, x->opDim))
    return false;
  if (!cbor_encode_bool(out, x->negated))
    return false;
  if (!Core_Dtype_Option_ser(out, x->dtype))
    return false;
  if (!cbor_encode_bool(out, x->keepdims))
    return false;
  return true;
}

bool Core_TensorScalar_ser(FILE *out, struct Core_TensorScalar *x) {
  if (!cbor_encode_tag(out, 180, 0, 9))
    return false;
  if (!Core_TensorRef_ser(out, x->dst))
    return false;
  if (!Core_TensorRef_ser(out, x->src))
    return false;
  if (!Core_Operand_ser(out, x->imm0))
    return false;
  if (!Core_AluOp_ser(out, x->op0))
    return false;
  if (!Core_Operand_Option_ser(out, x->imm1))
    return false;
  if (!Core_AluOp_Option_ser(out, x->op1))
    return false;
  if (!Core_TensorScalarReverseOps_ser(out, x->reverse))
    return false;
  if (!Core_Engine_ser(out, x->engine))
    return false;
  if (!Core_Dtype_Option_ser(out, x->dtype))
    return false;
  return true;
}

bool Core_TensorTensor_ser(FILE *out, struct Core_TensorTensor *x) {
  if (!cbor_encode_tag(out, 182, 0, 6))
    return false;
  if (!Core_TensorRef_ser(out, x->dst))
    return false;
  if (!Core_TensorRef_ser(out, x->src0))
    return false;
  if (!Core_TensorRef_ser(out, x->src1))
    return false;
  if (!Core_AluOp_ser(out, x->op))
    return false;
  if (!Core_Dtype_Option_ser(out, x->dtype))
    return false;
  if (!Core_Engine_ser(out, x->engine))
    return false;
  return true;
}

bool Core_NcMatMul_ser(FILE *out, struct Core_NcMatMul *x) {
  if (!cbor_encode_tag(out, 183, 0, 8))
    return false;
  if (!Core_TensorRef_ser(out, x->dst))
    return false;
  if (!Core_TensorRef_ser(out, x->stationary))
    return false;
  if (!Core_TensorRef_ser(out, x->moving))
    return false;
  if (!cbor_encode_bool(out, x->isStationaryOneZero))
    return false;
  if (!cbor_encode_bool(out, x->isMovingZero))
    return false;
  if (!cbor_encode_bool(out, x->isTranspose))
    return false;
  if (!Nat_List_ser(out, x->tilePosition))
    return false;
  if (!Nat_List_ser(out, x->tileSize))
    return false;
  return true;
}

bool Core_TensorScalarReduce_ser(FILE *out, struct Core_TensorScalarReduce *x) {
  if (!cbor_encode_tag(out, 181, 0, 8))
    return false;
  if (!Core_TensorRef_ser(out, x->dst))
    return false;
  if (!Core_TensorRef_ser(out, x->src))
    return false;
  if (!Core_Operand_ser(out, x->operand0))
    return false;
  if (!Core_AluOp_ser(out, x->op0))
    return false;
  if (!cbor_encode_bool(out, x->reverse0))
    return false;
  if (!Core_Dtype_Option_ser(out, x->dtype))
    return false;
  if (!Core_AluOp_Option_ser(out, x->reduceOp))
    return false;
  if (!Core_TensorRef_ser(out, x->reduceRes))
    return false;
  return true;
}

bool Core_TensorPartitionReduce_ser(FILE *out,
                                    struct Core_TensorPartitionReduce *x) {
  if (!cbor_encode_tag(out, 184, 0, 4))
    return false;
  if (!Core_TensorRef_ser(out, x->dst))
    return false;
  if (!Core_AluOp_ser(out, x->op))
    return false;
  if (!Core_TensorRef_ser(out, x->data))
    return false;
  if (!Core_Dtype_Option_ser(out, x->dtype))
    return false;
  return true;
}

bool Core_NcActivate_ser(FILE *out, struct Core_NcActivate *x) {
  if (!cbor_encode_tag(out, 149, 0, 9))
    return false;
  if (!Core_TensorRef_ser(out, x->dst))
    return false;
  if (!Core_TensorRef_ser(out, x->src))
    return false;
  if (!Core_AccumCmd_ser(out, x->accumulatorCmd))
    return false;
  if (!Core_ActivationFunc_ser(out, x->activationFunc))
    return false;
  if (!Core_Immediate_ser(out, x->scale))
    return false;
  if (!Core_Immediate_ser(out, x->bias))
    return false;
  if (!Core_AluOp_Option_ser(out, x->reduceOp))
    return false;
  if (!Core_TensorRef_Option_ser(out, x->reduceRes))
    return false;
  if (!Core_Dtype_Option_ser(out, x->dtype))
    return false;
  return true;
}

bool Core_NcAffineSelect_ser(FILE *out, struct Core_NcAffineSelect *x) {
  if (!cbor_encode_tag(out, 151, 0, 6))
    return false;
  if (!Core_TensorRef_ser(out, x->dst))
    return false;
  if (!Core_DataPattern_ser(out, x->pred))
    return false;
  if (!Core_TensorRef_ser(out, x->onTrueTile))
    return false;
  if (!Core_Immediate_ser(out, x->onFalseValue))
    return false;
  if (!Core_Dtype_Option_ser(out, x->dtype))
    return false;
  if (!Core_AluOp_ser(out, x->cmpOp))
    return false;
  return true;
}

bool Core_NcDmaCopy_ser(FILE *out, struct Core_NcDmaCopy *x) {
  if (!cbor_encode_tag(out, 153, 0, 5))
    return false;
  if (!Core_TensorRef_ser(out, x->dst))
    return false;
  if (!Core_TensorRef_ser(out, x->src))
    return false;
  if (!Core_DgeComputeOp_ser(out, x->compute_op))
    return false;
  if (!Core_DmaBounds_ser(out, x->oobMode))
    return false;
  if (!cbor_encode_uint(out, x->dgeMode))
    return false;
  return true;
}

bool Core_NcLocalGather_ser(FILE *out, struct Core_NcLocalGather *x) {
  if (!cbor_encode_tag(out, 163, 0, 5))
    return false;
  if (!Core_TensorRef_ser(out, x->dst))
    return false;
  if (!Core_TensorRef_ser(out, x->src))
    return false;
  if (!Core_TensorRef_ser(out, x->index))
    return false;
  if (!Core_Immediate_ser(out, x->numElemPerIdx))
    return false;
  if (!Core_Immediate_Option_ser(out, x->numValidIndicies))
    return false;
  return true;
}

bool Core_NcRangeSelect_ser(FILE *out, struct Core_NcRangeSelect *x) {
  if (!cbor_encode_tag(out, 165, 0, 12))
    return false;
  if (!Core_TensorRef_ser(out, x->dst))
    return false;
  if (!Core_AccumCmd_ser(out, x->reduceCommand))
    return false;
  if (!Core_TensorRef_Option_ser(out, x->reduceRes))
    return false;
  if (!Core_AluOp_Option_ser(out, x->reduceOp))
    return false;
  if (!Core_AluOp_ser(out, x->compOp0))
    return false;
  if (!Core_AluOp_ser(out, x->compOp1))
    return false;
  if (!Core_TensorRef_ser(out, x->bound0))
    return false;
  if (!Core_TensorRef_ser(out, x->bound1))
    return false;
  if (!Core_Immediate_ser(out, x->rangeStart))
    return false;
  if (!Core_TensorRef_ser(out, x->onTrueTile))
    return false;
  if (!Core_Immediate_ser(out, x->onFalseValue))
    return false;
  if (!Core_Dtype_Option_ser(out, x->dtype))
    return false;
  return true;
}

bool Core_NcScalarTensorTensor_ser(FILE *out,
                                   struct Core_NcScalarTensorTensor *x) {
  if (!cbor_encode_tag(out, 167, 0, 8))
    return false;
  if (!Core_TensorRef_ser(out, x->dst))
    return false;
  if (!Core_TensorRef_ser(out, x->data))
    return false;
  if (!Core_Operand_ser(out, x->src0))
    return false;
  if (!Core_Operand_ser(out, x->src1))
    return false;
  if (!Core_AluOp_ser(out, x->op0))
    return false;
  if (!Core_AluOp_ser(out, x->op1))
    return false;
  if (!Core_TensorScalarReverseOps_ser(out, x->reverseOperands))
    return false;
  if (!Core_Dtype_Option_ser(out, x->dtype))
    return false;
  return true;
}

bool Core_NcCopy_ser(FILE *out, struct Core_NcCopy *x) {
  if (!cbor_encode_tag(out, 178, 0, 4))
    return false;
  if (!Core_TensorRef_ser(out, x->dst))
    return false;
  if (!Core_TensorRef_ser(out, x->src))
    return false;
  if (!Core_Dtype_Option_ser(out, x->dtype))
    return false;
  if (!Core_Engine_ser(out, x->engine))
    return false;
  return true;
}

bool Core_SelectReduce_ser(FILE *out, struct Core_SelectReduce *x) {
  if (!cbor_encode_tag(out, 185, 0, 9))
    return false;
  if (!Core_TensorRef_ser(out, x->dst))
    return false;
  if (!Core_TensorRef_ser(out, x->predicate))
    return false;
  if (!Core_TensorRef_ser(out, x->onTrue))
    return false;
  if (!Core_Operand_ser(out, x->onFalse))
    return false;
  if (!Core_TensorRef_Option_ser(out, x->reduceRes))
    return false;
  if (!Core_AccumCmd_ser(out, x->reduceCmd))
    return false;
  if (!Core_AluOp_ser(out, x->reduceOp))
    return false;
  if (!cbor_encode_bool(out, x->reversePred))
    return false;
  if (!Core_Dtype_Option_ser(out, x->dtype))
    return false;
  return true;
}

bool Core_SequenceBounds_ser(FILE *out, struct Core_SequenceBounds *x) {
  if (!cbor_encode_tag(out, 186, 0, 3))
    return false;
  if (!Core_TensorRef_ser(out, x->dst))
    return false;
  if (!Core_TensorRef_ser(out, x->segmentIds))
    return false;
  if (!Core_Dtype_Option_ser(out, x->dtype))
    return false;
  return true;
}

bool Core_Operator_ser(FILE *out, struct Core_Operator *x) {
  switch (x->tag) {
  case Core_Operator_activate:
    if (!cbor_encode_tag(out, 187, 0, 1))
      return false;
    if (!Core_Activate_ser(out, x->activate.op))
      return false;
    break;
  case Core_Operator_ncActivate:
    if (!cbor_encode_tag(out, 187, 1, 1))
      return false;
    if (!Core_NcActivate_ser(out, x->ncActivate.op))
      return false;
    break;
  case Core_Operator_activationReduce:
    if (!cbor_encode_tag(out, 187, 2, 1))
      return false;
    if (!Core_NcActivate_ser(out, x->activationReduce.op))
      return false;
    break;
  case Core_Operator_affineSelect:
    if (!cbor_encode_tag(out, 187, 3, 1))
      return false;
    if (!Core_AffineSelect_ser(out, x->affineSelect.op))
      return false;
    break;
  case Core_Operator_ncAffineSelect:
    if (!cbor_encode_tag(out, 187, 4, 1))
      return false;
    if (!Core_NcAffineSelect_ser(out, x->ncAffineSelect.op))
      return false;
    break;
  case Core_Operator_batchNormAggregate:
    if (!cbor_encode_tag(out, 187, 5, 1))
      return false;
    if (!Core_BatchNormAggregate_ser(out, x->batchNormAggregate.op))
      return false;
    break;
  case Core_Operator_batchNormStats:
    if (!cbor_encode_tag(out, 187, 6, 1))
      return false;
    if (!Core_BatchNormStats_ser(out, x->batchNormStats.op))
      return false;
    break;
  case Core_Operator_copy:
    if (!cbor_encode_tag(out, 187, 7, 1))
      return false;
    if (!Core_Copy_ser(out, x->copy.op))
      return false;
    break;
  case Core_Operator_ncCopy:
    if (!cbor_encode_tag(out, 187, 8, 1))
      return false;
    if (!Core_NcCopy_ser(out, x->ncCopy.op))
      return false;
    break;
  case Core_Operator_copyPredicated:
    if (!cbor_encode_tag(out, 187, 9, 1))
      return false;
    if (!Core_CopyPredicated_ser(out, x->copyPredicated.op))
      return false;
    break;
  case Core_Operator_dmaCopy:
    if (!cbor_encode_tag(out, 187, 10, 1))
      return false;
    if (!Core_DmaCopy_ser(out, x->dmaCopy.op))
      return false;
    break;
  case Core_Operator_ncDmaCopy:
    if (!cbor_encode_tag(out, 187, 11, 1))
      return false;
    if (!Core_NcDmaCopy_ser(out, x->ncDmaCopy.op))
      return false;
    break;
  case Core_Operator_dmaTranspose:
    if (!cbor_encode_tag(out, 187, 12, 1))
      return false;
    if (!Core_DmaTranspose_ser(out, x->dmaTranspose.op))
      return false;
    break;
  case Core_Operator_dropout:
    if (!cbor_encode_tag(out, 187, 13, 1))
      return false;
    if (!Core_Dropout_ser(out, x->dropout.op))
      return false;
    break;
  case Core_Operator_findIndex8:
    if (!cbor_encode_tag(out, 187, 14, 1))
      return false;
    if (!Core_FindIndex8_ser(out, x->findIndex8.op))
      return false;
    break;
  case Core_Operator_iota:
    if (!cbor_encode_tag(out, 187, 15, 1))
      return false;
    if (!Core_Iota_ser(out, x->iota.op))
      return false;
    break;
  case Core_Operator_loadMaskRegister:
    if (!cbor_encode_tag(out, 187, 16, 1))
      return false;
    if (!Core_LoadMaskRegister_ser(out, x->loadMaskRegister.op))
      return false;
    break;
  case Core_Operator_loadStationary:
    if (!cbor_encode_tag(out, 187, 17, 1))
      return false;
    if (!Core_LoadStationary_ser(out, x->loadStationary.op))
      return false;
    break;
  case Core_Operator_localGather:
    if (!cbor_encode_tag(out, 187, 18, 1))
      return false;
    if (!Core_LocalGather_ser(out, x->localGather.op))
      return false;
    break;
  case Core_Operator_ncLocalGather:
    if (!cbor_encode_tag(out, 187, 19, 1))
      return false;
    if (!Core_NcLocalGather_ser(out, x->ncLocalGather.op))
      return false;
    break;
  case Core_Operator_matMul:
    if (!cbor_encode_tag(out, 187, 20, 1))
      return false;
    if (!Core_MatMul_ser(out, x->matMul.op))
      return false;
    break;
  case Core_Operator_ncMatMul:
    if (!cbor_encode_tag(out, 187, 21, 1))
      return false;
    if (!Core_NcMatMul_ser(out, x->ncMatMul.op))
      return false;
    break;
  case Core_Operator_matchReplace8:
    if (!cbor_encode_tag(out, 187, 22, 1))
      return false;
    if (!Core_MatchReplace8_ser(out, x->matchReplace8.op))
      return false;
    break;
  case Core_Operator_matchValueLoad:
    if (!cbor_encode_tag(out, 187, 23, 1))
      return false;
    if (!Core_MatchValueLoad_ser(out, x->matchValueLoad.op))
      return false;
    break;
  case Core_Operator_max8:
    if (!cbor_encode_tag(out, 187, 24, 1))
      return false;
    if (!Core_Max8_ser(out, x->max8.op))
      return false;
    break;
  case Core_Operator_memSet:
    if (!cbor_encode_tag(out, 187, 25, 1))
      return false;
    if (!Core_MemSet_ser(out, x->memSet.op))
      return false;
    break;
  case Core_Operator_rangeSelect:
    if (!cbor_encode_tag(out, 187, 26, 1))
      return false;
    if (!Core_RangeSelect_ser(out, x->rangeSelect.op))
      return false;
    break;
  case Core_Operator_ncRangeSelect:
    if (!cbor_encode_tag(out, 187, 27, 1))
      return false;
    if (!Core_NcRangeSelect_ser(out, x->ncRangeSelect.op))
      return false;
    break;
  case Core_Operator_reciprocal:
    if (!cbor_encode_tag(out, 187, 28, 1))
      return false;
    if (!Core_Reciprocal_ser(out, x->reciprocal.op))
      return false;
    break;
  case Core_Operator_scalarTensorTensor:
    if (!cbor_encode_tag(out, 187, 29, 1))
      return false;
    if (!Core_ScalarTensorTensor_ser(out, x->scalarTensorTensor.op))
      return false;
    break;
  case Core_Operator_ncScalarTensorTensor:
    if (!cbor_encode_tag(out, 187, 30, 1))
      return false;
    if (!Core_NcScalarTensorTensor_ser(out, x->ncScalarTensorTensor.op))
      return false;
    break;
  case Core_Operator_shuffle:
    if (!cbor_encode_tag(out, 187, 31, 1))
      return false;
    if (!Core_Shuffle_ser(out, x->shuffle.op))
      return false;
    break;
  case Core_Operator_tensorReduce:
    if (!cbor_encode_tag(out, 187, 32, 1))
      return false;
    if (!Core_TensorReduce_ser(out, x->tensorReduce.op))
      return false;
    break;
  case Core_Operator_tensorScalar:
    if (!cbor_encode_tag(out, 187, 33, 1))
      return false;
    if (!Core_TensorScalar_ser(out, x->tensorScalar.op))
      return false;
    break;
  case Core_Operator_tensorTensor:
    if (!cbor_encode_tag(out, 187, 34, 1))
      return false;
    if (!Core_TensorTensor_ser(out, x->tensorTensor.op))
      return false;
    break;
  case Core_Operator_tensorTensorScan:
    if (!cbor_encode_tag(out, 187, 35, 1))
      return false;
    if (!Core_TensorTensorScan_ser(out, x->tensorTensorScan.op))
      return false;
    break;
  case Core_Operator_tensorPartitionReduce:
    if (!cbor_encode_tag(out, 187, 36, 1))
      return false;
    if (!Core_TensorPartitionReduce_ser(out, x->tensorPartitionReduce.op))
      return false;
    break;
  case Core_Operator_tensorScalarReduce:
    if (!cbor_encode_tag(out, 187, 37, 1))
      return false;
    if (!Core_TensorScalarReduce_ser(out, x->tensorScalarReduce.op))
      return false;
    break;
  case Core_Operator_transpose:
    if (!cbor_encode_tag(out, 187, 38, 1))
      return false;
    if (!Core_Transpose_ser(out, x->transpose.op))
      return false;
    break;
  case Core_Operator_selectReduce:
    if (!cbor_encode_tag(out, 187, 39, 1))
      return false;
    if (!Core_SelectReduce_ser(out, x->selectReduce.op))
      return false;
    break;
  case Core_Operator_sequenceBounds:
    if (!cbor_encode_tag(out, 187, 40, 1))
      return false;
    if (!Core_SequenceBounds_ser(out, x->sequenceBounds.op))
      return false;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_Value_ser(FILE *out, struct Core_Value *x) {
  switch (x->tag) {
  case Core_Value_var:
    if (!cbor_encode_tag(out, 101, 0, 1))
      return false;
    if (!String_ser(out, x->var.x))
      return false;
    break;
  case Core_Value_bool:
    if (!cbor_encode_tag(out, 101, 1, 1))
      return false;
    if (!cbor_encode_bool(out, x->b.value))
      return false;
    break;
  case Core_Value_int:
    if (!cbor_encode_tag(out, 101, 2, 1))
      return false;
    if (!cbor_encode_int(out, x->i.value))
      return false;
    break;
  case Core_Value_float:
    if (!cbor_encode_tag(out, 101, 3, 1))
      return false;
    if (!cbor_encode_float(out, x->f.value))
      return false;
    break;
  case Core_Value_access:
    if (!cbor_encode_tag(out, 101, 4, 1))
      return false;
    if (!Core_Access_ser(out, x->access.a))
      return false;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_Keyword_ser(FILE *out, struct Core_Keyword *x) {
  if (!cbor_encode_tag(out, 102, 0, 2))
    return false;
  if (!String_ser(out, x->name))
    return false;
  if (!Core_Value_ser(out, x->value))
    return false;
  return true;
}

bool Core_Expr_ser(FILE *out, struct Core_Expr *x) {
  switch (x->tag) {
  case Core_Expr_value:
    if (!cbor_encode_tag(out, 103, 0, 1))
      return false;
    if (!Core_Value_ser(out, x->value.v))
      return false;
    break;
  case Core_Expr_call:
    if (!cbor_encode_tag(out, 103, 1, 3))
      return false;
    if (!String_ser(out, x->call.f))
      return false;
    if (!Core_Value_List_ser(out, x->call.args))
      return false;
    if (!Core_Keyword_List_ser(out, x->call.kwargs))
      return false;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_Stmt_ser(FILE *out, struct Core_Stmt *x) {
  switch (x->tag) {
  case Core_Stmt_ret:
    if (!cbor_encode_tag(out, 104, 0, 1))
      return false;
    if (!Core_Value_ser(out, x->ret.v))
      return false;
    break;
  case Core_Stmt_assign:
    if (!cbor_encode_tag(out, 104, 1, 2))
      return false;
    if (!String_ser(out, x->assign.x))
      return false;
    if (!Core_Expr_ser(out, x->assign.e))
      return false;
    break;
  case Core_Stmt_oper:
    if (!cbor_encode_tag(out, 104, 2, 3))
      return false;
    if (!Core_Operator_ser(out, x->oper.op))
      return false;
    if (!String_Option_ser(out, x->oper.name))
      return false;
    if (!Core_Pos_ser(out, x->oper.pos))
      return false;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_Kernel_ser(FILE *out, struct Core_Kernel *x) {
  if (!cbor_encode_tag(out, 105, 0, 4))
    return false;
  if (!String_ser(out, x->name))
    return false;
  if (!Core_TensorName_List_ser(out, x->inputs))
    return false;
  if (!Core_TensorName_List_ser(out, x->outputs))
    return false;
  if (!Core_Stmt_List_ser(out, x->body))
    return false;
  return true;
}

bool Core_Index_List_ser(FILE *out, struct Core_Index_List *x) {
  u64 count = 0;
  for (struct Core_Index_List *node = x; node; node = node->next)
    count++;
  if (!cbor_encode_array_start(out, count))
    return false;
  for (struct Core_Index_List *node = x; node; node = node->next)
    if (!Core_Index_ser(out, node->index))
      return false;
  return true;
}

bool Core_APPair_List_ser(FILE *out, struct Core_APPair_List *x) {
  u64 count = 0;
  for (struct Core_APPair_List *node = x; node; node = node->next)
    count++;
  if (!cbor_encode_array_start(out, count))
    return false;
  for (struct Core_APPair_List *node = x; node; node = node->next)
    if (!Core_APPair_ser(out, node->appair))
      return false;
  return true;
}

bool Core_Dtype_Option_ser(FILE *out, enum Core_Dtype x) {
  if (!x) {
    return cbor_encode_option(out, false);
  } else {
    return cbor_encode_option(out, true) && Core_Dtype_ser(out, x);
  }
  return true;
}

bool Core_Immediate_List_ser(FILE *out, struct Core_Immediate_List *x) {
  u64 count = 0;
  for (struct Core_Immediate_List *node = x; node; node = node->next)
    count++;
  if (!cbor_encode_array_start(out, count))
    return false;
  for (struct Core_Immediate_List *node = x; node; node = node->next)
    if (!Core_Immediate_ser(out, node->immediate))
      return false;
  return true;
}

bool Core_TensorRef_Option_ser(FILE *out, struct Core_TensorRef *x) {
  if (!x) {
    return cbor_encode_option(out, false);
  } else {
    return cbor_encode_option(out, true) && Core_TensorRef_ser(out, x);
  }
  return true;
}

bool Core_TensorSubDim_Option_ser(FILE *out, enum Core_TensorSubDim x) {
  if (!x) {
    return cbor_encode_option(out, false);
  } else {
    return cbor_encode_option(out, true) && Core_TensorSubDim_ser(out, x);
  }
  return true;
}

bool Core_Operand_Option_ser(FILE *out, struct Core_Operand *x) {
  if (!x) {
    return cbor_encode_option(out, false);
  } else {
    return cbor_encode_option(out, true) && Core_Operand_ser(out, x);
  }
  return true;
}

bool Core_AluOp_Option_ser(FILE *out, enum Core_AluOp x) {
  if (!x) {
    return cbor_encode_option(out, false);
  } else {
    return cbor_encode_option(out, true) && Core_AluOp_ser(out, x);
  }
  return true;
}

bool Core_Immediate_Option_ser(FILE *out, struct Core_Immediate *x) {
  if (!x) {
    return cbor_encode_option(out, false);
  } else {
    return cbor_encode_option(out, true) && Core_Immediate_ser(out, x);
  }
  return true;
}

bool Core_Value_List_ser(FILE *out, struct Core_Value_List *x) {
  u64 count = 0;
  for (struct Core_Value_List *node = x; node; node = node->next)
    count++;
  if (!cbor_encode_array_start(out, count))
    return false;
  for (struct Core_Value_List *node = x; node; node = node->next)
    if (!Core_Value_ser(out, node->value))
      return false;
  return true;
}

bool Core_Keyword_List_ser(FILE *out, struct Core_Keyword_List *x) {
  u64 count = 0;
  for (struct Core_Keyword_List *node = x; node; node = node->next)
    count++;
  if (!cbor_encode_array_start(out, count))
    return false;
  for (struct Core_Keyword_List *node = x; node; node = node->next)
    if (!Core_Keyword_ser(out, node->keyword))
      return false;
  return true;
}

bool Core_TensorName_List_ser(FILE *out, struct Core_TensorName_List *x) {
  u64 count = 0;
  for (struct Core_TensorName_List *node = x; node; node = node->next)
    count++;
  if (!cbor_encode_array_start(out, count))
    return false;
  for (struct Core_TensorName_List *node = x; node; node = node->next)
    if (!Core_TensorName_ser(out, node->tensorname))
      return false;
  return true;
}

bool Core_Stmt_List_ser(FILE *out, struct Core_Stmt_List *x) {
  u64 count = 0;
  for (struct Core_Stmt_List *node = x; node; node = node->next)
    count++;
  if (!cbor_encode_array_start(out, count))
    return false;
  for (struct Core_Stmt_List *node = x; node; node = node->next)
    if (!Core_Stmt_ser(out, node->stmt))
      return false;
  return true;
}

bool Core_Memory_des(FILE *in, struct region *region, enum Core_Memory *x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 110)
    return false;
  (void)region;
  switch (c) {
  case 0:
    if (l != 0)
      return false;
    *x = Core_Memory_hbm;
    break;
  case 1:
    if (l != 0)
      return false;
    *x = Core_Memory_sbuf;
    break;
  case 2:
    if (l != 0)
      return false;
    *x = Core_Memory_psum;
    break;
  case 3:
    if (l != 0)
      return false;
    *x = Core_Memory_reg;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_Dtype_des(FILE *in, struct region *region, enum Core_Dtype *x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 111)
    return false;
  (void)region;
  switch (c) {
  case 0:
    if (l != 0)
      return false;
    *x = Core_Dtype_bfloat16;
    break;
  case 1:
    if (l != 0)
      return false;
    *x = Core_Dtype_float8e3;
    break;
  case 2:
    if (l != 0)
      return false;
    *x = Core_Dtype_float8e4;
    break;
  case 3:
    if (l != 0)
      return false;
    *x = Core_Dtype_float8e5;
    break;
  case 4:
    if (l != 0)
      return false;
    *x = Core_Dtype_float16;
    break;
  case 5:
    if (l != 0)
      return false;
    *x = Core_Dtype_float32;
    break;
  case 6:
    if (l != 0)
      return false;
    *x = Core_Dtype_float32r;
    break;
  case 7:
    if (l != 0)
      return false;
    *x = Core_Dtype_int8;
    break;
  case 8:
    if (l != 0)
      return false;
    *x = Core_Dtype_int16;
    break;
  case 9:
    if (l != 0)
      return false;
    *x = Core_Dtype_int64;
    break;
  case 10:
    if (l != 0)
      return false;
    *x = Core_Dtype_int32;
    break;
  case 11:
    if (l != 0)
      return false;
    *x = Core_Dtype_uint8;
    break;
  case 12:
    if (l != 0)
      return false;
    *x = Core_Dtype_uint16;
    break;
  case 13:
    if (l != 0)
      return false;
    *x = Core_Dtype_uint32;
    break;
  case 14:
    if (l != 0)
      return false;
    *x = Core_Dtype_uint64;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_Shape_des(FILE *in, struct region *region, struct Core_Shape **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 112 || c != 0 || l != 2)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Nat_des(in, region, &(*x)->parDim))
    return false;
  if (!Nat_List_des(in, region, &(*x)->freeDims))
    return false;
  return true;
}

bool Core_Address_des(FILE *in, struct region *region,
                      struct Core_Address **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 113 || c != 0 || l != 5)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Core_Memory_des(in, region, &(*x)->memory))
    return false;
  if (!Nat_des(in, region, &(*x)->parSize))
    return false;
  if (!Nat_des(in, region, &(*x)->freeSize))
    return false;
  if (!Nat_Option_des(in, region, &(*x)->parOffset))
    return false;
  if (!Nat_Option_des(in, region, &(*x)->freeOffset))
    return false;
  return true;
}

bool Core_TensorName_des(FILE *in, struct region *region,
                         struct Core_TensorName **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 114 || c != 0 || l != 7)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!String_des(in, region, &(*x)->name))
    return false;
  if (!Core_Dtype_des(in, region, &(*x)->dtype))
    return false;
  if (!Core_Shape_des(in, region, &(*x)->shape))
    return false;
  if (!Core_Address_des(in, region, &(*x)->address))
    return false;
  if (!Nat_des(in, region, &(*x)->freeElements))
    return false;
  if (!Prop_des(in, region, &(*x)->parWF))
    return false;
  if (!Prop_des(in, region, &(*x)->freeWF))
    return false;
  return true;
}

bool Core_Slice_des(FILE *in, struct region *region, struct Core_Slice **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 115 || c != 0 || l != 4)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Nat_des(in, region, &(*x)->l))
    return false;
  if (!Nat_des(in, region, &(*x)->u))
    return false;
  if (!Int_des(in, region, &(*x)->step))
    return false;
  if (!Prop_des(in, region, &(*x)->wf))
    return false;
  return true;
}

bool Core_Index_des(FILE *in, struct region *region, struct Core_Index **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 116)
    return false;
  *x = region_alloc(region, sizeof(**x));
  switch (c) {
  case 0:
    if (l != 1)
      return false;
    if (!Nat_des(in, region, &(*x)->coord.e))
      return false;
    (*x)->tag = Core_Index_coord;
    break;
  case 1:
    if (l != 1)
      return false;
    if (!Core_Slice_des(in, region, &(*x)->slice.slice))
      return false;
    (*x)->tag = Core_Index_slice;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_AccessBasic_des(FILE *in, struct region *region,
                          struct Core_AccessBasic **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 117 || c != 0 || l != 3)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Core_TensorName_des(in, region, &(*x)->tensor))
    return false;
  if (!Core_Index_List_des(in, region, &(*x)->indexes))
    return false;
  if (!Prop_des(in, region, &(*x)->lenWF))
    return false;
  return true;
}

bool Core_APPair_des(FILE *in, struct region *region, struct Core_APPair **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 118 || c != 0 || l != 2)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Int_des(in, region, &(*x)->step))
    return false;
  if (!Nat_des(in, region, &(*x)->num))
    return false;
  return true;
}

bool Core_AccessPattern_des(FILE *in, struct region *region,
                            struct Core_AccessPattern **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 119 || c != 0 || l != 5)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Core_TensorName_des(in, region, &(*x)->tensor))
    return false;
  if (!Nat_des(in, region, &(*x)->parNum))
    return false;
  if (!Core_APPair_List_des(in, region, &(*x)->freePattern))
    return false;
  if (!Nat_des(in, region, &(*x)->parOffset))
    return false;
  if (!Nat_des(in, region, &(*x)->freeOffset))
    return false;
  return true;
}

bool Core_Access_des(FILE *in, struct region *region, struct Core_Access **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 120)
    return false;
  *x = region_alloc(region, sizeof(**x));
  switch (c) {
  case 0:
    if (l != 1)
      return false;
    if (!Core_TensorName_des(in, region, &(*x)->simple.tensor))
      return false;
    (*x)->tag = Core_Access_simple;
    break;
  case 1:
    if (l != 1)
      return false;
    if (!Core_AccessBasic_des(in, region, &(*x)->basic.access))
      return false;
    (*x)->tag = Core_Access_basic;
    break;
  case 2:
    if (l != 1)
      return false;
    if (!Core_AccessPattern_des(in, region, &(*x)->pattern.access))
      return false;
    (*x)->tag = Core_Access_pattern;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_TensorHbm_des(FILE *in, struct region *region,
                        struct Core_TensorHbm **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 121 || c != 0 || l != 4)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!String_des(in, region, &(*x)->name))
    return false;
  if (!Core_Dtype_des(in, region, &(*x)->dtype))
    return false;
  if (!Nat_des(in, region, &(*x)->address))
    return false;
  if (!Core_APPair_List_des(in, region, &(*x)->dims))
    return false;
  return true;
}

bool Core_ParQuadrant_des(FILE *in, struct region *region,
                          enum Core_ParQuadrant *x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 122)
    return false;
  (void)region;
  switch (c) {
  case 0:
    if (l != 0)
      return false;
    *x = Core_ParQuadrant_par0;
    break;
  case 1:
    if (l != 0)
      return false;
    *x = Core_ParQuadrant_par32;
    break;
  case 2:
    if (l != 0)
      return false;
    *x = Core_ParQuadrant_par64;
    break;
  case 3:
    if (l != 0)
      return false;
    *x = Core_ParQuadrant_par96;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_TensorSram_des(FILE *in, struct region *region,
                         struct Core_TensorSram **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 123 || c != 0 || l != 6)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!String_des(in, region, &(*x)->name))
    return false;
  if (!Core_Dtype_des(in, region, &(*x)->dtype))
    return false;
  if (!Core_ParQuadrant_des(in, region, &(*x)->parQuadrant))
    return false;
  if (!Nat_des(in, region, &(*x)->parDim))
    return false;
  if (!Nat_des(in, region, &(*x)->freeOffset))
    return false;
  if (!Core_APPair_List_des(in, region, &(*x)->freePattern))
    return false;
  return true;
}

bool Core_TensorRef_des(FILE *in, struct region *region,
                        struct Core_TensorRef **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 124)
    return false;
  *x = region_alloc(region, sizeof(**x));
  switch (c) {
  case 0:
    if (l != 1)
      return false;
    if (!Core_Access_des(in, region, &(*x)->abstract.access))
      return false;
    (*x)->tag = Core_TensorRef_abstract;
    break;
  case 1:
    if (l != 1)
      return false;
    if (!Core_TensorSram_des(in, region, &(*x)->sbuf.view))
      return false;
    (*x)->tag = Core_TensorRef_sbuf;
    break;
  case 2:
    if (l != 1)
      return false;
    if (!Core_TensorSram_des(in, region, &(*x)->psum.view))
      return false;
    (*x)->tag = Core_TensorRef_psum;
    break;
  case 3:
    if (l != 1)
      return false;
    if (!Core_TensorHbm_des(in, region, &(*x)->hbm.view))
      return false;
    (*x)->tag = Core_TensorRef_hbm;
    break;
  case 4:
    if (l != 1)
      return false;
    if (!Nat_des(in, region, &(*x)->r.reg))
      return false;
    (*x)->tag = Core_TensorRef_register;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_Engine_des(FILE *in, struct region *region, enum Core_Engine *x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 130)
    return false;
  (void)region;
  switch (c) {
  case 0:
    if (l != 0)
      return false;
    *x = Core_Engine_unassigned;
    break;
  case 1:
    if (l != 0)
      return false;
    *x = Core_Engine_act;
    break;
  case 2:
    if (l != 0)
      return false;
    *x = Core_Engine_dma;
    break;
  case 3:
    if (l != 0)
      return false;
    *x = Core_Engine_dve;
    break;
  case 4:
    if (l != 0)
      return false;
    *x = Core_Engine_pe;
    break;
  case 5:
    if (l != 0)
      return false;
    *x = Core_Engine_pool;
    break;
  case 6:
    if (l != 0)
      return false;
    *x = Core_Engine_sp;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_Immediate_des(FILE *in, struct region *region,
                        struct Core_Immediate **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 131)
    return false;
  *x = region_alloc(region, sizeof(**x));
  switch (c) {
  case 0:
    if (l != 1)
      return false;
    if (!Nat_des(in, region, &(*x)->r.reg))
      return false;
    (*x)->tag = Core_Immediate_register;
    break;
  case 1:
    if (l != 0)
      return false;
    (*x)->tag = Core_Immediate_pointer;
    break;
  case 2:
    if (l != 1)
      return false;
    if (!Int_des(in, region, &(*x)->i.i))
      return false;
    (*x)->tag = Core_Immediate_int;
    break;
  case 3:
    if (l != 1)
      return false;
    if (!Float_des(in, region, &(*x)->f.f))
      return false;
    (*x)->tag = Core_Immediate_float;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_ActivationImm_des(FILE *in, struct region *region,
                            struct Core_ActivationImm **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 132)
    return false;
  *x = region_alloc(region, sizeof(**x));
  switch (c) {
  case 0:
    if (l != 1)
      return false;
    if (!Nat_des(in, region, &(*x)->r.reg))
      return false;
    (*x)->tag = Core_ActivationImm_register;
    break;
  case 1:
    if (l != 0)
      return false;
    (*x)->tag = Core_ActivationImm_pointer;
    break;
  case 2:
    if (l != 1)
      return false;
    if (!Float_des(in, region, &(*x)->f.f))
      return false;
    (*x)->tag = Core_ActivationImm_float;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_Operand_des(FILE *in, struct region *region,
                      struct Core_Operand **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 133)
    return false;
  *x = region_alloc(region, sizeof(**x));
  switch (c) {
  case 0:
    if (l != 1)
      return false;
    if (!Core_Immediate_des(in, region, &(*x)->imm.i))
      return false;
    (*x)->tag = Core_Operand_imm;
    break;
  case 1:
    if (l != 1)
      return false;
    if (!Core_TensorRef_des(in, region, &(*x)->tile.t))
      return false;
    (*x)->tag = Core_Operand_tile;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_DataPattern_des(FILE *in, struct region *region,
                          struct Core_DataPattern **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 134 || c != 0 || l != 2)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Nat_des(in, region, &(*x)->offset))
    return false;
  if (!Core_APPair_List_des(in, region, &(*x)->pattern))
    return false;
  return true;
}

bool Core_AluOp_des(FILE *in, struct region *region, enum Core_AluOp *x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 135)
    return false;
  (void)region;
  switch (c) {
  case 0:
    if (l != 0)
      return false;
    *x = Core_AluOp_abs;
    break;
  case 1:
    if (l != 0)
      return false;
    *x = Core_AluOp_add;
    break;
  case 2:
    if (l != 0)
      return false;
    *x = Core_AluOp_arith_shift_left;
    break;
  case 3:
    if (l != 0)
      return false;
    *x = Core_AluOp_arith_shift_right;
    break;
  case 4:
    if (l != 0)
      return false;
    *x = Core_AluOp_average;
    break;
  case 5:
    if (l != 0)
      return false;
    *x = Core_AluOp_bitwise_and;
    break;
  case 6:
    if (l != 0)
      return false;
    *x = Core_AluOp_bitwise_not;
    break;
  case 7:
    if (l != 0)
      return false;
    *x = Core_AluOp_bitwise_or;
    break;
  case 8:
    if (l != 0)
      return false;
    *x = Core_AluOp_bitwise_xor;
    break;
  case 9:
    if (l != 0)
      return false;
    *x = Core_AluOp_bypass;
    break;
  case 10:
    if (l != 0)
      return false;
    *x = Core_AluOp_divide;
    break;
  case 11:
    if (l != 0)
      return false;
    *x = Core_AluOp_is_equal;
    break;
  case 12:
    if (l != 0)
      return false;
    *x = Core_AluOp_is_ge;
    break;
  case 13:
    if (l != 0)
      return false;
    *x = Core_AluOp_is_gt;
    break;
  case 14:
    if (l != 0)
      return false;
    *x = Core_AluOp_is_le;
    break;
  case 15:
    if (l != 0)
      return false;
    *x = Core_AluOp_is_lt;
    break;
  case 16:
    if (l != 0)
      return false;
    *x = Core_AluOp_logical_and;
    break;
  case 17:
    if (l != 0)
      return false;
    *x = Core_AluOp_logical_or;
    break;
  case 18:
    if (l != 0)
      return false;
    *x = Core_AluOp_logical_shift_left;
    break;
  case 19:
    if (l != 0)
      return false;
    *x = Core_AluOp_logical_shift_right;
    break;
  case 20:
    if (l != 0)
      return false;
    *x = Core_AluOp_logical_xor;
    break;
  case 21:
    if (l != 0)
      return false;
    *x = Core_AluOp_max;
    break;
  case 22:
    if (l != 0)
      return false;
    *x = Core_AluOp_min;
    break;
  case 23:
    if (l != 0)
      return false;
    *x = Core_AluOp_mod;
    break;
  case 24:
    if (l != 0)
      return false;
    *x = Core_AluOp_mult;
    break;
  case 25:
    if (l != 0)
      return false;
    *x = Core_AluOp_not_equal;
    break;
  case 26:
    if (l != 0)
      return false;
    *x = Core_AluOp_pow;
    break;
  case 27:
    if (l != 0)
      return false;
    *x = Core_AluOp_rsqrt;
    break;
  case 28:
    if (l != 0)
      return false;
    *x = Core_AluOp_subtract;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_DropoutThresholdType_des(FILE *in, struct region *region,
                                   enum Core_DropoutThresholdType *x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 136)
    return false;
  (void)region;
  switch (c) {
  case 0:
    if (l != 0)
      return false;
    *x = Core_DropoutThresholdType_DropRate;
    break;
  case 1:
    if (l != 0)
      return false;
    *x = Core_DropoutThresholdType_KeepRate;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_AccumCmd_des(FILE *in, struct region *region, enum Core_AccumCmd *x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 137)
    return false;
  (void)region;
  switch (c) {
  case 0:
    if (l != 0)
      return false;
    *x = Core_AccumCmd_Idle;
    break;
  case 1:
    if (l != 0)
      return false;
    *x = Core_AccumCmd_Zero;
    break;
  case 2:
    if (l != 0)
      return false;
    *x = Core_AccumCmd_Accumulate;
    break;
  case 3:
    if (l != 0)
      return false;
    *x = Core_AccumCmd_ZeroAccumulate;
    break;
  case 4:
    if (l != 0)
      return false;
    *x = Core_AccumCmd_LoadAccumulate;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_ActivationFunc_des(FILE *in, struct region *region,
                             enum Core_ActivationFunc *x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 138)
    return false;
  (void)region;
  switch (c) {
  case 0:
    if (l != 0)
      return false;
    *x = Core_ActivationFunc_abs;
    break;
  case 1:
    if (l != 0)
      return false;
    *x = Core_ActivationFunc_arctan;
    break;
  case 2:
    if (l != 0)
      return false;
    *x = Core_ActivationFunc_copy;
    break;
  case 3:
    if (l != 0)
      return false;
    *x = Core_ActivationFunc_erf;
    break;
  case 4:
    if (l != 0)
      return false;
    *x = Core_ActivationFunc_erf_dx;
    break;
  case 5:
    if (l != 0)
      return false;
    *x = Core_ActivationFunc_exp;
    break;
  case 6:
    if (l != 0)
      return false;
    *x = Core_ActivationFunc_gelu;
    break;
  case 7:
    if (l != 0)
      return false;
    *x = Core_ActivationFunc_gelu_apprx_tanh;
    break;
  case 8:
    if (l != 0)
      return false;
    *x = Core_ActivationFunc_gelu_dx;
    break;
  case 9:
    if (l != 0)
      return false;
    *x = Core_ActivationFunc_log;
    break;
  case 10:
    if (l != 0)
      return false;
    *x = Core_ActivationFunc_mish;
    break;
  case 11:
    if (l != 0)
      return false;
    *x = Core_ActivationFunc_reciprocal;
    break;
  case 12:
    if (l != 0)
      return false;
    *x = Core_ActivationFunc_relu;
    break;
  case 13:
    if (l != 0)
      return false;
    *x = Core_ActivationFunc_rsqrt;
    break;
  case 14:
    if (l != 0)
      return false;
    *x = Core_ActivationFunc_sigmoid;
    break;
  case 15:
    if (l != 0)
      return false;
    *x = Core_ActivationFunc_sign;
    break;
  case 16:
    if (l != 0)
      return false;
    *x = Core_ActivationFunc_silu;
    break;
  case 17:
    if (l != 0)
      return false;
    *x = Core_ActivationFunc_silu_dx;
    break;
  case 18:
    if (l != 0)
      return false;
    *x = Core_ActivationFunc_sin;
    break;
  case 19:
    if (l != 0)
      return false;
    *x = Core_ActivationFunc_softplus;
    break;
  case 20:
    if (l != 0)
      return false;
    *x = Core_ActivationFunc_sqrt;
    break;
  case 21:
    if (l != 0)
      return false;
    *x = Core_ActivationFunc_square;
    break;
  case 22:
    if (l != 0)
      return false;
    *x = Core_ActivationFunc_tanh;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_AffineSelectCmp_des(FILE *in, struct region *region,
                              enum Core_AffineSelectCmp *x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 139)
    return false;
  (void)region;
  switch (c) {
  case 0:
    if (l != 0)
      return false;
    *x = Core_AffineSelectCmp_GreaterThan;
    break;
  case 1:
    if (l != 0)
      return false;
    *x = Core_AffineSelectCmp_GreaterThanEq;
    break;
  case 2:
    if (l != 0)
      return false;
    *x = Core_AffineSelectCmp_Eq;
    break;
  case 3:
    if (l != 0)
      return false;
    *x = Core_AffineSelectCmp_NotEq;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_DgeComputeOp_des(FILE *in, struct region *region,
                           enum Core_DgeComputeOp *x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 140)
    return false;
  (void)region;
  switch (c) {
  case 0:
    if (l != 0)
      return false;
    *x = Core_DgeComputeOp_none;
    break;
  case 1:
    if (l != 0)
      return false;
    *x = Core_DgeComputeOp_add;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_DmaBounds_des(FILE *in, struct region *region,
                        struct Core_DmaBounds **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 141)
    return false;
  *x = region_alloc(region, sizeof(**x));
  switch (c) {
  case 0:
    if (l != 0)
      return false;
    (*x)->tag = Core_DmaBounds_disable;
    break;
  case 1:
    if (l != 0)
      return false;
    (*x)->tag = Core_DmaBounds_enable;
    break;
  case 2:
    if (l != 1)
      return false;
    if (!Nat_des(in, region, &(*x)->reg.reg))
      return false;
    (*x)->tag = Core_DmaBounds_reg;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_MatmulGroupElement_des(FILE *in, struct region *region,
                                 enum Core_MatmulGroupElement *x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 142)
    return false;
  (void)region;
  switch (c) {
  case 0:
    if (l != 0)
      return false;
    *x = Core_MatmulGroupElement_first;
    break;
  case 1:
    if (l != 0)
      return false;
    *x = Core_MatmulGroupElement_middle;
    break;
  case 2:
    if (l != 0)
      return false;
    *x = Core_MatmulGroupElement_last;
    break;
  case 3:
    if (l != 0)
      return false;
    *x = Core_MatmulGroupElement_whole;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_IndexMissBehavior_des(FILE *in, struct region *region,
                                struct Core_IndexMissBehavior **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 143)
    return false;
  *x = region_alloc(region, sizeof(**x));
  switch (c) {
  case 0:
    if (l != 1)
      return false;
    if (!Core_Immediate_des(in, region, &(*x)->imm.value))
      return false;
    (*x)->tag = Core_IndexMissBehavior_imm;
    break;
  case 1:
    if (l != 0)
      return false;
    (*x)->tag = Core_IndexMissBehavior_skip;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_TensorScalarReverseOps_des(FILE *in, struct region *region,
                                     enum Core_TensorScalarReverseOps *x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 144)
    return false;
  (void)region;
  switch (c) {
  case 0:
    if (l != 0)
      return false;
    *x = Core_TensorScalarReverseOps_none;
    break;
  case 1:
    if (l != 0)
      return false;
    *x = Core_TensorScalarReverseOps_first;
    break;
  case 2:
    if (l != 0)
      return false;
    *x = Core_TensorScalarReverseOps_second;
    break;
  case 3:
    if (l != 0)
      return false;
    *x = Core_TensorScalarReverseOps_both;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_TensorSubDim_des(FILE *in, struct region *region,
                           enum Core_TensorSubDim *x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 145)
    return false;
  (void)region;
  switch (c) {
  case 0:
    if (l != 0)
      return false;
    *x = Core_TensorSubDim_X;
    break;
  case 1:
    if (l != 0)
      return false;
    *x = Core_TensorSubDim_XY;
    break;
  case 2:
    if (l != 0)
      return false;
    *x = Core_TensorSubDim_XYZ;
    break;
  case 3:
    if (l != 0)
      return false;
    *x = Core_TensorSubDim_XYZW;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_TransposeOps_des(FILE *in, struct region *region,
                           enum Core_TransposeOps *x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 146)
    return false;
  (void)region;
  switch (c) {
  case 0:
    if (l != 0)
      return false;
    *x = Core_TransposeOps_None;
    break;
  case 1:
    if (l != 0)
      return false;
    *x = Core_TransposeOps_WZXY;
    break;
  case 2:
    if (l != 0)
      return false;
    *x = Core_TransposeOps_WXZY;
    break;
  case 3:
    if (l != 0)
      return false;
    *x = Core_TransposeOps_WYXZ;
    break;
  case 4:
    if (l != 0)
      return false;
    *x = Core_TransposeOps_ZWYX;
    break;
  case 5:
    if (l != 0)
      return false;
    *x = Core_TransposeOps_ZYWX;
    break;
  case 6:
    if (l != 0)
      return false;
    *x = Core_TransposeOps_ZYXW;
    break;
  case 7:
    if (l != 0)
      return false;
    *x = Core_TransposeOps_YXWZ;
    break;
  case 8:
    if (l != 0)
      return false;
    *x = Core_TransposeOps_YXZW;
    break;
  case 9:
    if (l != 0)
      return false;
    *x = Core_TransposeOps_YWZX;
    break;
  case 10:
    if (l != 0)
      return false;
    *x = Core_TransposeOps_XWZY;
    break;
  case 11:
    if (l != 0)
      return false;
    *x = Core_TransposeOps_XZYW;
    break;
  case 12:
    if (l != 0)
      return false;
    *x = Core_TransposeOps_XYZW;
    break;
  case 13:
    if (l != 0)
      return false;
    *x = Core_TransposeOps_XYWZ;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_Dropout_des(FILE *in, struct region *region,
                      struct Core_Dropout **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 147 || c != 0 || l != 5)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Core_TensorRef_des(in, region, &(*x)->dst))
    return false;
  if (!Core_TensorRef_des(in, region, &(*x)->src))
    return false;
  if (!Core_DropoutThresholdType_des(in, region, &(*x)->thresholdType))
    return false;
  if (!Core_Operand_des(in, region, &(*x)->threshold))
    return false;
  if (!Core_Dtype_Option_des(in, region, &(*x)->dtype))
    return false;
  return true;
}

bool Core_Activate_des(FILE *in, struct region *region,
                       struct Core_Activate **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 148 || c != 0 || l != 7)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Core_TensorRef_des(in, region, &(*x)->dst))
    return false;
  if (!Core_TensorRef_des(in, region, &(*x)->src))
    return false;
  if (!Core_AccumCmd_des(in, region, &(*x)->accumulatorCmd))
    return false;
  if (!Core_ActivationFunc_des(in, region, &(*x)->activationFunc))
    return false;
  if (!Core_Immediate_des(in, region, &(*x)->scale))
    return false;
  if (!Core_Immediate_des(in, region, &(*x)->bias))
    return false;
  if (!Core_Immediate_des(in, region, &(*x)->imm))
    return false;
  return true;
}

bool Core_AffineSelect_des(FILE *in, struct region *region,
                           struct Core_AffineSelect **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 150 || c != 0 || l != 5)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Core_TensorRef_des(in, region, &(*x)->dst))
    return false;
  if (!Core_TensorRef_des(in, region, &(*x)->src))
    return false;
  if (!Core_AffineSelectCmp_des(in, region, &(*x)->fillMode))
    return false;
  if (!Nat_des(in, region, &(*x)->fillReg))
    return false;
  if (!Core_DataPattern_des(in, region, &(*x)->maskPattern))
    return false;
  return true;
}

bool Core_DmaCopy_des(FILE *in, struct region *region,
                      struct Core_DmaCopy **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 152 || c != 0 || l != 5)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Core_TensorRef_des(in, region, &(*x)->dst))
    return false;
  if (!Core_TensorRef_des(in, region, &(*x)->src))
    return false;
  if (!Core_DgeComputeOp_des(in, region, &(*x)->compute_op))
    return false;
  if (!Core_DmaBounds_des(in, region, &(*x)->dstBoundsCheck))
    return false;
  if (!Core_DmaBounds_des(in, region, &(*x)->srcBoundsCheck))
    return false;
  return true;
}

bool Core_DmaTranspose_des(FILE *in, struct region *region,
                           struct Core_DmaTranspose **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 154 || c != 0 || l != 4)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Core_TensorRef_des(in, region, &(*x)->dst))
    return false;
  if (!Core_TensorRef_des(in, region, &(*x)->src))
    return false;
  if (!Core_TransposeOps_des(in, region, &(*x)->axes))
    return false;
  if (!Core_Dtype_Option_des(in, region, &(*x)->dtype))
    return false;
  return true;
}

bool Core_Transpose_des(FILE *in, struct region *region,
                        struct Core_Transpose **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 155 || c != 0 || l != 4)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Core_TensorRef_des(in, region, &(*x)->dst))
    return false;
  if (!Core_TensorRef_des(in, region, &(*x)->src))
    return false;
  if (!Core_Dtype_Option_des(in, region, &(*x)->dtype))
    return false;
  if (!Core_Engine_des(in, region, &(*x)->engine))
    return false;
  return true;
}

bool Core_LoadMaskRegister_des(FILE *in, struct region *region,
                               struct Core_LoadMaskRegister **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 156 || c != 0 || l != 1)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Nat_des(in, region, &(*x)->regNum))
    return false;
  return true;
}

bool Core_Shuffle_des(FILE *in, struct region *region,
                      struct Core_Shuffle **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 157 || c != 0 || l != 4)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Core_TensorRef_des(in, region, &(*x)->dst))
    return false;
  if (!Core_TensorRef_des(in, region, &(*x)->src))
    return false;
  if (!Core_Immediate_List_des(in, region, &(*x)->shuffleMask))
    return false;
  if (!Core_Dtype_Option_des(in, region, &(*x)->dtype))
    return false;
  return true;
}

bool Core_MemSet_des(FILE *in, struct region *region, struct Core_MemSet **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 158 || c != 0 || l != 4)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Core_TensorRef_des(in, region, &(*x)->dst))
    return false;
  if (!Core_Immediate_des(in, region, &(*x)->value))
    return false;
  if (!Core_Dtype_des(in, region, &(*x)->dtype))
    return false;
  if (!Core_Engine_des(in, region, &(*x)->engine))
    return false;
  return true;
}

bool Core_Iota_des(FILE *in, struct region *region, struct Core_Iota **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 159 || c != 0 || l != 3)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Core_TensorRef_des(in, region, &(*x)->dst))
    return false;
  if (!Core_DataPattern_des(in, region, &(*x)->pattern))
    return false;
  if (!Core_Dtype_Option_des(in, region, &(*x)->dtype))
    return false;
  return true;
}

bool Core_LoadStationary_des(FILE *in, struct region *region,
                             struct Core_LoadStationary **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 160 || c != 0 || l != 2)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Core_TensorRef_des(in, region, &(*x)->src))
    return false;
  if (!Bool_des(in, region, &(*x)->isTranspose))
    return false;
  return true;
}

bool Core_MatMul_des(FILE *in, struct region *region, struct Core_MatMul **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 161 || c != 0 || l != 3)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Core_TensorRef_des(in, region, &(*x)->dst))
    return false;
  if (!Core_TensorRef_des(in, region, &(*x)->moving))
    return false;
  if (!Core_MatmulGroupElement_des(in, region, &(*x)->psumAccumulateFlag))
    return false;
  return true;
}

bool Core_LocalGather_des(FILE *in, struct region *region,
                          struct Core_LocalGather **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 162 || c != 0 || l != 4)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Core_TensorRef_des(in, region, &(*x)->dst))
    return false;
  if (!Core_TensorRef_des(in, region, &(*x)->src))
    return false;
  if (!Core_IndexMissBehavior_des(in, region, &(*x)->indexMissBehavior))
    return false;
  if (!Bool_des(in, region, &(*x)->freePoolBuffer))
    return false;
  return true;
}

bool Core_RangeSelect_des(FILE *in, struct region *region,
                          struct Core_RangeSelect **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 164 || c != 0 || l != 10)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Core_TensorRef_des(in, region, &(*x)->dst))
    return false;
  if (!Core_TensorRef_des(in, region, &(*x)->src))
    return false;
  if (!Core_AccumCmd_des(in, region, &(*x)->reduceCommand))
    return false;
  if (!Core_AluOp_des(in, region, &(*x)->reduceOp))
    return false;
  if (!Float_des(in, region, &(*x)->base))
    return false;
  if (!Float_des(in, region, &(*x)->fillValue))
    return false;
  if (!Core_AluOp_des(in, region, &(*x)->compOp0))
    return false;
  if (!Core_AluOp_des(in, region, &(*x)->compOp1))
    return false;
  if (!Core_Immediate_des(in, region, &(*x)->bound0))
    return false;
  if (!Core_Immediate_des(in, region, &(*x)->bound1))
    return false;
  return true;
}

bool Core_ScalarTensorTensor_des(FILE *in, struct region *region,
                                 struct Core_ScalarTensorTensor **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 166 || c != 0 || l != 8)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Core_TensorRef_des(in, region, &(*x)->dst))
    return false;
  if (!Core_TensorRef_des(in, region, &(*x)->src0))
    return false;
  if (!Core_TensorRef_des(in, region, &(*x)->src1))
    return false;
  if (!Core_AluOp_des(in, region, &(*x)->op0))
    return false;
  if (!Core_AluOp_des(in, region, &(*x)->op1))
    return false;
  if (!Core_TensorScalarReverseOps_des(in, region, &(*x)->reverseOperands))
    return false;
  if (!Core_Immediate_des(in, region, &(*x)->imm0))
    return false;
  if (!Core_AccumCmd_des(in, region, &(*x)->accumulatorCmd))
    return false;
  return true;
}

bool Core_CopyPredicated_des(FILE *in, struct region *region,
                             struct Core_CopyPredicated **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 168 || c != 0 || l != 5)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Core_TensorRef_des(in, region, &(*x)->dst))
    return false;
  if (!Core_TensorRef_des(in, region, &(*x)->src))
    return false;
  if (!Core_TensorRef_des(in, region, &(*x)->predicate))
    return false;
  if (!Core_Dtype_Option_des(in, region, &(*x)->dtype))
    return false;
  if (!Bool_des(in, region, &(*x)->reversePred))
    return false;
  return true;
}

bool Core_TensorTensorScan_des(FILE *in, struct region *region,
                               struct Core_TensorTensorScan **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 169 || c != 0 || l != 9)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Core_TensorRef_des(in, region, &(*x)->dst))
    return false;
  if (!Core_TensorRef_des(in, region, &(*x)->src0))
    return false;
  if (!Core_TensorRef_des(in, region, &(*x)->src1))
    return false;
  if (!Core_AluOp_des(in, region, &(*x)->op0))
    return false;
  if (!Core_AluOp_des(in, region, &(*x)->op1))
    return false;
  if (!Core_TensorScalarReverseOps_des(in, region, &(*x)->reverseOperands))
    return false;
  if (!Core_Operand_des(in, region, &(*x)->imm0))
    return false;
  if (!Core_AccumCmd_des(in, region, &(*x)->accumulatorCmd))
    return false;
  if (!Core_Dtype_Option_des(in, region, &(*x)->dtype))
    return false;
  return true;
}

bool Core_MatchValueLoad_des(FILE *in, struct region *region,
                             struct Core_MatchValueLoad **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 170 || c != 0 || l != 1)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Core_TensorRef_des(in, region, &(*x)->src))
    return false;
  return true;
}

bool Core_FindIndex8_des(FILE *in, struct region *region,
                         struct Core_FindIndex8 **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 171 || c != 0 || l != 4)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Core_TensorRef_des(in, region, &(*x)->dst))
    return false;
  if (!Core_TensorRef_des(in, region, &(*x)->src))
    return false;
  if (!Core_TensorRef_des(in, region, &(*x)->vals))
    return false;
  if (!Core_Dtype_Option_des(in, region, &(*x)->dtype))
    return false;
  return true;
}

bool Core_MatchReplace8_des(FILE *in, struct region *region,
                            struct Core_MatchReplace8 **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 172 || c != 0 || l != 6)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Core_TensorRef_des(in, region, &(*x)->dst))
    return false;
  if (!Core_TensorRef_des(in, region, &(*x)->src))
    return false;
  if (!Core_TensorRef_des(in, region, &(*x)->vals))
    return false;
  if (!Core_Immediate_des(in, region, &(*x)->replaceValue))
    return false;
  if (!Core_TensorRef_Option_des(in, region, &(*x)->dstIdx))
    return false;
  if (!Core_Dtype_Option_des(in, region, &(*x)->dtype))
    return false;
  return true;
}

bool Core_Max8_des(FILE *in, struct region *region, struct Core_Max8 **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 173 || c != 0 || l != 3)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Core_TensorRef_des(in, region, &(*x)->dst))
    return false;
  if (!Core_TensorRef_des(in, region, &(*x)->src))
    return false;
  if (!Core_Dtype_Option_des(in, region, &(*x)->dtype))
    return false;
  return true;
}

bool Core_BatchNormAggregate_des(FILE *in, struct region *region,
                                 struct Core_BatchNormAggregate **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 174 || c != 0 || l != 3)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Core_TensorRef_des(in, region, &(*x)->dst))
    return false;
  if (!Core_TensorRef_des(in, region, &(*x)->src))
    return false;
  if (!Core_Dtype_Option_des(in, region, &(*x)->dtype))
    return false;
  return true;
}

bool Core_BatchNormStats_des(FILE *in, struct region *region,
                             struct Core_BatchNormStats **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 175 || c != 0 || l != 3)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Core_TensorRef_des(in, region, &(*x)->dst))
    return false;
  if (!Core_TensorRef_des(in, region, &(*x)->src))
    return false;
  if (!Core_Dtype_Option_des(in, region, &(*x)->dtype))
    return false;
  return true;
}

bool Core_Reciprocal_des(FILE *in, struct region *region,
                         struct Core_Reciprocal **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 176 || c != 0 || l != 3)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Core_TensorRef_des(in, region, &(*x)->dst))
    return false;
  if (!Core_TensorRef_des(in, region, &(*x)->src))
    return false;
  if (!Core_Dtype_Option_des(in, region, &(*x)->dtype))
    return false;
  return true;
}

bool Core_Copy_des(FILE *in, struct region *region, struct Core_Copy **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 177 || c != 0 || l != 3)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Core_TensorRef_des(in, region, &(*x)->dst))
    return false;
  if (!Core_TensorRef_des(in, region, &(*x)->src))
    return false;
  if (!Core_TensorSubDim_Option_des(in, region, &(*x)->opDim))
    return false;
  return true;
}

bool Core_TensorReduce_des(FILE *in, struct region *region,
                           struct Core_TensorReduce **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 179 || c != 0 || l != 7)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Core_TensorRef_des(in, region, &(*x)->dst))
    return false;
  if (!Core_TensorRef_des(in, region, &(*x)->src))
    return false;
  if (!Core_AluOp_des(in, region, &(*x)->op))
    return false;
  if (!Core_TensorSubDim_des(in, region, &(*x)->opDim))
    return false;
  if (!Bool_des(in, region, &(*x)->negated))
    return false;
  if (!Core_Dtype_Option_des(in, region, &(*x)->dtype))
    return false;
  if (!Bool_des(in, region, &(*x)->keepdims))
    return false;
  return true;
}

bool Core_TensorScalar_des(FILE *in, struct region *region,
                           struct Core_TensorScalar **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 180 || c != 0 || l != 9)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Core_TensorRef_des(in, region, &(*x)->dst))
    return false;
  if (!Core_TensorRef_des(in, region, &(*x)->src))
    return false;
  if (!Core_Operand_des(in, region, &(*x)->imm0))
    return false;
  if (!Core_AluOp_des(in, region, &(*x)->op0))
    return false;
  if (!Core_Operand_Option_des(in, region, &(*x)->imm1))
    return false;
  if (!Core_AluOp_Option_des(in, region, &(*x)->op1))
    return false;
  if (!Core_TensorScalarReverseOps_des(in, region, &(*x)->reverse))
    return false;
  if (!Core_Engine_des(in, region, &(*x)->engine))
    return false;
  if (!Core_Dtype_Option_des(in, region, &(*x)->dtype))
    return false;
  return true;
}

bool Core_TensorTensor_des(FILE *in, struct region *region,
                           struct Core_TensorTensor **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 182 || c != 0 || l != 6)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Core_TensorRef_des(in, region, &(*x)->dst))
    return false;
  if (!Core_TensorRef_des(in, region, &(*x)->src0))
    return false;
  if (!Core_TensorRef_des(in, region, &(*x)->src1))
    return false;
  if (!Core_AluOp_des(in, region, &(*x)->op))
    return false;
  if (!Core_Dtype_Option_des(in, region, &(*x)->dtype))
    return false;
  if (!Core_Engine_des(in, region, &(*x)->engine))
    return false;
  return true;
}

bool Core_NcMatMul_des(FILE *in, struct region *region,
                       struct Core_NcMatMul **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 183 || c != 0 || l != 8)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Core_TensorRef_des(in, region, &(*x)->dst))
    return false;
  if (!Core_TensorRef_des(in, region, &(*x)->stationary))
    return false;
  if (!Core_TensorRef_des(in, region, &(*x)->moving))
    return false;
  if (!Bool_des(in, region, &(*x)->isStationaryOneZero))
    return false;
  if (!Bool_des(in, region, &(*x)->isMovingZero))
    return false;
  if (!Bool_des(in, region, &(*x)->isTranspose))
    return false;
  if (!Nat_List_des(in, region, &(*x)->tilePosition))
    return false;
  if (!Nat_List_des(in, region, &(*x)->tileSize))
    return false;
  return true;
}

bool Core_TensorScalarReduce_des(FILE *in, struct region *region,
                                 struct Core_TensorScalarReduce **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 181 || c != 0 || l != 8)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Core_TensorRef_des(in, region, &(*x)->dst))
    return false;
  if (!Core_TensorRef_des(in, region, &(*x)->src))
    return false;
  if (!Core_Operand_des(in, region, &(*x)->operand0))
    return false;
  if (!Core_AluOp_des(in, region, &(*x)->op0))
    return false;
  if (!Bool_des(in, region, &(*x)->reverse0))
    return false;
  if (!Core_Dtype_Option_des(in, region, &(*x)->dtype))
    return false;
  if (!Core_AluOp_Option_des(in, region, &(*x)->reduceOp))
    return false;
  if (!Core_TensorRef_des(in, region, &(*x)->reduceRes))
    return false;
  return true;
}

bool Core_TensorPartitionReduce_des(FILE *in, struct region *region,
                                    struct Core_TensorPartitionReduce **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 184 || c != 0 || l != 4)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Core_TensorRef_des(in, region, &(*x)->dst))
    return false;
  if (!Core_AluOp_des(in, region, &(*x)->op))
    return false;
  if (!Core_TensorRef_des(in, region, &(*x)->data))
    return false;
  if (!Core_Dtype_Option_des(in, region, &(*x)->dtype))
    return false;
  return true;
}

bool Core_NcActivate_des(FILE *in, struct region *region,
                         struct Core_NcActivate **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 149 || c != 0 || l != 9)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Core_TensorRef_des(in, region, &(*x)->dst))
    return false;
  if (!Core_TensorRef_des(in, region, &(*x)->src))
    return false;
  if (!Core_AccumCmd_des(in, region, &(*x)->accumulatorCmd))
    return false;
  if (!Core_ActivationFunc_des(in, region, &(*x)->activationFunc))
    return false;
  if (!Core_Immediate_des(in, region, &(*x)->scale))
    return false;
  if (!Core_Immediate_des(in, region, &(*x)->bias))
    return false;
  if (!Core_AluOp_Option_des(in, region, &(*x)->reduceOp))
    return false;
  if (!Core_TensorRef_Option_des(in, region, &(*x)->reduceRes))
    return false;
  if (!Core_Dtype_Option_des(in, region, &(*x)->dtype))
    return false;
  return true;
}

bool Core_NcAffineSelect_des(FILE *in, struct region *region,
                             struct Core_NcAffineSelect **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 151 || c != 0 || l != 6)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Core_TensorRef_des(in, region, &(*x)->dst))
    return false;
  if (!Core_DataPattern_des(in, region, &(*x)->pred))
    return false;
  if (!Core_TensorRef_des(in, region, &(*x)->onTrueTile))
    return false;
  if (!Core_Immediate_des(in, region, &(*x)->onFalseValue))
    return false;
  if (!Core_Dtype_Option_des(in, region, &(*x)->dtype))
    return false;
  if (!Core_AluOp_des(in, region, &(*x)->cmpOp))
    return false;
  return true;
}

bool Core_NcDmaCopy_des(FILE *in, struct region *region,
                        struct Core_NcDmaCopy **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 153 || c != 0 || l != 5)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Core_TensorRef_des(in, region, &(*x)->dst))
    return false;
  if (!Core_TensorRef_des(in, region, &(*x)->src))
    return false;
  if (!Core_DgeComputeOp_des(in, region, &(*x)->compute_op))
    return false;
  if (!Core_DmaBounds_des(in, region, &(*x)->oobMode))
    return false;
  if (!Nat_des(in, region, &(*x)->dgeMode))
    return false;
  return true;
}

bool Core_NcLocalGather_des(FILE *in, struct region *region,
                            struct Core_NcLocalGather **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 163 || c != 0 || l != 5)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Core_TensorRef_des(in, region, &(*x)->dst))
    return false;
  if (!Core_TensorRef_des(in, region, &(*x)->src))
    return false;
  if (!Core_TensorRef_des(in, region, &(*x)->index))
    return false;
  if (!Core_Immediate_des(in, region, &(*x)->numElemPerIdx))
    return false;
  if (!Core_Immediate_Option_des(in, region, &(*x)->numValidIndicies))
    return false;
  return true;
}

bool Core_NcRangeSelect_des(FILE *in, struct region *region,
                            struct Core_NcRangeSelect **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 165 || c != 0 || l != 12)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Core_TensorRef_des(in, region, &(*x)->dst))
    return false;
  if (!Core_AccumCmd_des(in, region, &(*x)->reduceCommand))
    return false;
  if (!Core_TensorRef_Option_des(in, region, &(*x)->reduceRes))
    return false;
  if (!Core_AluOp_Option_des(in, region, &(*x)->reduceOp))
    return false;
  if (!Core_AluOp_des(in, region, &(*x)->compOp0))
    return false;
  if (!Core_AluOp_des(in, region, &(*x)->compOp1))
    return false;
  if (!Core_TensorRef_des(in, region, &(*x)->bound0))
    return false;
  if (!Core_TensorRef_des(in, region, &(*x)->bound1))
    return false;
  if (!Core_Immediate_des(in, region, &(*x)->rangeStart))
    return false;
  if (!Core_TensorRef_des(in, region, &(*x)->onTrueTile))
    return false;
  if (!Core_Immediate_des(in, region, &(*x)->onFalseValue))
    return false;
  if (!Core_Dtype_Option_des(in, region, &(*x)->dtype))
    return false;
  return true;
}

bool Core_NcScalarTensorTensor_des(FILE *in, struct region *region,
                                   struct Core_NcScalarTensorTensor **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 167 || c != 0 || l != 8)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Core_TensorRef_des(in, region, &(*x)->dst))
    return false;
  if (!Core_TensorRef_des(in, region, &(*x)->data))
    return false;
  if (!Core_Operand_des(in, region, &(*x)->src0))
    return false;
  if (!Core_Operand_des(in, region, &(*x)->src1))
    return false;
  if (!Core_AluOp_des(in, region, &(*x)->op0))
    return false;
  if (!Core_AluOp_des(in, region, &(*x)->op1))
    return false;
  if (!Core_TensorScalarReverseOps_des(in, region, &(*x)->reverseOperands))
    return false;
  if (!Core_Dtype_Option_des(in, region, &(*x)->dtype))
    return false;
  return true;
}

bool Core_NcCopy_des(FILE *in, struct region *region, struct Core_NcCopy **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 178 || c != 0 || l != 4)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Core_TensorRef_des(in, region, &(*x)->dst))
    return false;
  if (!Core_TensorRef_des(in, region, &(*x)->src))
    return false;
  if (!Core_Dtype_Option_des(in, region, &(*x)->dtype))
    return false;
  if (!Core_Engine_des(in, region, &(*x)->engine))
    return false;
  return true;
}

bool Core_SelectReduce_des(FILE *in, struct region *region,
                           struct Core_SelectReduce **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 185 || c != 0 || l != 9)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Core_TensorRef_des(in, region, &(*x)->dst))
    return false;
  if (!Core_TensorRef_des(in, region, &(*x)->predicate))
    return false;
  if (!Core_TensorRef_des(in, region, &(*x)->onTrue))
    return false;
  if (!Core_Operand_des(in, region, &(*x)->onFalse))
    return false;
  if (!Core_TensorRef_Option_des(in, region, &(*x)->reduceRes))
    return false;
  if (!Core_AccumCmd_des(in, region, &(*x)->reduceCmd))
    return false;
  if (!Core_AluOp_des(in, region, &(*x)->reduceOp))
    return false;
  if (!Bool_des(in, region, &(*x)->reversePred))
    return false;
  if (!Core_Dtype_Option_des(in, region, &(*x)->dtype))
    return false;
  return true;
}

bool Core_SequenceBounds_des(FILE *in, struct region *region,
                             struct Core_SequenceBounds **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 186 || c != 0 || l != 3)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Core_TensorRef_des(in, region, &(*x)->dst))
    return false;
  if (!Core_TensorRef_des(in, region, &(*x)->segmentIds))
    return false;
  if (!Core_Dtype_Option_des(in, region, &(*x)->dtype))
    return false;
  return true;
}

bool Core_Operator_des(FILE *in, struct region *region,
                       struct Core_Operator **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 187)
    return false;
  *x = region_alloc(region, sizeof(**x));
  switch (c) {
  case 0:
    if (l != 1)
      return false;
    if (!Core_Activate_des(in, region, &(*x)->activate.op))
      return false;
    (*x)->tag = Core_Operator_activate;
    break;
  case 1:
    if (l != 1)
      return false;
    if (!Core_NcActivate_des(in, region, &(*x)->ncActivate.op))
      return false;
    (*x)->tag = Core_Operator_ncActivate;
    break;
  case 2:
    if (l != 1)
      return false;
    if (!Core_NcActivate_des(in, region, &(*x)->activationReduce.op))
      return false;
    (*x)->tag = Core_Operator_activationReduce;
    break;
  case 3:
    if (l != 1)
      return false;
    if (!Core_AffineSelect_des(in, region, &(*x)->affineSelect.op))
      return false;
    (*x)->tag = Core_Operator_affineSelect;
    break;
  case 4:
    if (l != 1)
      return false;
    if (!Core_NcAffineSelect_des(in, region, &(*x)->ncAffineSelect.op))
      return false;
    (*x)->tag = Core_Operator_ncAffineSelect;
    break;
  case 5:
    if (l != 1)
      return false;
    if (!Core_BatchNormAggregate_des(in, region, &(*x)->batchNormAggregate.op))
      return false;
    (*x)->tag = Core_Operator_batchNormAggregate;
    break;
  case 6:
    if (l != 1)
      return false;
    if (!Core_BatchNormStats_des(in, region, &(*x)->batchNormStats.op))
      return false;
    (*x)->tag = Core_Operator_batchNormStats;
    break;
  case 7:
    if (l != 1)
      return false;
    if (!Core_Copy_des(in, region, &(*x)->copy.op))
      return false;
    (*x)->tag = Core_Operator_copy;
    break;
  case 8:
    if (l != 1)
      return false;
    if (!Core_NcCopy_des(in, region, &(*x)->ncCopy.op))
      return false;
    (*x)->tag = Core_Operator_ncCopy;
    break;
  case 9:
    if (l != 1)
      return false;
    if (!Core_CopyPredicated_des(in, region, &(*x)->copyPredicated.op))
      return false;
    (*x)->tag = Core_Operator_copyPredicated;
    break;
  case 10:
    if (l != 1)
      return false;
    if (!Core_DmaCopy_des(in, region, &(*x)->dmaCopy.op))
      return false;
    (*x)->tag = Core_Operator_dmaCopy;
    break;
  case 11:
    if (l != 1)
      return false;
    if (!Core_NcDmaCopy_des(in, region, &(*x)->ncDmaCopy.op))
      return false;
    (*x)->tag = Core_Operator_ncDmaCopy;
    break;
  case 12:
    if (l != 1)
      return false;
    if (!Core_DmaTranspose_des(in, region, &(*x)->dmaTranspose.op))
      return false;
    (*x)->tag = Core_Operator_dmaTranspose;
    break;
  case 13:
    if (l != 1)
      return false;
    if (!Core_Dropout_des(in, region, &(*x)->dropout.op))
      return false;
    (*x)->tag = Core_Operator_dropout;
    break;
  case 14:
    if (l != 1)
      return false;
    if (!Core_FindIndex8_des(in, region, &(*x)->findIndex8.op))
      return false;
    (*x)->tag = Core_Operator_findIndex8;
    break;
  case 15:
    if (l != 1)
      return false;
    if (!Core_Iota_des(in, region, &(*x)->iota.op))
      return false;
    (*x)->tag = Core_Operator_iota;
    break;
  case 16:
    if (l != 1)
      return false;
    if (!Core_LoadMaskRegister_des(in, region, &(*x)->loadMaskRegister.op))
      return false;
    (*x)->tag = Core_Operator_loadMaskRegister;
    break;
  case 17:
    if (l != 1)
      return false;
    if (!Core_LoadStationary_des(in, region, &(*x)->loadStationary.op))
      return false;
    (*x)->tag = Core_Operator_loadStationary;
    break;
  case 18:
    if (l != 1)
      return false;
    if (!Core_LocalGather_des(in, region, &(*x)->localGather.op))
      return false;
    (*x)->tag = Core_Operator_localGather;
    break;
  case 19:
    if (l != 1)
      return false;
    if (!Core_NcLocalGather_des(in, region, &(*x)->ncLocalGather.op))
      return false;
    (*x)->tag = Core_Operator_ncLocalGather;
    break;
  case 20:
    if (l != 1)
      return false;
    if (!Core_MatMul_des(in, region, &(*x)->matMul.op))
      return false;
    (*x)->tag = Core_Operator_matMul;
    break;
  case 21:
    if (l != 1)
      return false;
    if (!Core_NcMatMul_des(in, region, &(*x)->ncMatMul.op))
      return false;
    (*x)->tag = Core_Operator_ncMatMul;
    break;
  case 22:
    if (l != 1)
      return false;
    if (!Core_MatchReplace8_des(in, region, &(*x)->matchReplace8.op))
      return false;
    (*x)->tag = Core_Operator_matchReplace8;
    break;
  case 23:
    if (l != 1)
      return false;
    if (!Core_MatchValueLoad_des(in, region, &(*x)->matchValueLoad.op))
      return false;
    (*x)->tag = Core_Operator_matchValueLoad;
    break;
  case 24:
    if (l != 1)
      return false;
    if (!Core_Max8_des(in, region, &(*x)->max8.op))
      return false;
    (*x)->tag = Core_Operator_max8;
    break;
  case 25:
    if (l != 1)
      return false;
    if (!Core_MemSet_des(in, region, &(*x)->memSet.op))
      return false;
    (*x)->tag = Core_Operator_memSet;
    break;
  case 26:
    if (l != 1)
      return false;
    if (!Core_RangeSelect_des(in, region, &(*x)->rangeSelect.op))
      return false;
    (*x)->tag = Core_Operator_rangeSelect;
    break;
  case 27:
    if (l != 1)
      return false;
    if (!Core_NcRangeSelect_des(in, region, &(*x)->ncRangeSelect.op))
      return false;
    (*x)->tag = Core_Operator_ncRangeSelect;
    break;
  case 28:
    if (l != 1)
      return false;
    if (!Core_Reciprocal_des(in, region, &(*x)->reciprocal.op))
      return false;
    (*x)->tag = Core_Operator_reciprocal;
    break;
  case 29:
    if (l != 1)
      return false;
    if (!Core_ScalarTensorTensor_des(in, region, &(*x)->scalarTensorTensor.op))
      return false;
    (*x)->tag = Core_Operator_scalarTensorTensor;
    break;
  case 30:
    if (l != 1)
      return false;
    if (!Core_NcScalarTensorTensor_des(in, region,
                                       &(*x)->ncScalarTensorTensor.op))
      return false;
    (*x)->tag = Core_Operator_ncScalarTensorTensor;
    break;
  case 31:
    if (l != 1)
      return false;
    if (!Core_Shuffle_des(in, region, &(*x)->shuffle.op))
      return false;
    (*x)->tag = Core_Operator_shuffle;
    break;
  case 32:
    if (l != 1)
      return false;
    if (!Core_TensorReduce_des(in, region, &(*x)->tensorReduce.op))
      return false;
    (*x)->tag = Core_Operator_tensorReduce;
    break;
  case 33:
    if (l != 1)
      return false;
    if (!Core_TensorScalar_des(in, region, &(*x)->tensorScalar.op))
      return false;
    (*x)->tag = Core_Operator_tensorScalar;
    break;
  case 34:
    if (l != 1)
      return false;
    if (!Core_TensorTensor_des(in, region, &(*x)->tensorTensor.op))
      return false;
    (*x)->tag = Core_Operator_tensorTensor;
    break;
  case 35:
    if (l != 1)
      return false;
    if (!Core_TensorTensorScan_des(in, region, &(*x)->tensorTensorScan.op))
      return false;
    (*x)->tag = Core_Operator_tensorTensorScan;
    break;
  case 36:
    if (l != 1)
      return false;
    if (!Core_TensorPartitionReduce_des(in, region,
                                        &(*x)->tensorPartitionReduce.op))
      return false;
    (*x)->tag = Core_Operator_tensorPartitionReduce;
    break;
  case 37:
    if (l != 1)
      return false;
    if (!Core_TensorScalarReduce_des(in, region, &(*x)->tensorScalarReduce.op))
      return false;
    (*x)->tag = Core_Operator_tensorScalarReduce;
    break;
  case 38:
    if (l != 1)
      return false;
    if (!Core_Transpose_des(in, region, &(*x)->transpose.op))
      return false;
    (*x)->tag = Core_Operator_transpose;
    break;
  case 39:
    if (l != 1)
      return false;
    if (!Core_SelectReduce_des(in, region, &(*x)->selectReduce.op))
      return false;
    (*x)->tag = Core_Operator_selectReduce;
    break;
  case 40:
    if (l != 1)
      return false;
    if (!Core_SequenceBounds_des(in, region, &(*x)->sequenceBounds.op))
      return false;
    (*x)->tag = Core_Operator_sequenceBounds;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_Value_des(FILE *in, struct region *region, struct Core_Value **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 101)
    return false;
  *x = region_alloc(region, sizeof(**x));
  switch (c) {
  case 0:
    if (l != 1)
      return false;
    if (!String_des(in, region, &(*x)->var.x))
      return false;
    (*x)->tag = Core_Value_var;
    break;
  case 1:
    if (l != 1)
      return false;
    if (!Bool_des(in, region, &(*x)->b.value))
      return false;
    (*x)->tag = Core_Value_bool;
    break;
  case 2:
    if (l != 1)
      return false;
    if (!Int_des(in, region, &(*x)->i.value))
      return false;
    (*x)->tag = Core_Value_int;
    break;
  case 3:
    if (l != 1)
      return false;
    if (!Float_des(in, region, &(*x)->f.value))
      return false;
    (*x)->tag = Core_Value_float;
    break;
  case 4:
    if (l != 1)
      return false;
    if (!Core_Access_des(in, region, &(*x)->access.a))
      return false;
    (*x)->tag = Core_Value_access;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_Keyword_des(FILE *in, struct region *region,
                      struct Core_Keyword **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 102 || c != 0 || l != 2)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!String_des(in, region, &(*x)->name))
    return false;
  if (!Core_Value_des(in, region, &(*x)->value))
    return false;
  return true;
}

bool Core_Expr_des(FILE *in, struct region *region, struct Core_Expr **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 103)
    return false;
  *x = region_alloc(region, sizeof(**x));
  switch (c) {
  case 0:
    if (l != 1)
      return false;
    if (!Core_Value_des(in, region, &(*x)->value.v))
      return false;
    (*x)->tag = Core_Expr_value;
    break;
  case 1:
    if (l != 3)
      return false;
    if (!String_des(in, region, &(*x)->call.f))
      return false;
    if (!Core_Value_List_des(in, region, &(*x)->call.args))
      return false;
    if (!Core_Keyword_List_des(in, region, &(*x)->call.kwargs))
      return false;
    (*x)->tag = Core_Expr_call;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_Stmt_des(FILE *in, struct region *region, struct Core_Stmt **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 104)
    return false;
  *x = region_alloc(region, sizeof(**x));
  switch (c) {
  case 0:
    if (l != 1)
      return false;
    if (!Core_Value_des(in, region, &(*x)->ret.v))
      return false;
    (*x)->tag = Core_Stmt_ret;
    break;
  case 1:
    if (l != 2)
      return false;
    if (!String_des(in, region, &(*x)->assign.x))
      return false;
    if (!Core_Expr_des(in, region, &(*x)->assign.e))
      return false;
    (*x)->tag = Core_Stmt_assign;
    break;
  case 2:
    if (l != 3)
      return false;
    if (!Core_Operator_des(in, region, &(*x)->oper.op))
      return false;
    if (!String_Option_des(in, region, &(*x)->oper.name))
      return false;
    if (!Core_Pos_des(in, region, &(*x)->oper.pos))
      return false;
    (*x)->tag = Core_Stmt_oper;
    break;
  default:
    return false;
  }
  return true;
}

bool Core_Kernel_des(FILE *in, struct region *region, struct Core_Kernel **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 105 || c != 0 || l != 4)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!String_des(in, region, &(*x)->name))
    return false;
  if (!Core_TensorName_List_des(in, region, &(*x)->inputs))
    return false;
  if (!Core_TensorName_List_des(in, region, &(*x)->outputs))
    return false;
  if (!Core_Stmt_List_des(in, region, &(*x)->body))
    return false;
  return true;
}

bool Core_Index_List_des(FILE *in, struct region *region,
                         struct Core_Index_List **x) {
  u64 count = 0;
  if (!cbor_decode_array_start(in, &count))
    return false;
  struct Core_Index_List *current = *x = NULL;
  for (; count > 0; count--) {
    struct Core_Index_List *node = region_alloc(region, sizeof(*node));
    node->next = NULL;
    if (!current) {
      *x = current = node;
    } else {
      current->next = node;
      current = node;
    }
    if (!Core_Index_des(in, region, &node->index))
      return false;
  }
  return true;
}

bool Core_APPair_List_des(FILE *in, struct region *region,
                          struct Core_APPair_List **x) {
  u64 count = 0;
  if (!cbor_decode_array_start(in, &count))
    return false;
  struct Core_APPair_List *current = *x = NULL;
  for (; count > 0; count--) {
    struct Core_APPair_List *node = region_alloc(region, sizeof(*node));
    node->next = NULL;
    if (!current) {
      *x = current = node;
    } else {
      current->next = node;
      current = node;
    }
    if (!Core_APPair_des(in, region, &node->appair))
      return false;
  }
  return true;
}

bool Core_Dtype_Option_des(FILE *in, struct region *region,
                           enum Core_Dtype *x) {
  bool isSome;
  if (!cbor_decode_option(in, &isSome))
    return false;
  if (!isSome)
    *x = 0;
  else
    return Core_Dtype_des(in, region, x);
  return true;
}

bool Core_Immediate_List_des(FILE *in, struct region *region,
                             struct Core_Immediate_List **x) {
  u64 count = 0;
  if (!cbor_decode_array_start(in, &count))
    return false;
  struct Core_Immediate_List *current = *x = NULL;
  for (; count > 0; count--) {
    struct Core_Immediate_List *node = region_alloc(region, sizeof(*node));
    node->next = NULL;
    if (!current) {
      *x = current = node;
    } else {
      current->next = node;
      current = node;
    }
    if (!Core_Immediate_des(in, region, &node->immediate))
      return false;
  }
  return true;
}

bool Core_TensorRef_Option_des(FILE *in, struct region *region,
                               struct Core_TensorRef **x) {
  bool isSome;
  if (!cbor_decode_option(in, &isSome))
    return false;
  if (!isSome)
    *x = 0;
  else
    return Core_TensorRef_des(in, region, x);
  return true;
}

bool Core_TensorSubDim_Option_des(FILE *in, struct region *region,
                                  enum Core_TensorSubDim *x) {
  bool isSome;
  if (!cbor_decode_option(in, &isSome))
    return false;
  if (!isSome)
    *x = 0;
  else
    return Core_TensorSubDim_des(in, region, x);
  return true;
}

bool Core_Operand_Option_des(FILE *in, struct region *region,
                             struct Core_Operand **x) {
  bool isSome;
  if (!cbor_decode_option(in, &isSome))
    return false;
  if (!isSome)
    *x = 0;
  else
    return Core_Operand_des(in, region, x);
  return true;
}

bool Core_AluOp_Option_des(FILE *in, struct region *region,
                           enum Core_AluOp *x) {
  bool isSome;
  if (!cbor_decode_option(in, &isSome))
    return false;
  if (!isSome)
    *x = 0;
  else
    return Core_AluOp_des(in, region, x);
  return true;
}

bool Core_Immediate_Option_des(FILE *in, struct region *region,
                               struct Core_Immediate **x) {
  bool isSome;
  if (!cbor_decode_option(in, &isSome))
    return false;
  if (!isSome)
    *x = 0;
  else
    return Core_Immediate_des(in, region, x);
  return true;
}

bool Core_Value_List_des(FILE *in, struct region *region,
                         struct Core_Value_List **x) {
  u64 count = 0;
  if (!cbor_decode_array_start(in, &count))
    return false;
  struct Core_Value_List *current = *x = NULL;
  for (; count > 0; count--) {
    struct Core_Value_List *node = region_alloc(region, sizeof(*node));
    node->next = NULL;
    if (!current) {
      *x = current = node;
    } else {
      current->next = node;
      current = node;
    }
    if (!Core_Value_des(in, region, &node->value))
      return false;
  }
  return true;
}

bool Core_Keyword_List_des(FILE *in, struct region *region,
                           struct Core_Keyword_List **x) {
  u64 count = 0;
  if (!cbor_decode_array_start(in, &count))
    return false;
  struct Core_Keyword_List *current = *x = NULL;
  for (; count > 0; count--) {
    struct Core_Keyword_List *node = region_alloc(region, sizeof(*node));
    node->next = NULL;
    if (!current) {
      *x = current = node;
    } else {
      current->next = node;
      current = node;
    }
    if (!Core_Keyword_des(in, region, &node->keyword))
      return false;
  }
  return true;
}

bool Core_TensorName_List_des(FILE *in, struct region *region,
                              struct Core_TensorName_List **x) {
  u64 count = 0;
  if (!cbor_decode_array_start(in, &count))
    return false;
  struct Core_TensorName_List *current = *x = NULL;
  for (; count > 0; count--) {
    struct Core_TensorName_List *node = region_alloc(region, sizeof(*node));
    node->next = NULL;
    if (!current) {
      *x = current = node;
    } else {
      current->next = node;
      current = node;
    }
    if (!Core_TensorName_des(in, region, &node->tensorname))
      return false;
  }
  return true;
}

bool Core_Stmt_List_des(FILE *in, struct region *region,
                        struct Core_Stmt_List **x) {
  u64 count = 0;
  if (!cbor_decode_array_start(in, &count))
    return false;
  struct Core_Stmt_List *current = *x = NULL;
  for (; count > 0; count--) {
    struct Core_Stmt_List *node = region_alloc(region, sizeof(*node));
    node->next = NULL;
    if (!current) {
      *x = current = node;
    } else {
      current->next = node;
      current = node;
    }
    if (!Core_Stmt_des(in, region, &node->stmt))
      return false;
  }
  return true;
}
