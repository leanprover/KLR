/*
Copyright (c) 2025 Amazon.com, Inc. or its affiliates. All Rights Reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Written by the KLR Contributors (https://github.com/leanprover/KLR)
*/
#pragma once

// This file is automatically generated from KLR.
// Manual edits to this file will be overwritten.

#include "klir_common.hpp"

namespace klr {

// KLR.Core Abstract Syntax

struct Pos final {
  Nat line;
  Nat column;
  Option<Nat> lineEnd;
  Option<Nat> columnEnd;
};

enum class Memory {
  hbm = 1,
  sbuf,
  pmem,
  reg,
};

enum class Dtype {
  bfloat16 = 1,
  float8e3,
  float8e4,
  float8e5,
  float16,
  float32,
  float32r,
  int8,
  int16,
  int64,
  int32,
  uint8,
  uint16,
  uint32,
  uint64,
};

struct Shape final {
  Nat parDim;
  List<Nat> freeDims;
};

struct Address final {
  Memory memory;
  Nat parSize;
  Nat freeSize;
  Option<Nat> parOffset;
  Option<Nat> freeOffset;
};

struct TensorName final {
  String name;
  Dtype dtype;
  Ptr<Shape> shape;
  Ptr<Address> address;
  Nat freeElements;
  Prop parWF;
  Prop freeWF;
};

struct Slice final {
  Nat l;
  Nat u;
  Int step;
  Prop wf;
};

struct Index {
  enum class Tag {
    coord = 1,
    slice,
  };
  Tag tag;
  Index(Tag tag) : tag(tag) {}
};

struct IndexCoordWrapper final : Index {
  Nat e;
  IndexCoordWrapper() : Index(Tag::coord) {}
};

struct IndexSliceWrapper final : Index {
  Ptr<Slice> slice;
  IndexSliceWrapper() : Index(Tag::slice) {}
};

struct AccessBasic final {
  Ptr<TensorName> tensor;
  List<Ptr<Index>> indexes;
  Prop lenWF;
};

struct APPair final {
  Int step;
  Nat num;
};

struct AccessPattern final {
  Ptr<TensorName> tensor;
  Nat parNum;
  List<Ptr<APPair>> freePattern;
  Nat offset;
};

struct Access {
  enum class Tag {
    simple = 1,
    basic,
    pattern,
  };
  Tag tag;
  Access(Tag tag) : tag(tag) {}
};

struct AccessSimpleWrapper final : Access {
  Ptr<TensorName> tensor;
  AccessSimpleWrapper() : Access(Tag::simple) {}
};

struct AccessBasicWrapper final : Access {
  Ptr<AccessBasic> access;
  AccessBasicWrapper() : Access(Tag::basic) {}
};

struct AccessPatternWrapper final : Access {
  Ptr<AccessPattern> access;
  AccessPatternWrapper() : Access(Tag::pattern) {}
};

struct TensorHbm final {
  String name;
  Dtype dtype;
  Nat address;
  List<Ptr<APPair>> dims;
};

enum class ParQuadrant {
  par0 = 1,
  par32,
  par64,
  par96,
};

struct TensorSram final {
  String name;
  Dtype dtype;
  ParQuadrant parQuadrant;
  Nat parDim;
  Nat freeOffset;
  List<Ptr<APPair>> freePattern;
};

struct TensorRef {
  enum class Tag {
    abstract = 1,
    sbuf,
    psum,
    hbm,
    reg,
  };
  Tag tag;
  TensorRef(Tag tag) : tag(tag) {}
};

struct TensorRefAbstractWrapper final : TensorRef {
  Ptr<Access> access;
  TensorRefAbstractWrapper() : TensorRef(Tag::abstract) {}
};

struct TensorRefSbufWrapper final : TensorRef {
  Ptr<TensorSram> view;
  TensorRefSbufWrapper() : TensorRef(Tag::sbuf) {}
};

struct TensorRefPsumWrapper final : TensorRef {
  Ptr<TensorSram> view;
  TensorRefPsumWrapper() : TensorRef(Tag::psum) {}
};

struct TensorRefHbmWrapper final : TensorRef {
  Ptr<TensorHbm> view;
  TensorRefHbmWrapper() : TensorRef(Tag::hbm) {}
};

struct TensorRefRegisterWrapper final : TensorRef {
  Nat reg;
  TensorRefRegisterWrapper() : TensorRef(Tag::reg) {}
};

enum class Engine {
  unassigned = 1,
  act,
  dma,
  dve,
  pe,
  pool,
  sp,
};

struct Immediate {
  enum class Tag {
    reg = 1,
    pointer,
    int32,
    float32,
  };
  Tag tag;
  Immediate(Tag tag) : tag(tag) {}
};

struct ImmediateRegisterWrapper final : Immediate {
  Nat reg;
  ImmediateRegisterWrapper() : Immediate(Tag::reg) {}
};

struct ImmediatePointerWrapper final : Immediate {
  ImmediatePointerWrapper() : Immediate(Tag::pointer) {}
};

struct ImmediateIntWrapper final : Immediate {
  Int i;
  ImmediateIntWrapper() : Immediate(Tag::int32) {}
};

struct ImmediateFloatWrapper final : Immediate {
  Float f;
  ImmediateFloatWrapper() : Immediate(Tag::float32) {}
};

struct ActivationImm {
  enum class Tag {
    reg = 1,
    pointer,
    float32,
  };
  Tag tag;
  ActivationImm(Tag tag) : tag(tag) {}
};

struct ActivationImmRegisterWrapper final : ActivationImm {
  Nat reg;
  ActivationImmRegisterWrapper() : ActivationImm(Tag::reg) {}
};

struct ActivationImmPointerWrapper final : ActivationImm {
  ActivationImmPointerWrapper() : ActivationImm(Tag::pointer) {}
};

struct ActivationImmFloatWrapper final : ActivationImm {
  Float f;
  ActivationImmFloatWrapper() : ActivationImm(Tag::float32) {}
};

struct DataPattern final {
  Nat offset;
  List<Ptr<APPair>> pattern;
};

enum class AluOp {
  abs = 1,
  add,
  arith_shift_left,
  arith_shift_right,
  average,
  bitwise_and,
  bitwise_not,
  bitwise_or,
  bitwise_xor,
  bypass,
  divide,
  is_equal,
  is_ge,
  is_gt,
  is_le,
  is_lt,
  logical_and,
  logical_or,
  logical_shift_left,
  logical_shift_right,
  logical_xor,
  max,
  min,
  mod,
  mult,
  not_equal,
  pow,
  rsqrt,
  subtract,
};

enum class DropoutThresholdType {
  DropRate = 1,
  KeepRate,
};

enum class AccumCmd {
  Idle = 1,
  Zero,
  Accumulate,
  ZeroAccumulate,
  LoadAccumulate,
};

enum class ActivationFunc {
  abs = 1,
  arctan,
  copy,
  erf,
  erf_dx,
  exp,
  gelu,
  gelu_apprx_tanh,
  gelu_dx,
  log,
  mish,
  reciprocal,
  relu,
  rsqrt,
  sigmoid,
  sign,
  silu,
  silu_dx,
  sin,
  softplus,
  sqrt,
  square,
  tanh,
};

enum class AffineSelectCmp {
  GreaterThan = 1,
  GreaterThanEq,
  Eq,
  NotEq,
};

enum class DgeComputeOp {
  none = 1,
  add,
};

struct DmaBounds {
  enum class Tag {
    disable = 1,
    enable,
    reg,
  };
  Tag tag;
  DmaBounds(Tag tag) : tag(tag) {}
};

struct DmaBoundsDisableWrapper final : DmaBounds {
  DmaBoundsDisableWrapper() : DmaBounds(Tag::disable) {}
};

struct DmaBoundsEnableWrapper final : DmaBounds {
  DmaBoundsEnableWrapper() : DmaBounds(Tag::enable) {}
};

struct DmaBoundsRegWrapper final : DmaBounds {
  Nat reg;
  DmaBoundsRegWrapper() : DmaBounds(Tag::reg) {}
};

enum class MatmulGroupElement {
  first = 1,
  middle,
  last,
  whole,
};

struct IndexMissBehavior {
  enum class Tag {
    imm = 1,
    skip,
  };
  Tag tag;
  IndexMissBehavior(Tag tag) : tag(tag) {}
};

struct IndexMissBehaviorImmWrapper final : IndexMissBehavior {
  Ptr<Immediate> value;
  IndexMissBehaviorImmWrapper() : IndexMissBehavior(Tag::imm) {}
};

struct IndexMissBehaviorSkipWrapper final : IndexMissBehavior {
  IndexMissBehaviorSkipWrapper() : IndexMissBehavior(Tag::skip) {}
};

enum class TensorScalarReverseOps {
  none = 1,
  first,
  second,
  both,
};

enum class TensorSubDim {
  X = 1,
  XY,
  XYZ,
  XYZW,
};

struct Dropout final {
  Ptr<TensorRef> dst;
  Ptr<TensorRef> src;
  DropoutThresholdType thresholdType;
  Ptr<Immediate> threshold;
};

struct Activate final {
  Ptr<TensorRef> dst;
  Ptr<TensorRef> src;
  AccumCmd accumulatorCmd;
  ActivationFunc activationFunc;
  Ptr<Immediate> scale;
  Ptr<Immediate> bias;
  Ptr<Immediate> imm;
};

struct AffineSelect final {
  Ptr<TensorRef> dst;
  Ptr<TensorRef> src;
  AffineSelectCmp fillMode;
  Nat fillReg;
  Ptr<DataPattern> maskPattern;
};

struct DmaCopy final {
  Ptr<TensorRef> dst;
  Ptr<TensorRef> src;
  DgeComputeOp compute_op;
  Ptr<DmaBounds> dstBoundsCheck;
  Ptr<DmaBounds> srcBoundsCheck;
};

struct DmaTranspose final {
  Ptr<TensorRef> dst;
  Ptr<TensorRef> src;
};

struct Transpose final {
  Ptr<TensorRef> dst;
  Ptr<TensorRef> src;
};

struct LoadMaskRegister final {
  Nat regNum;
};

struct Shuffle final {
  Ptr<TensorRef> dst;
  Ptr<TensorRef> src;
};

struct MemSet final {
  Ptr<TensorRef> dst;
  Ptr<Immediate> value;
  Nat count;
};

struct Iota final {
  Ptr<TensorRef> dst;
  Ptr<DataPattern> pattern;
};

struct LoadStationary final {
  Ptr<TensorRef> src;
  Bool isTranspose;
};

struct MatMul final {
  Ptr<TensorRef> dst;
  Ptr<TensorRef> moving;
  MatmulGroupElement psumAccumulateFlag;
};

struct LocalGather final {
  Ptr<TensorRef> dst;
  Ptr<TensorRef> src;
  Ptr<IndexMissBehavior> indexMissBehavior;
  Bool freePoolBuffer;
};

struct RangeSelect final {
  Ptr<TensorRef> dst;
  Ptr<TensorRef> src;
  AccumCmd reduceCommand;
  AluOp reduceOp;
  Float base;
  Float fillValue;
  AluOp compOp0;
  AluOp compOp1;
  Ptr<Immediate> bound0;
  Ptr<Immediate> bound1;
};

struct ScalarTensorTensor final {
  Ptr<TensorRef> dst;
  Ptr<TensorRef> src0;
  Ptr<TensorRef> src1;
  AluOp op0;
  AluOp op1;
  TensorScalarReverseOps reverseOperands;
  Ptr<Immediate> imm0;
  AccumCmd accumulatorCmd;
};

struct CopyPredicated final {
  Ptr<TensorRef> dst;
  Ptr<TensorRef> src;
  Ptr<TensorRef> predicate;
};

struct TensorTensorScan final {
  Ptr<TensorRef> dst;
  Ptr<TensorRef> src0;
  Ptr<TensorRef> src1;
  AluOp op0;
  AluOp op1;
  TensorScalarReverseOps reverseOperands;
  Ptr<Immediate> imm0;
  AccumCmd accumulatorCmd;
};

struct MatchValueLoad final {
  Ptr<TensorRef> src;
};

struct FindIndex8 final {
  Ptr<TensorRef> dst;
  Ptr<TensorRef> src;
};

struct MatchReplace8 final {
  Ptr<TensorRef> dst;
  Ptr<TensorRef> src;
  Ptr<Immediate> replaceValue;
};

struct Max8 final {
  Ptr<TensorRef> dst;
  Ptr<TensorRef> src;
};

struct BatchNormAggregate final {
  Ptr<TensorRef> dst;
  Ptr<TensorRef> src;
};

struct BatchNormStats final {
  Ptr<TensorRef> dst;
  Ptr<TensorRef> src;
};

struct Reciprocal final {
  Ptr<TensorRef> dst;
  Ptr<TensorRef> src;
};

struct Copy final {
  Ptr<TensorRef> dst;
  Ptr<TensorRef> src;
  Option<TensorSubDim> opDim;
};

struct TensorReduce final {
  Ptr<TensorRef> dst;
  Ptr<TensorRef> src;
  AluOp op;
  TensorSubDim opDim;
  Bool negated;
};

struct TensorScalar final {
  Ptr<TensorRef> dst;
  Ptr<TensorRef> src;
  Ptr<Immediate> imm0;
  AluOp op0;
  Ptr<Immediate> imm1;
  AluOp op1;
  TensorScalarReverseOps reverse;
};

struct TensorTensor final {
  Ptr<TensorRef> dst;
  Ptr<TensorRef> src0;
  Ptr<TensorRef> src1;
  AluOp op;
};

struct NcMatMul final {
  Ptr<TensorRef> dst;
  Ptr<TensorRef> stationary;
  Ptr<TensorRef> moving;
  Bool isStationaryOneZero;
  Bool isMovingZero;
  Bool isTranspose;
  List<Nat> tilePosition;
  List<Nat> tileSize;
};

struct Operator {
  enum class Tag {
    activate = 1,
    affineSelect,
    batchNormAggregate,
    batchNormStats,
    copy,
    copyPredicated,
    dmaCopy,
    dmaTranspose,
    dropout,
    findIndex8,
    iota,
    loadMaskRegister,
    loadStationary,
    localGather,
    matMul,
    matchReplace8,
    matchValueLoad,
    max8,
    memSet,
    rangeSelect,
    reciprocal,
    scalarTensorTensor,
    shuffle,
    tensorReduce,
    tensorScalar,
    tensorTensor,
    tensorTensorScan,
    transpose,
    ncMatMul,
  };
  Tag tag;
  Operator(Tag tag) : tag(tag) {}
};

struct OperatorActivateWrapper final : Operator {
  Ptr<Activate> op;
  OperatorActivateWrapper() : Operator(Tag::activate) {}
};

struct OperatorAffineSelectWrapper final : Operator {
  Ptr<AffineSelect> op;
  OperatorAffineSelectWrapper() : Operator(Tag::affineSelect) {}
};

struct OperatorBatchNormAggregateWrapper final : Operator {
  Ptr<BatchNormAggregate> op;
  OperatorBatchNormAggregateWrapper() : Operator(Tag::batchNormAggregate) {}
};

struct OperatorBatchNormStatsWrapper final : Operator {
  Ptr<BatchNormStats> op;
  OperatorBatchNormStatsWrapper() : Operator(Tag::batchNormStats) {}
};

struct OperatorCopyWrapper final : Operator {
  Ptr<Copy> op;
  OperatorCopyWrapper() : Operator(Tag::copy) {}
};

struct OperatorCopyPredicatedWrapper final : Operator {
  Ptr<CopyPredicated> op;
  OperatorCopyPredicatedWrapper() : Operator(Tag::copyPredicated) {}
};

struct OperatorDmaCopyWrapper final : Operator {
  Ptr<DmaCopy> op;
  OperatorDmaCopyWrapper() : Operator(Tag::dmaCopy) {}
};

struct OperatorDmaTransposeWrapper final : Operator {
  Ptr<DmaTranspose> op;
  OperatorDmaTransposeWrapper() : Operator(Tag::dmaTranspose) {}
};

struct OperatorDropoutWrapper final : Operator {
  Ptr<Dropout> op;
  OperatorDropoutWrapper() : Operator(Tag::dropout) {}
};

struct OperatorFindIndex8Wrapper final : Operator {
  Ptr<FindIndex8> op;
  OperatorFindIndex8Wrapper() : Operator(Tag::findIndex8) {}
};

struct OperatorIotaWrapper final : Operator {
  Ptr<Iota> op;
  OperatorIotaWrapper() : Operator(Tag::iota) {}
};

struct OperatorLoadMaskRegisterWrapper final : Operator {
  Ptr<LoadMaskRegister> op;
  OperatorLoadMaskRegisterWrapper() : Operator(Tag::loadMaskRegister) {}
};

struct OperatorLoadStationaryWrapper final : Operator {
  Ptr<LoadStationary> op;
  OperatorLoadStationaryWrapper() : Operator(Tag::loadStationary) {}
};

struct OperatorLocalGatherWrapper final : Operator {
  Ptr<LocalGather> op;
  OperatorLocalGatherWrapper() : Operator(Tag::localGather) {}
};

struct OperatorMatMulWrapper final : Operator {
  Ptr<MatMul> op;
  OperatorMatMulWrapper() : Operator(Tag::matMul) {}
};

struct OperatorMatchReplace8Wrapper final : Operator {
  Ptr<MatchReplace8> op;
  OperatorMatchReplace8Wrapper() : Operator(Tag::matchReplace8) {}
};

struct OperatorMatchValueLoadWrapper final : Operator {
  Ptr<MatchValueLoad> op;
  OperatorMatchValueLoadWrapper() : Operator(Tag::matchValueLoad) {}
};

struct OperatorMax8Wrapper final : Operator {
  Ptr<Max8> op;
  OperatorMax8Wrapper() : Operator(Tag::max8) {}
};

struct OperatorMemSetWrapper final : Operator {
  Ptr<MemSet> op;
  OperatorMemSetWrapper() : Operator(Tag::memSet) {}
};

struct OperatorRangeSelectWrapper final : Operator {
  Ptr<RangeSelect> op;
  OperatorRangeSelectWrapper() : Operator(Tag::rangeSelect) {}
};

struct OperatorReciprocalWrapper final : Operator {
  Ptr<Reciprocal> op;
  OperatorReciprocalWrapper() : Operator(Tag::reciprocal) {}
};

struct OperatorScalarTensorTensorWrapper final : Operator {
  Ptr<ScalarTensorTensor> op;
  OperatorScalarTensorTensorWrapper() : Operator(Tag::scalarTensorTensor) {}
};

struct OperatorShuffleWrapper final : Operator {
  Ptr<Shuffle> op;
  OperatorShuffleWrapper() : Operator(Tag::shuffle) {}
};

struct OperatorTensorReduceWrapper final : Operator {
  Ptr<TensorReduce> op;
  OperatorTensorReduceWrapper() : Operator(Tag::tensorReduce) {}
};

struct OperatorTensorScalarWrapper final : Operator {
  Ptr<TensorScalar> op;
  OperatorTensorScalarWrapper() : Operator(Tag::tensorScalar) {}
};

struct OperatorTensorTensorWrapper final : Operator {
  Ptr<TensorTensor> op;
  OperatorTensorTensorWrapper() : Operator(Tag::tensorTensor) {}
};

struct OperatorTensorTensorScanWrapper final : Operator {
  Ptr<TensorTensorScan> op;
  OperatorTensorTensorScanWrapper() : Operator(Tag::tensorTensorScan) {}
};

struct OperatorTransposeWrapper final : Operator {
  Ptr<Transpose> op;
  OperatorTransposeWrapper() : Operator(Tag::transpose) {}
};

struct OperatorNcMatMulWrapper final : Operator {
  Ptr<NcMatMul> op;
  OperatorNcMatMulWrapper() : Operator(Tag::ncMatMul) {}
};

struct Value {
  enum class Tag {
    var = 1,
    boolean,
    int32,
    float32,
    access,
  };
  Tag tag;
  Value(Tag tag) : tag(tag) {}
};

struct ValueVarWrapper final : Value {
  String x;
  ValueVarWrapper() : Value(Tag::var) {}
};

struct ValueBoolWrapper final : Value {
  Bool value;
  ValueBoolWrapper() : Value(Tag::boolean) {}
};

struct ValueIntWrapper final : Value {
  Int value;
  ValueIntWrapper() : Value(Tag::int32) {}
};

struct ValueFloatWrapper final : Value {
  Float value;
  ValueFloatWrapper() : Value(Tag::float32) {}
};

struct ValueAccessWrapper final : Value {
  Ptr<Access> a;
  ValueAccessWrapper() : Value(Tag::access) {}
};

struct Keyword final {
  String name;
  Ptr<Value> value;
};

struct Expr {
  enum class Tag {
    value = 1,
    call,
  };
  Tag tag;
  Expr(Tag tag) : tag(tag) {}
};

struct ExprValueWrapper final : Expr {
  Ptr<Value> v;
  ExprValueWrapper() : Expr(Tag::value) {}
};

struct ExprCallWrapper final : Expr {
  String f;
  List<Ptr<Value>> args;
  List<Ptr<Keyword>> kwargs;
  ExprCallWrapper() : Expr(Tag::call) {}
};

struct Stmt {
  enum class Tag {
    ret = 1,
    assign,
    store,
    oper,
  };
  Tag tag;
  Stmt(Tag tag) : tag(tag) {}
};

struct StmtRetWrapper final : Stmt {
  Ptr<Value> v;
  StmtRetWrapper() : Stmt(Tag::ret) {}
};

struct StmtAssignWrapper final : Stmt {
  String x;
  Ptr<Expr> e;
  StmtAssignWrapper() : Stmt(Tag::assign) {}
};

struct StmtStoreWrapper final : Stmt {
  Ptr<Access> dst;
  Ptr<Operator> op;
  List<Ptr<Value>> args;
  StmtStoreWrapper() : Stmt(Tag::store) {}
};

struct StmtOperWrapper final : Stmt {
  Ptr<Operator> op;
  StmtOperWrapper() : Stmt(Tag::oper) {}
};

struct Kernel final {
  String name;
  List<Ptr<TensorName>> inputs;
  List<Ptr<TensorName>> outputs;
  List<Ptr<Stmt>> body;
};

struct KLRFile final {
  Nat major;
  Nat minor;
  Nat patch;
};

struct KLRMetaData final {
  String format;
};

struct Contents {
  enum class Tag {
    python = 1,
    nki,
    klir,
    hlo,
  };
  Tag tag;
  Contents(Tag tag) : tag(tag) {}
};

struct ContentsPythonWrapper final : Contents {
  Ptr<Kernel> kernel;
  ContentsPythonWrapper() : Contents(Tag::python) {}
};

struct ContentsNkiWrapper final : Contents {
  Ptr<Kernel> kernel;
  ContentsNkiWrapper() : Contents(Tag::nki) {}
};

struct ContentsKlirWrapper final : Contents {
  Ptr<Kernel> kernel;
  ContentsKlirWrapper() : Contents(Tag::klir) {}
};

struct ContentsHloWrapper final : Contents {
  String name;
  ContentsHloWrapper() : Contents(Tag::hlo) {}
};
} // namespace klr
