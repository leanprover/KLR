/*
Copyright (c) 2025 Amazon.com, Inc. or its affiliates. All Rights Reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Written by the KLR Contributors (https://github.com/leanprover/KLR)
*/

// This file is automatically generated from KLR.
// Manual edits to this file will be overwritten.

#include "klir_common.hpp"
#include "klir_serde.hpp"
#include <sstream>

namespace klr {

bool List_Bool_ser(FILE *out, const List<Bool> &value) {
  if (!serialize_array_start(out, value.size()))
    return false;

  for (const auto &item : value) {
    if (!Bool_ser(out, item))
      return false;
  }
  return true;
}

bool List_Nat_ser(FILE *out, const List<Nat> &value) {
  if (!serialize_array_start(out, value.size()))
    return false;

  for (const auto &item : value) {
    if (!Nat_ser(out, item))
      return false;
  }
  return true;
}

bool List_Int_ser(FILE *out, const List<Int> &value) {
  if (!serialize_array_start(out, value.size()))
    return false;

  for (const auto &item : value) {
    if (!Int_ser(out, item))
      return false;
  }
  return true;
}

bool List_Float_ser(FILE *out, const List<Float> &value) {
  if (!serialize_array_start(out, value.size()))
    return false;

  for (const auto &item : value) {
    if (!Float_ser(out, item))
      return false;
  }
  return true;
}

bool List_String_ser(FILE *out, const List<String> &value) {
  if (!serialize_array_start(out, value.size()))
    return false;

  for (const auto &item : value) {
    if (!String_ser(out, item))
      return false;
  }
  return true;
}

bool Option_Bool_ser(FILE *out, const Option<Bool> &value) {
  if (!serialize_option(out, value.has_value()))
    return false;

  if (value.has_value()) {
    return Bool_ser(out, value.value());
  }
  return true;
}

bool Option_Nat_ser(FILE *out, const Option<Nat> &value) {
  if (!serialize_option(out, value.has_value()))
    return false;

  if (value.has_value()) {
    return Nat_ser(out, value.value());
  }
  return true;
}

bool Option_Int_ser(FILE *out, const Option<Int> &value) {
  if (!serialize_option(out, value.has_value()))
    return false;

  if (value.has_value()) {
    return Int_ser(out, value.value());
  }
  return true;
}

bool Option_Float_ser(FILE *out, const Option<Float> &value) {
  if (!serialize_option(out, value.has_value()))
    return false;

  if (value.has_value()) {
    return Float_ser(out, value.value());
  }
  return true;
}

bool Option_String_ser(FILE *out, const Option<String> &value) {
  if (!serialize_option(out, value.has_value()))
    return false;

  if (value.has_value()) {
    return String_ser(out, value.value());
  }
  return true;
}

bool Option_List_Bool_ser(FILE *out, const Option<List<Bool>> &value) {
  if (!serialize_option(out, value.has_value()))
    return false;

  if (value.has_value()) {
    return List_Bool_ser(out, value.value());
  }
  return true;
}

bool Option_List_Nat_ser(FILE *out, const Option<List<Nat>> &value) {
  if (!serialize_option(out, value.has_value()))
    return false;

  if (value.has_value()) {
    return List_Nat_ser(out, value.value());
  }
  return true;
}

bool Option_List_Int_ser(FILE *out, const Option<List<Int>> &value) {
  if (!serialize_option(out, value.has_value()))
    return false;

  if (value.has_value()) {
    return List_Int_ser(out, value.value());
  }
  return true;
}

bool Option_List_Float_ser(FILE *out, const Option<List<Float>> &value) {
  if (!serialize_option(out, value.has_value()))
    return false;

  if (value.has_value()) {
    return List_Float_ser(out, value.value());
  }
  return true;
}

bool Option_List_String_ser(FILE *out, const Option<List<String>> &value) {
  if (!serialize_option(out, value.has_value()))
    return false;

  if (value.has_value()) {
    return List_String_ser(out, value.value());
  }
  return true;
}

bool List_List_Bool_ser(FILE *out, const List<List<Bool>> &value) {
  if (!serialize_array_start(out, value.size()))
    return false;

  for (const auto &item : value) {
    if (!List_Bool_ser(out, item))
      return false;
  }
  return true;
}

bool List_List_Nat_ser(FILE *out, const List<List<Nat>> &value) {
  if (!serialize_array_start(out, value.size()))
    return false;

  for (const auto &item : value) {
    if (!List_Nat_ser(out, item))
      return false;
  }
  return true;
}

bool List_List_Int_ser(FILE *out, const List<List<Int>> &value) {
  if (!serialize_array_start(out, value.size()))
    return false;

  for (const auto &item : value) {
    if (!List_Int_ser(out, item))
      return false;
  }
  return true;
}

bool List_List_Float_ser(FILE *out, const List<List<Float>> &value) {
  if (!serialize_array_start(out, value.size()))
    return false;

  for (const auto &item : value) {
    if (!List_Float_ser(out, item))
      return false;
  }
  return true;
}

bool List_List_String_ser(FILE *out, const List<List<String>> &value) {
  if (!serialize_array_start(out, value.size()))
    return false;

  for (const auto &item : value) {
    if (!List_String_ser(out, item))
      return false;
  }
  return true;
}

bool Option_List_List_Bool_ser(FILE *out,
                               const Option<List<List<Bool>>> &value) {
  if (!serialize_option(out, value.has_value()))
    return false;

  if (value.has_value()) {
    return List_List_Bool_ser(out, value.value());
  }
  return true;
}

bool Option_List_List_Nat_ser(FILE *out, const Option<List<List<Nat>>> &value) {
  if (!serialize_option(out, value.has_value()))
    return false;

  if (value.has_value()) {
    return List_List_Nat_ser(out, value.value());
  }
  return true;
}

bool Option_List_List_Int_ser(FILE *out, const Option<List<List<Int>>> &value) {
  if (!serialize_option(out, value.has_value()))
    return false;

  if (value.has_value()) {
    return List_List_Int_ser(out, value.value());
  }
  return true;
}

bool Option_List_List_Float_ser(FILE *out,
                                const Option<List<List<Float>>> &value) {
  if (!serialize_option(out, value.has_value()))
    return false;

  if (value.has_value()) {
    return List_List_Float_ser(out, value.value());
  }
  return true;
}

bool Option_List_List_String_ser(FILE *out,
                                 const Option<List<List<String>>> &value) {
  if (!serialize_option(out, value.has_value()))
    return false;

  if (value.has_value()) {
    return List_List_String_ser(out, value.value());
  }
  return true;
}

bool Pos_ser(FILE *out, const Ptr<Pos> &value) {
  if (!serialize_tag(out, 100, 0, 5))
    return false;
  if (!Nat_ser(out, value->line))
    return false;
  if (!Nat_ser(out, value->column))
    return false;
  if (!Option_Nat_ser(out, value->lineEnd))
    return false;
  if (!Option_Nat_ser(out, value->columnEnd))
    return false;
  if (!Option_String_ser(out, value->filename))
    return false;
  return true;
}

List<Bool> List_Bool_des(FILE *in) {
  u64 size = 0;
  if (!deserialize_array_start(in, &size))
    throw std::runtime_error("expecting List");

  List<Bool> l;
  while (size-- > 0) {
    Bool b = Bool_des(in);
    l.push_back(b);
  }
  return l;
}

List<Nat> List_Nat_des(FILE *in) {
  u64 size = 0;
  if (!deserialize_array_start(in, &size))
    throw std::runtime_error("expecting List");

  List<Nat> l;
  while (size-- > 0) {
    Nat b = Nat_des(in);
    l.push_back(b);
  }
  return l;
}

List<Int> List_Int_des(FILE *in) {
  u64 size = 0;
  if (!deserialize_array_start(in, &size))
    throw std::runtime_error("expecting List");

  List<Int> l;
  while (size-- > 0) {
    Int b = Int_des(in);
    l.push_back(b);
  }
  return l;
}

List<Float> List_Float_des(FILE *in) {
  u64 size = 0;
  if (!deserialize_array_start(in, &size))
    throw std::runtime_error("expecting List");

  List<Float> l;
  while (size-- > 0) {
    Float b = Float_des(in);
    l.push_back(b);
  }
  return l;
}

List<String> List_String_des(FILE *in) {
  u64 size = 0;
  if (!deserialize_array_start(in, &size))
    throw std::runtime_error("expecting List");

  List<String> l;
  while (size-- > 0) {
    String b = String_des(in);
    l.push_back(b);
  }
  return l;
}

Option<Bool> Option_Bool_des(FILE *in) {
  bool isSome;
  if (!deserialize_option(in, &isSome))
    throw std::runtime_error("expecting Bool");

  Option<Bool> x;
  if (isSome)
    x = Bool_des(in);
  return x;
}

Option<Nat> Option_Nat_des(FILE *in) {
  bool isSome;
  if (!deserialize_option(in, &isSome))
    throw std::runtime_error("expecting Bool");

  Option<Nat> x;
  if (isSome)
    x = Nat_des(in);
  return x;
}

Option<Int> Option_Int_des(FILE *in) {
  bool isSome;
  if (!deserialize_option(in, &isSome))
    throw std::runtime_error("expecting Bool");

  Option<Int> x;
  if (isSome)
    x = Int_des(in);
  return x;
}

Option<Float> Option_Float_des(FILE *in) {
  bool isSome;
  if (!deserialize_option(in, &isSome))
    throw std::runtime_error("expecting Bool");

  Option<Float> x;
  if (isSome)
    x = Float_des(in);
  return x;
}

Option<String> Option_String_des(FILE *in) {
  bool isSome;
  if (!deserialize_option(in, &isSome))
    throw std::runtime_error("expecting Bool");

  Option<String> x;
  if (isSome)
    x = String_des(in);
  return x;
}

Option<List<Bool>> Option_List_Bool_des(FILE *in) {
  bool isSome;
  if (!deserialize_option(in, &isSome))
    throw std::runtime_error("expecting Bool");

  Option<List<Bool>> x;
  if (isSome)
    x = List_Bool_des(in);
  return x;
}

Option<List<Nat>> Option_List_Nat_des(FILE *in) {
  bool isSome;
  if (!deserialize_option(in, &isSome))
    throw std::runtime_error("expecting Bool");

  Option<List<Nat>> x;
  if (isSome)
    x = List_Nat_des(in);
  return x;
}

Option<List<Int>> Option_List_Int_des(FILE *in) {
  bool isSome;
  if (!deserialize_option(in, &isSome))
    throw std::runtime_error("expecting Bool");

  Option<List<Int>> x;
  if (isSome)
    x = List_Int_des(in);
  return x;
}

Option<List<Float>> Option_List_Float_des(FILE *in) {
  bool isSome;
  if (!deserialize_option(in, &isSome))
    throw std::runtime_error("expecting Bool");

  Option<List<Float>> x;
  if (isSome)
    x = List_Float_des(in);
  return x;
}

Option<List<String>> Option_List_String_des(FILE *in) {
  bool isSome;
  if (!deserialize_option(in, &isSome))
    throw std::runtime_error("expecting Bool");

  Option<List<String>> x;
  if (isSome)
    x = List_String_des(in);
  return x;
}

List<List<Bool>> List_List_Bool_des(FILE *in) {
  u64 size = 0;
  if (!deserialize_array_start(in, &size))
    throw std::runtime_error("expecting List");

  List<List<Bool>> l;
  while (size-- > 0) {
    List<Bool> b = List_Bool_des(in);
    l.push_back(b);
  }
  return l;
}

List<List<Nat>> List_List_Nat_des(FILE *in) {
  u64 size = 0;
  if (!deserialize_array_start(in, &size))
    throw std::runtime_error("expecting List");

  List<List<Nat>> l;
  while (size-- > 0) {
    List<Nat> b = List_Nat_des(in);
    l.push_back(b);
  }
  return l;
}

List<List<Int>> List_List_Int_des(FILE *in) {
  u64 size = 0;
  if (!deserialize_array_start(in, &size))
    throw std::runtime_error("expecting List");

  List<List<Int>> l;
  while (size-- > 0) {
    List<Int> b = List_Int_des(in);
    l.push_back(b);
  }
  return l;
}

List<List<Float>> List_List_Float_des(FILE *in) {
  u64 size = 0;
  if (!deserialize_array_start(in, &size))
    throw std::runtime_error("expecting List");

  List<List<Float>> l;
  while (size-- > 0) {
    List<Float> b = List_Float_des(in);
    l.push_back(b);
  }
  return l;
}

List<List<String>> List_List_String_des(FILE *in) {
  u64 size = 0;
  if (!deserialize_array_start(in, &size))
    throw std::runtime_error("expecting List");

  List<List<String>> l;
  while (size-- > 0) {
    List<String> b = List_String_des(in);
    l.push_back(b);
  }
  return l;
}

Option<List<List<Bool>>> Option_List_List_Bool_des(FILE *in) {
  bool isSome;
  if (!deserialize_option(in, &isSome))
    throw std::runtime_error("expecting Bool");

  Option<List<List<Bool>>> x;
  if (isSome)
    x = List_List_Bool_des(in);
  return x;
}

Option<List<List<Nat>>> Option_List_List_Nat_des(FILE *in) {
  bool isSome;
  if (!deserialize_option(in, &isSome))
    throw std::runtime_error("expecting Bool");

  Option<List<List<Nat>>> x;
  if (isSome)
    x = List_List_Nat_des(in);
  return x;
}

Option<List<List<Int>>> Option_List_List_Int_des(FILE *in) {
  bool isSome;
  if (!deserialize_option(in, &isSome))
    throw std::runtime_error("expecting Bool");

  Option<List<List<Int>>> x;
  if (isSome)
    x = List_List_Int_des(in);
  return x;
}

Option<List<List<Float>>> Option_List_List_Float_des(FILE *in) {
  bool isSome;
  if (!deserialize_option(in, &isSome))
    throw std::runtime_error("expecting Bool");

  Option<List<List<Float>>> x;
  if (isSome)
    x = List_List_Float_des(in);
  return x;
}

Option<List<List<String>>> Option_List_List_String_des(FILE *in) {
  bool isSome;
  if (!deserialize_option(in, &isSome))
    throw std::runtime_error("expecting Bool");

  Option<List<List<String>>> x;
  if (isSome)
    x = List_List_String_des(in);
  return x;
}

Ptr<Pos> Pos_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting Pos:100,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 100 || c != 0 || l != 5) {
    std::ostringstream msg;
    msg << "Expecting Pos:(100,0,5)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<Pos> x = ptr<Pos>();
  x->line = Nat_des(in);
  x->column = Nat_des(in);
  x->lineEnd = Option_Nat_des(in);
  x->columnEnd = Option_Nat_des(in);
  x->filename = Option_String_des(in);
  return x;
}

bool Immediate_ser(FILE *out, const Ptr<Immediate> &value) {
  u8 tag_val = 0;
  u8 field_count = 1; // All variants have exactly 1 field

  // Map Immediate tags to their serialization case numbers
  switch (value->tag) {
  case Immediate::Tag::reg:
    tag_val = 0;
    field_count = 1;
    break;
  case Immediate::Tag::pointer:
    tag_val = 1;
    field_count = 0;
    break;
  case Immediate::Tag::int32:
    tag_val = 2;
    field_count = 1;
    break;
  case Immediate::Tag::float32:
    tag_val = 3;
    field_count = 1;
    break;
  default:
    throw std::runtime_error("Unknown Immediate type in serialization");
    return false;
  }

  // Serialize the tag
  if (!serialize_tag(out, 131, tag_val, field_count))
    return false;

  // Serialize the fields based on the specific variant
  switch (value->tag) {
  case Immediate::Tag::reg: {
    auto *typed_value =
        static_cast<const ImmediateRegisterWrapper *>(value.get());
    return Nat_ser(out, typed_value->reg);
  }
  case Immediate::Tag::pointer: {
    auto *typed_value =
        static_cast<const ImmediatePointerWrapper *>(value.get());
    return true; // pointer variant has no fields to serialize
  }
  case Immediate::Tag::int32: {
    auto *typed_value = static_cast<const ImmediateIntWrapper *>(value.get());
    return Int_ser(out, typed_value->i);
  }
  case Immediate::Tag::float32: {
    auto *typed_value = static_cast<const ImmediateFloatWrapper *>(value.get());
    return Float_ser(out, typed_value->f);
  }
  default:
    throw std::runtime_error("Unknown Immediate type in serialization");
    return false;
  }
}

bool Memory_ser(FILE *out, const Memory &value) {
  u8 tag_val = 0;
  switch (value) {
  case Memory::hbm:
    tag_val = 0;
    break;
  case Memory::sbuf:
    tag_val = 1;
    break;
  case Memory::psum:
    tag_val = 2;
    break;
  case Memory::reg:
    tag_val = 3;
    break;
  case Memory::shared_hbm:
    tag_val = 4;
    break;
  case Memory::private_hbm:
    tag_val = 5;
    break;
  default:
    return false;
  }
  return serialize_tag(out, 110, tag_val, 0);
}

bool Dtype_ser(FILE *out, const Dtype &value) {
  u8 tag_val = 0;
  switch (value) {
  case Dtype::bfloat16:
    tag_val = 0;
    break;
  case Dtype::float8e3:
    tag_val = 1;
    break;
  case Dtype::float8e4:
    tag_val = 2;
    break;
  case Dtype::float8e5:
    tag_val = 3;
    break;
  case Dtype::float16:
    tag_val = 4;
    break;
  case Dtype::float32:
    tag_val = 5;
    break;
  case Dtype::float32r:
    tag_val = 6;
    break;
  case Dtype::int8:
    tag_val = 7;
    break;
  case Dtype::int16:
    tag_val = 8;
    break;
  case Dtype::int64:
    tag_val = 9;
    break;
  case Dtype::int32:
    tag_val = 10;
    break;
  case Dtype::uint8:
    tag_val = 11;
    break;
  case Dtype::uint16:
    tag_val = 12;
    break;
  case Dtype::uint32:
    tag_val = 13;
    break;
  case Dtype::uint64:
    tag_val = 14;
    break;
  case Dtype::float8_e4m3:
    tag_val = 15;
    break;
  case Dtype::float8_e4m3fn:
    tag_val = 16;
    break;
  case Dtype::float8_e5m2_x4:
    tag_val = 17;
    break;
  case Dtype::float8_e4m3fn_x4:
    tag_val = 18;
    break;
  case Dtype::float4_e2m1fn_x4:
    tag_val = 19;
    break;
  default:
    return false;
  }
  return serialize_tag(out, 111, tag_val, 0);
}

bool Shape_ser(FILE *out, const Ptr<Shape> &value) {
  if (!serialize_tag(out, 112, 0, 2))
    return false;
  if (!Nat_ser(out, value->parDim))
    return false;
  if (!List_Nat_ser(out, value->freeDims))
    return false;
  return true;
}

bool Address_ser(FILE *out, const Ptr<Address> &value) {
  if (!serialize_tag(out, 113, 0, 7))
    return false;
  if (!String_ser(out, value->name))
    return false;
  if (!Memory_ser(out, value->memory))
    return false;
  if (!Nat_ser(out, value->parSize))
    return false;
  if (!Nat_ser(out, value->freeSize))
    return false;
  if (!Option_Nat_ser(out, value->parOffset))
    return false;
  if (!Option_Nat_ser(out, value->freeOffset))
    return false;
  if (!Bool_ser(out, value->isShared))
    return false;
  return true;
}

bool TensorName_ser(FILE *out, const Ptr<TensorName> &value) {
  if (!serialize_tag(out, 114, 0, 8))
    return false;
  if (!String_ser(out, value->name))
    return false;
  if (!Dtype_ser(out, value->dtype))
    return false;
  if (!Shape_ser(out, value->shape))
    return false;
  if (!Address_ser(out, value->address))
    return false;
  if (!Nat_ser(out, value->freeElements))
    return false;
  if (!Prop_ser(out, value->parWF))
    return false;
  if (!Prop_ser(out, value->freeWF))
    return false;
  if (!Bool_ser(out, value->addressRotation))
    return false;
  return true;
}

bool Slice_ser(FILE *out, const Ptr<Slice> &value) {
  if (!serialize_tag(out, 115, 0, 4))
    return false;
  if (!Nat_ser(out, value->l))
    return false;
  if (!Nat_ser(out, value->u))
    return false;
  if (!Int_ser(out, value->step))
    return false;
  if (!Prop_ser(out, value->wf))
    return false;
  return true;
}

bool Index_ser(FILE *out, const Ptr<Index> &value) {
  u8 tag_val = 0;
  u8 field_count = 1; // All variants have exactly 1 field

  // Map Index tags to their serialization case numbers
  switch (value->tag) {
  case Index::Tag::coord:
    tag_val = 0;
    field_count = 1;
    break;
  case Index::Tag::slice:
    tag_val = 1;
    field_count = 1;
    break;
  default:
    throw std::runtime_error("Unknown Index type in serialization");
    return false;
  }

  // Serialize the tag
  if (!serialize_tag(out, 117, tag_val, field_count))
    return false;

  // Serialize the fields based on the specific variant
  switch (value->tag) {
  case Index::Tag::coord: {
    auto *typed_value = static_cast<const IndexCoordWrapper *>(value.get());
    return Nat_ser(out, typed_value->e);
  }
  case Index::Tag::slice: {
    auto *typed_value = static_cast<const IndexSliceWrapper *>(value.get());
    return Slice_ser(out, typed_value->slice);
  }
  default:
    throw std::runtime_error("Unknown Index type in serialization");
    return false;
  }
}

bool AccessBasic_ser(FILE *out, const Ptr<AccessBasic> &value) {
  if (!serialize_tag(out, 118, 0, 3))
    return false;
  if (!TensorName_ser(out, value->tensor))
    return false;
  if (!List_Index_ser(out, value->indexes))
    return false;
  if (!Prop_ser(out, value->lenWF))
    return false;
  return true;
}

bool APPair_ser(FILE *out, const Ptr<APPair> &value) {
  if (!serialize_tag(out, 119, 0, 3))
    return false;
  if (!Int_ser(out, value->step))
    return false;
  if (!Nat_ser(out, value->num))
    return false;
  if (!Nat_ser(out, value->offset))
    return false;
  return true;
}

bool AccessPattern_ser(FILE *out, const Ptr<AccessPattern> &value) {
  if (!serialize_tag(out, 120, 0, 6))
    return false;
  if (!TensorName_ser(out, value->tensor))
    return false;
  if (!Nat_ser(out, value->parNum))
    return false;
  if (!List_APPair_ser(out, value->pattern))
    return false;
  if (!Nat_ser(out, value->parOffset))
    return false;
  if (!Nat_ser(out, value->freeOffset))
    return false;
  if (!List_Nat_ser(out, value->fixedAxis))
    return false;
  return true;
}

bool ScalarOffset_ser(FILE *out, const Ptr<ScalarOffset> &value) {
  u8 tag_val = 0;
  u8 field_count = 1; // All variants have exactly 1 field

  // Map ScalarOffset tags to their serialization case numbers
  switch (value->tag) {
  case ScalarOffset::Tag::reg:
    tag_val = 0;
    field_count = 1;
    break;
  case ScalarOffset::Tag::acc:
    tag_val = 1;
    field_count = 1;
    break;
  default:
    throw std::runtime_error("Unknown ScalarOffset type in serialization");
    return false;
  }

  // Serialize the tag
  if (!serialize_tag(out, 123, tag_val, field_count))
    return false;

  // Serialize the fields based on the specific variant
  switch (value->tag) {
  case ScalarOffset::Tag::reg: {
    auto *typed_value =
        static_cast<const ScalarOffsetRegWrapper *>(value.get());
    return String_ser(out, typed_value->r);
  }
  case ScalarOffset::Tag::acc: {
    auto *typed_value =
        static_cast<const ScalarOffsetAccWrapper *>(value.get());
    return Access_ser(out, typed_value->a);
  }
  default:
    throw std::runtime_error("Unknown ScalarOffset type in serialization");
    return false;
  }
}

bool BirAccessPattern_ser(FILE *out, const Ptr<BirAccessPattern> &value) {
  if (!serialize_tag(out, 124, 0, 7))
    return false;
  if (!TensorName_ser(out, value->tensor))
    return false;
  if (!Nat_ser(out, value->offset))
    return false;
  if (!List_APPair_ser(out, value->pattern))
    return false;
  if (!Option_ScalarOffset_ser(out, value->scalarOffset))
    return false;
  if (!Option_Access_ser(out, value->vectorOffset))
    return false;
  if (!Int_ser(out, value->indirectDim))
    return false;
  if (!Option_Dtype_ser(out, value->dtypeOverride))
    return false;
  return true;
}

bool Access_ser(FILE *out, const Ptr<Access> &value) {
  u8 tag_val = 0;
  u8 field_count = 1; // All variants have exactly 1 field

  // Map Access tags to their serialization case numbers
  switch (value->tag) {
  case Access::Tag::simple:
    tag_val = 0;
    field_count = 1;
    break;
  case Access::Tag::basic:
    tag_val = 1;
    field_count = 1;
    break;
  case Access::Tag::pattern:
    tag_val = 2;
    field_count = 1;
    break;
  case Access::Tag::birPattern:
    tag_val = 3;
    field_count = 1;
    break;
  default:
    throw std::runtime_error("Unknown Access type in serialization");
    return false;
  }

  // Serialize the tag
  if (!serialize_tag(out, 125, tag_val, field_count))
    return false;

  // Serialize the fields based on the specific variant
  switch (value->tag) {
  case Access::Tag::simple: {
    auto *typed_value = static_cast<const AccessSimpleWrapper *>(value.get());
    return TensorName_ser(out, typed_value->tensor);
  }
  case Access::Tag::basic: {
    auto *typed_value = static_cast<const AccessBasicWrapper *>(value.get());
    return AccessBasic_ser(out, typed_value->access);
  }
  case Access::Tag::pattern: {
    auto *typed_value = static_cast<const AccessPatternWrapper *>(value.get());
    return AccessPattern_ser(out, typed_value->access);
  }
  case Access::Tag::birPattern: {
    auto *typed_value =
        static_cast<const AccessBirPatternWrapper *>(value.get());
    return BirAccessPattern_ser(out, typed_value->access);
  }
  default:
    throw std::runtime_error("Unknown Access type in serialization");
    return false;
  }
}

bool TensorHbm_ser(FILE *out, const Ptr<TensorHbm> &value) {
  if (!serialize_tag(out, 126, 0, 4))
    return false;
  if (!String_ser(out, value->name))
    return false;
  if (!Dtype_ser(out, value->dtype))
    return false;
  if (!Nat_ser(out, value->address))
    return false;
  if (!List_APPair_ser(out, value->dims))
    return false;
  return true;
}

bool TensorSram_ser(FILE *out, const Ptr<TensorSram> &value) {
  if (!serialize_tag(out, 127, 0, 6))
    return false;
  if (!String_ser(out, value->name))
    return false;
  if (!Dtype_ser(out, value->dtype))
    return false;
  if (!Nat_ser(out, value->parNum))
    return false;
  if (!List_APPair_ser(out, value->pattern))
    return false;
  if (!Nat_ser(out, value->parOffset))
    return false;
  if (!Nat_ser(out, value->freeOffset))
    return false;
  return true;
}

bool TensorRef_ser(FILE *out, const Ptr<TensorRef> &value) {
  u8 tag_val = 0;
  u8 field_count = 1; // All variants have exactly 1 field

  // Map TensorRef tags to their serialization case numbers
  switch (value->tag) {
  case TensorRef::Tag::abstract:
    tag_val = 0;
    field_count = 1;
    break;
  case TensorRef::Tag::sbuf:
    tag_val = 1;
    field_count = 1;
    break;
  case TensorRef::Tag::psum:
    tag_val = 2;
    field_count = 1;
    break;
  case TensorRef::Tag::hbm:
    tag_val = 3;
    field_count = 1;
    break;
  case TensorRef::Tag::reg:
    tag_val = 4;
    field_count = 1;
    break;
  default:
    throw std::runtime_error("Unknown TensorRef type in serialization");
    return false;
  }

  // Serialize the tag
  if (!serialize_tag(out, 128, tag_val, field_count))
    return false;

  // Serialize the fields based on the specific variant
  switch (value->tag) {
  case TensorRef::Tag::abstract: {
    auto *typed_value =
        static_cast<const TensorRefAbstractWrapper *>(value.get());
    return Access_ser(out, typed_value->access);
  }
  case TensorRef::Tag::sbuf: {
    auto *typed_value = static_cast<const TensorRefSbufWrapper *>(value.get());
    return TensorSram_ser(out, typed_value->view);
  }
  case TensorRef::Tag::psum: {
    auto *typed_value = static_cast<const TensorRefPsumWrapper *>(value.get());
    return TensorSram_ser(out, typed_value->view);
  }
  case TensorRef::Tag::hbm: {
    auto *typed_value = static_cast<const TensorRefHbmWrapper *>(value.get());
    return TensorHbm_ser(out, typed_value->view);
  }
  case TensorRef::Tag::reg: {
    auto *typed_value =
        static_cast<const TensorRefRegisterWrapper *>(value.get());
    return Nat_ser(out, typed_value->reg);
  }
  default:
    throw std::runtime_error("Unknown TensorRef type in serialization");
    return false;
  }
}

bool MatmulPerfMode_ser(FILE *out, const MatmulPerfMode &value) {
  u8 tag_val = 0;
  switch (value) {
  case MatmulPerfMode::None:
    tag_val = 0;
    break;
  case MatmulPerfMode::DoubleRow:
    tag_val = 1;
    break;
  case MatmulPerfMode::DoubleRowSwInterleave:
    tag_val = 2;
    break;
  default:
    return false;
  }
  return serialize_tag(out, 129, tag_val, 0);
}

bool Engine_ser(FILE *out, const Engine &value) {
  u8 tag_val = 0;
  switch (value) {
  case Engine::unassigned:
    tag_val = 0;
    break;
  case Engine::act:
    tag_val = 1;
    break;
  case Engine::dma:
    tag_val = 2;
    break;
  case Engine::dve:
    tag_val = 3;
    break;
  case Engine::pe:
    tag_val = 4;
    break;
  case Engine::pool:
    tag_val = 5;
    break;
  case Engine::sp:
    tag_val = 6;
    break;
  default:
    return false;
  }
  return serialize_tag(out, 130, tag_val, 0);
}

bool ActivationImm_ser(FILE *out, const Ptr<ActivationImm> &value) {
  u8 tag_val = 0;
  u8 field_count = 1; // All variants have exactly 1 field

  // Map ActivationImm tags to their serialization case numbers
  switch (value->tag) {
  case ActivationImm::Tag::reg:
    tag_val = 0;
    field_count = 1;
    break;
  case ActivationImm::Tag::pointer:
    tag_val = 1;
    field_count = 0;
    break;
  case ActivationImm::Tag::float32:
    tag_val = 2;
    field_count = 1;
    break;
  default:
    throw std::runtime_error("Unknown ActivationImm type in serialization");
    return false;
  }

  // Serialize the tag
  if (!serialize_tag(out, 132, tag_val, field_count))
    return false;

  // Serialize the fields based on the specific variant
  switch (value->tag) {
  case ActivationImm::Tag::reg: {
    auto *typed_value =
        static_cast<const ActivationImmRegisterWrapper *>(value.get());
    return Nat_ser(out, typed_value->reg);
  }
  case ActivationImm::Tag::pointer: {
    auto *typed_value =
        static_cast<const ActivationImmPointerWrapper *>(value.get());
    return true; // pointer variant has no fields to serialize
  }
  case ActivationImm::Tag::float32: {
    auto *typed_value =
        static_cast<const ActivationImmFloatWrapper *>(value.get());
    return Float_ser(out, typed_value->f);
  }
  default:
    throw std::runtime_error("Unknown ActivationImm type in serialization");
    return false;
  }
}

bool Operand_ser(FILE *out, const Ptr<Operand> &value) {
  u8 tag_val = 0;
  u8 field_count = 1; // All variants have exactly 1 field

  // Map Operand tags to their serialization case numbers
  switch (value->tag) {
  case Operand::Tag::imm:
    tag_val = 0;
    field_count = 1;
    break;
  case Operand::Tag::tile:
    tag_val = 1;
    field_count = 1;
    break;
  default:
    throw std::runtime_error("Unknown Operand type in serialization");
    return false;
  }

  // Serialize the tag
  if (!serialize_tag(out, 133, tag_val, field_count))
    return false;

  // Serialize the fields based on the specific variant
  switch (value->tag) {
  case Operand::Tag::imm: {
    auto *typed_value = static_cast<const OperandImmWrapper *>(value.get());
    return Immediate_ser(out, typed_value->i);
  }
  case Operand::Tag::tile: {
    auto *typed_value = static_cast<const OperandTileWrapper *>(value.get());
    return TensorRef_ser(out, typed_value->t);
  }
  default:
    throw std::runtime_error("Unknown Operand type in serialization");
    return false;
  }
}

bool DataPattern_ser(FILE *out, const Ptr<DataPattern> &value) {
  if (!serialize_tag(out, 134, 0, 3))
    return false;
  if (!Int_ser(out, value->offset))
    return false;
  if (!List_APPair_ser(out, value->pattern))
    return false;
  if (!Int_ser(out, value->channelMultiplier))
    return false;
  return true;
}

bool AluOp_ser(FILE *out, const AluOp &value) {
  u8 tag_val = 0;
  switch (value) {
  case AluOp::abs:
    tag_val = 0;
    break;
  case AluOp::add:
    tag_val = 1;
    break;
  case AluOp::arith_shift_left:
    tag_val = 2;
    break;
  case AluOp::arith_shift_right:
    tag_val = 3;
    break;
  case AluOp::average:
    tag_val = 4;
    break;
  case AluOp::bitwise_and:
    tag_val = 5;
    break;
  case AluOp::bitwise_not:
    tag_val = 6;
    break;
  case AluOp::bitwise_or:
    tag_val = 7;
    break;
  case AluOp::bitwise_xor:
    tag_val = 8;
    break;
  case AluOp::bypass:
    tag_val = 9;
    break;
  case AluOp::divide:
    tag_val = 10;
    break;
  case AluOp::is_equal:
    tag_val = 11;
    break;
  case AluOp::is_ge:
    tag_val = 12;
    break;
  case AluOp::is_gt:
    tag_val = 13;
    break;
  case AluOp::is_le:
    tag_val = 14;
    break;
  case AluOp::is_lt:
    tag_val = 15;
    break;
  case AluOp::logical_and:
    tag_val = 16;
    break;
  case AluOp::logical_or:
    tag_val = 17;
    break;
  case AluOp::logical_shift_left:
    tag_val = 18;
    break;
  case AluOp::logical_shift_right:
    tag_val = 19;
    break;
  case AluOp::logical_xor:
    tag_val = 20;
    break;
  case AluOp::max:
    tag_val = 21;
    break;
  case AluOp::min:
    tag_val = 22;
    break;
  case AluOp::mod:
    tag_val = 23;
    break;
  case AluOp::mult:
    tag_val = 24;
    break;
  case AluOp::not_equal:
    tag_val = 25;
    break;
  case AluOp::pow:
    tag_val = 26;
    break;
  case AluOp::rsqrt:
    tag_val = 27;
    break;
  case AluOp::subtract:
    tag_val = 28;
    break;
  default:
    return false;
  }
  return serialize_tag(out, 135, tag_val, 0);
}

bool DropoutThresholdType_ser(FILE *out, const DropoutThresholdType &value) {
  u8 tag_val = 0;
  switch (value) {
  case DropoutThresholdType::DropRate:
    tag_val = 0;
    break;
  case DropoutThresholdType::KeepRate:
    tag_val = 1;
    break;
  default:
    return false;
  }
  return serialize_tag(out, 136, tag_val, 0);
}

bool AccumCmd_ser(FILE *out, const AccumCmd &value) {
  u8 tag_val = 0;
  switch (value) {
  case AccumCmd::Idle:
    tag_val = 0;
    break;
  case AccumCmd::Zero:
    tag_val = 1;
    break;
  case AccumCmd::Accumulate:
    tag_val = 2;
    break;
  case AccumCmd::ZeroAccumulate:
    tag_val = 3;
    break;
  case AccumCmd::LoadAccumulate:
    tag_val = 4;
    break;
  default:
    return false;
  }
  return serialize_tag(out, 137, tag_val, 0);
}

bool ActivationFunc_ser(FILE *out, const ActivationFunc &value) {
  u8 tag_val = 0;
  switch (value) {
  case ActivationFunc::abs:
    tag_val = 0;
    break;
  case ActivationFunc::arctan:
    tag_val = 1;
    break;
  case ActivationFunc::copy:
    tag_val = 2;
    break;
  case ActivationFunc::erf:
    tag_val = 3;
    break;
  case ActivationFunc::erf_dx:
    tag_val = 4;
    break;
  case ActivationFunc::exp:
    tag_val = 5;
    break;
  case ActivationFunc::gelu:
    tag_val = 6;
    break;
  case ActivationFunc::gelu_apprx_tanh:
    tag_val = 7;
    break;
  case ActivationFunc::gelu_dx:
    tag_val = 8;
    break;
  case ActivationFunc::log:
    tag_val = 9;
    break;
  case ActivationFunc::mish:
    tag_val = 10;
    break;
  case ActivationFunc::reciprocal:
    tag_val = 11;
    break;
  case ActivationFunc::relu:
    tag_val = 12;
    break;
  case ActivationFunc::rsqrt:
    tag_val = 13;
    break;
  case ActivationFunc::sigmoid:
    tag_val = 14;
    break;
  case ActivationFunc::sign:
    tag_val = 15;
    break;
  case ActivationFunc::silu:
    tag_val = 16;
    break;
  case ActivationFunc::silu_dx:
    tag_val = 17;
    break;
  case ActivationFunc::sin:
    tag_val = 18;
    break;
  case ActivationFunc::softplus:
    tag_val = 19;
    break;
  case ActivationFunc::sqrt:
    tag_val = 20;
    break;
  case ActivationFunc::square:
    tag_val = 21;
    break;
  case ActivationFunc::tanh:
    tag_val = 22;
    break;
  case ActivationFunc::gelu_apprx_sigmoid:
    tag_val = 23;
    break;
  case ActivationFunc::gelu_apprx_sigmoid_dx:
    tag_val = 24;
    break;
  default:
    return false;
  }
  return serialize_tag(out, 138, tag_val, 0);
}

bool AffineSelectCmp_ser(FILE *out, const AffineSelectCmp &value) {
  u8 tag_val = 0;
  switch (value) {
  case AffineSelectCmp::GreaterThan:
    tag_val = 0;
    break;
  case AffineSelectCmp::GreaterThanEq:
    tag_val = 1;
    break;
  case AffineSelectCmp::Eq:
    tag_val = 2;
    break;
  case AffineSelectCmp::NotEq:
    tag_val = 3;
    break;
  default:
    return false;
  }
  return serialize_tag(out, 139, tag_val, 0);
}

bool DgeComputeOp_ser(FILE *out, const DgeComputeOp &value) {
  u8 tag_val = 0;
  switch (value) {
  case DgeComputeOp::none:
    tag_val = 0;
    break;
  case DgeComputeOp::add:
    tag_val = 1;
    break;
  default:
    return false;
  }
  return serialize_tag(out, 140, tag_val, 0);
}

bool DmaBounds_ser(FILE *out, const Ptr<DmaBounds> &value) {
  u8 tag_val = 0;
  u8 field_count = 1; // All variants have exactly 1 field

  // Map DmaBounds tags to their serialization case numbers
  switch (value->tag) {
  case DmaBounds::Tag::skip:
    tag_val = 0;
    field_count = 0;
    break;
  case DmaBounds::Tag::error:
    tag_val = 1;
    field_count = 0;
    break;
  case DmaBounds::Tag::reg:
    tag_val = 2;
    field_count = 1;
    break;
  default:
    throw std::runtime_error("Unknown DmaBounds type in serialization");
    return false;
  }

  // Serialize the tag
  if (!serialize_tag(out, 141, tag_val, field_count))
    return false;

  // Serialize the fields based on the specific variant
  switch (value->tag) {
  case DmaBounds::Tag::skip: {
    auto *typed_value = static_cast<const DmaBoundsSkipWrapper *>(value.get());
    return true; // skip variant has no fields to serialize
  }
  case DmaBounds::Tag::error: {
    auto *typed_value = static_cast<const DmaBoundsErrorWrapper *>(value.get());
    return true; // error variant has no fields to serialize
  }
  case DmaBounds::Tag::reg: {
    auto *typed_value = static_cast<const DmaBoundsRegWrapper *>(value.get());
    return Nat_ser(out, typed_value->reg);
  }
  default:
    throw std::runtime_error("Unknown DmaBounds type in serialization");
    return false;
  }
}

bool MatmulGroupElement_ser(FILE *out, const MatmulGroupElement &value) {
  u8 tag_val = 0;
  switch (value) {
  case MatmulGroupElement::first:
    tag_val = 0;
    break;
  case MatmulGroupElement::middle:
    tag_val = 1;
    break;
  case MatmulGroupElement::last:
    tag_val = 2;
    break;
  case MatmulGroupElement::whole:
    tag_val = 3;
    break;
  default:
    return false;
  }
  return serialize_tag(out, 142, tag_val, 0);
}

bool IndexMissBehavior_ser(FILE *out, const Ptr<IndexMissBehavior> &value) {
  u8 tag_val = 0;
  u8 field_count = 1; // All variants have exactly 1 field

  // Map IndexMissBehavior tags to their serialization case numbers
  switch (value->tag) {
  case IndexMissBehavior::Tag::imm:
    tag_val = 0;
    field_count = 1;
    break;
  case IndexMissBehavior::Tag::skip:
    tag_val = 1;
    field_count = 0;
    break;
  default:
    throw std::runtime_error("Unknown IndexMissBehavior type in serialization");
    return false;
  }

  // Serialize the tag
  if (!serialize_tag(out, 143, tag_val, field_count))
    return false;

  // Serialize the fields based on the specific variant
  switch (value->tag) {
  case IndexMissBehavior::Tag::imm: {
    auto *typed_value =
        static_cast<const IndexMissBehaviorImmWrapper *>(value.get());
    return Immediate_ser(out, typed_value->value);
  }
  case IndexMissBehavior::Tag::skip: {
    auto *typed_value =
        static_cast<const IndexMissBehaviorSkipWrapper *>(value.get());
    return true; // skip variant has no fields to serialize
  }
  default:
    throw std::runtime_error("Unknown IndexMissBehavior type in serialization");
    return false;
  }
}

bool TensorScalarReverseOps_ser(FILE *out,
                                const TensorScalarReverseOps &value) {
  u8 tag_val = 0;
  switch (value) {
  case TensorScalarReverseOps::none:
    tag_val = 0;
    break;
  case TensorScalarReverseOps::first:
    tag_val = 1;
    break;
  case TensorScalarReverseOps::second:
    tag_val = 2;
    break;
  case TensorScalarReverseOps::both:
    tag_val = 3;
    break;
  default:
    return false;
  }
  return serialize_tag(out, 144, tag_val, 0);
}

bool TensorSubDim_ser(FILE *out, const TensorSubDim &value) {
  u8 tag_val = 0;
  switch (value) {
  case TensorSubDim::X:
    tag_val = 0;
    break;
  case TensorSubDim::XY:
    tag_val = 1;
    break;
  case TensorSubDim::XYZ:
    tag_val = 2;
    break;
  case TensorSubDim::XYZW:
    tag_val = 3;
    break;
  default:
    return false;
  }
  return serialize_tag(out, 145, tag_val, 0);
}

bool TransposeOps_ser(FILE *out, const TransposeOps &value) {
  u8 tag_val = 0;
  switch (value) {
  case TransposeOps::None:
    tag_val = 0;
    break;
  case TransposeOps::WZXY:
    tag_val = 1;
    break;
  case TransposeOps::WXZY:
    tag_val = 2;
    break;
  case TransposeOps::WYXZ:
    tag_val = 3;
    break;
  case TransposeOps::ZWYX:
    tag_val = 4;
    break;
  case TransposeOps::ZYWX:
    tag_val = 5;
    break;
  case TransposeOps::ZYXW:
    tag_val = 6;
    break;
  case TransposeOps::YXWZ:
    tag_val = 7;
    break;
  case TransposeOps::YXZW:
    tag_val = 8;
    break;
  case TransposeOps::YWZX:
    tag_val = 9;
    break;
  case TransposeOps::XWZY:
    tag_val = 10;
    break;
  case TransposeOps::XZYW:
    tag_val = 11;
    break;
  case TransposeOps::XYZW:
    tag_val = 12;
    break;
  case TransposeOps::XYWZ:
    tag_val = 13;
    break;
  default:
    return false;
  }
  return serialize_tag(out, 146, tag_val, 0);
}

bool Dropout_ser(FILE *out, const Ptr<Dropout> &value) {
  if (!serialize_tag(out, 147, 0, 5))
    return false;
  if (!TensorRef_ser(out, value->dst))
    return false;
  if (!TensorRef_ser(out, value->src))
    return false;
  if (!DropoutThresholdType_ser(out, value->thresholdType))
    return false;
  if (!Operand_ser(out, value->threshold))
    return false;
  if (!Option_Dtype_ser(out, value->dtype))
    return false;
  return true;
}

bool Activate_ser(FILE *out, const Ptr<Activate> &value) {
  if (!serialize_tag(out, 148, 0, 7))
    return false;
  if (!TensorRef_ser(out, value->dst))
    return false;
  if (!TensorRef_ser(out, value->src))
    return false;
  if (!AccumCmd_ser(out, value->accumulatorCmd))
    return false;
  if (!ActivationFunc_ser(out, value->activationFunc))
    return false;
  if (!Immediate_ser(out, value->scale))
    return false;
  if (!Immediate_ser(out, value->bias))
    return false;
  if (!Immediate_ser(out, value->imm))
    return false;
  return true;
}

bool AffineSelect_ser(FILE *out, const Ptr<AffineSelect> &value) {
  if (!serialize_tag(out, 150, 0, 5))
    return false;
  if (!TensorRef_ser(out, value->dst))
    return false;
  if (!TensorRef_ser(out, value->src))
    return false;
  if (!AffineSelectCmp_ser(out, value->fillMode))
    return false;
  if (!Nat_ser(out, value->fillReg))
    return false;
  if (!DataPattern_ser(out, value->maskPattern))
    return false;
  return true;
}

bool DmaCopy_ser(FILE *out, const Ptr<DmaCopy> &value) {
  if (!serialize_tag(out, 152, 0, 5))
    return false;
  if (!TensorRef_ser(out, value->dst))
    return false;
  if (!TensorRef_ser(out, value->src))
    return false;
  if (!DgeComputeOp_ser(out, value->compute_op))
    return false;
  if (!DmaBounds_ser(out, value->dstBoundsCheck))
    return false;
  if (!DmaBounds_ser(out, value->srcBoundsCheck))
    return false;
  return true;
}

bool DmaTranspose_ser(FILE *out, const Ptr<DmaTranspose> &value) {
  if (!serialize_tag(out, 154, 0, 6))
    return false;
  if (!TensorRef_ser(out, value->dst))
    return false;
  if (!TensorRef_ser(out, value->src))
    return false;
  if (!TransposeOps_ser(out, value->axes))
    return false;
  if (!Option_Dtype_ser(out, value->dtype))
    return false;
  if (!Nat_ser(out, value->dgeMode))
    return false;
  if (!DmaBounds_ser(out, value->oobMode))
    return false;
  return true;
}

bool Transpose_ser(FILE *out, const Ptr<Transpose> &value) {
  if (!serialize_tag(out, 155, 0, 4))
    return false;
  if (!TensorRef_ser(out, value->dst))
    return false;
  if (!TensorRef_ser(out, value->src))
    return false;
  if (!Option_Dtype_ser(out, value->dtype))
    return false;
  if (!Engine_ser(out, value->engine))
    return false;
  return true;
}

bool LoadMaskRegister_ser(FILE *out, const Ptr<LoadMaskRegister> &value) {
  if (!serialize_tag(out, 156, 0, 1))
    return false;
  if (!Nat_ser(out, value->regNum))
    return false;
  return true;
}

bool Shuffle_ser(FILE *out, const Ptr<Shuffle> &value) {
  if (!serialize_tag(out, 157, 0, 4))
    return false;
  if (!TensorRef_ser(out, value->dst))
    return false;
  if (!TensorRef_ser(out, value->src))
    return false;
  if (!List_Immediate_ser(out, value->shuffleMask))
    return false;
  if (!Option_Dtype_ser(out, value->dtype))
    return false;
  return true;
}

bool MemSet_ser(FILE *out, const Ptr<MemSet> &value) {
  if (!serialize_tag(out, 158, 0, 4))
    return false;
  if (!TensorRef_ser(out, value->dst))
    return false;
  if (!Immediate_ser(out, value->value))
    return false;
  if (!Dtype_ser(out, value->dtype))
    return false;
  if (!Engine_ser(out, value->engine))
    return false;
  return true;
}

bool Iota_ser(FILE *out, const Ptr<Iota> &value) {
  if (!serialize_tag(out, 159, 0, 3))
    return false;
  if (!TensorRef_ser(out, value->dst))
    return false;
  if (!DataPattern_ser(out, value->pattern))
    return false;
  if (!Option_Dtype_ser(out, value->dtype))
    return false;
  return true;
}

bool LoadStationary_ser(FILE *out, const Ptr<LoadStationary> &value) {
  if (!serialize_tag(out, 160, 0, 2))
    return false;
  if (!TensorRef_ser(out, value->src))
    return false;
  if (!Bool_ser(out, value->isTranspose))
    return false;
  return true;
}

bool MatMul_ser(FILE *out, const Ptr<MatMul> &value) {
  if (!serialize_tag(out, 161, 0, 2))
    return false;
  if (!TensorRef_ser(out, value->dst))
    return false;
  if (!TensorRef_ser(out, value->moving))
    return false;
  return true;
}

bool LocalGather_ser(FILE *out, const Ptr<LocalGather> &value) {
  if (!serialize_tag(out, 162, 0, 4))
    return false;
  if (!TensorRef_ser(out, value->dst))
    return false;
  if (!TensorRef_ser(out, value->src))
    return false;
  if (!IndexMissBehavior_ser(out, value->indexMissBehavior))
    return false;
  if (!Bool_ser(out, value->freePoolBuffer))
    return false;
  return true;
}

bool RangeSelect_ser(FILE *out, const Ptr<RangeSelect> &value) {
  if (!serialize_tag(out, 164, 0, 10))
    return false;
  if (!TensorRef_ser(out, value->dst))
    return false;
  if (!TensorRef_ser(out, value->src))
    return false;
  if (!AccumCmd_ser(out, value->reduceCommand))
    return false;
  if (!AluOp_ser(out, value->reduceOp))
    return false;
  if (!Float_ser(out, value->base))
    return false;
  if (!Float_ser(out, value->fillValue))
    return false;
  if (!AluOp_ser(out, value->compOp0))
    return false;
  if (!AluOp_ser(out, value->compOp1))
    return false;
  if (!Immediate_ser(out, value->bound0))
    return false;
  if (!Immediate_ser(out, value->bound1))
    return false;
  return true;
}

bool ScalarTensorTensor_ser(FILE *out, const Ptr<ScalarTensorTensor> &value) {
  if (!serialize_tag(out, 166, 0, 8))
    return false;
  if (!TensorRef_ser(out, value->dst))
    return false;
  if (!TensorRef_ser(out, value->src0))
    return false;
  if (!TensorRef_ser(out, value->src1))
    return false;
  if (!AluOp_ser(out, value->op0))
    return false;
  if (!AluOp_ser(out, value->op1))
    return false;
  if (!TensorScalarReverseOps_ser(out, value->reverseOperands))
    return false;
  if (!Immediate_ser(out, value->imm0))
    return false;
  if (!AccumCmd_ser(out, value->accumulatorCmd))
    return false;
  return true;
}

bool CopyPredicated_ser(FILE *out, const Ptr<CopyPredicated> &value) {
  if (!serialize_tag(out, 168, 0, 5))
    return false;
  if (!TensorRef_ser(out, value->dst))
    return false;
  if (!TensorRef_ser(out, value->src))
    return false;
  if (!TensorRef_ser(out, value->predicate))
    return false;
  if (!Option_Dtype_ser(out, value->dtype))
    return false;
  if (!Bool_ser(out, value->reversePred))
    return false;
  return true;
}

bool TensorTensorScan_ser(FILE *out, const Ptr<TensorTensorScan> &value) {
  if (!serialize_tag(out, 169, 0, 9))
    return false;
  if (!TensorRef_ser(out, value->dst))
    return false;
  if (!TensorRef_ser(out, value->src0))
    return false;
  if (!TensorRef_ser(out, value->src1))
    return false;
  if (!AluOp_ser(out, value->op0))
    return false;
  if (!AluOp_ser(out, value->op1))
    return false;
  if (!TensorScalarReverseOps_ser(out, value->reverseOperands))
    return false;
  if (!Operand_ser(out, value->imm0))
    return false;
  if (!AccumCmd_ser(out, value->accumulatorCmd))
    return false;
  if (!Option_Dtype_ser(out, value->dtype))
    return false;
  return true;
}

bool MatchValueLoad_ser(FILE *out, const Ptr<MatchValueLoad> &value) {
  if (!serialize_tag(out, 170, 0, 1))
    return false;
  if (!TensorRef_ser(out, value->src))
    return false;
  return true;
}

bool FindIndex8_ser(FILE *out, const Ptr<FindIndex8> &value) {
  if (!serialize_tag(out, 171, 0, 4))
    return false;
  if (!TensorRef_ser(out, value->dst))
    return false;
  if (!TensorRef_ser(out, value->src))
    return false;
  if (!TensorRef_ser(out, value->vals))
    return false;
  if (!Option_Dtype_ser(out, value->dtype))
    return false;
  return true;
}

bool MatchReplace8_ser(FILE *out, const Ptr<MatchReplace8> &value) {
  if (!serialize_tag(out, 172, 0, 6))
    return false;
  if (!TensorRef_ser(out, value->dst))
    return false;
  if (!TensorRef_ser(out, value->src))
    return false;
  if (!TensorRef_ser(out, value->vals))
    return false;
  if (!Immediate_ser(out, value->replaceValue))
    return false;
  if (!Option_TensorRef_ser(out, value->dstIdx))
    return false;
  if (!Option_Dtype_ser(out, value->dtype))
    return false;
  return true;
}

bool Max8_ser(FILE *out, const Ptr<Max8> &value) {
  if (!serialize_tag(out, 173, 0, 3))
    return false;
  if (!TensorRef_ser(out, value->dst))
    return false;
  if (!TensorRef_ser(out, value->src))
    return false;
  if (!Option_Dtype_ser(out, value->dtype))
    return false;
  return true;
}

bool BatchNormAggregate_ser(FILE *out, const Ptr<BatchNormAggregate> &value) {
  if (!serialize_tag(out, 174, 0, 3))
    return false;
  if (!TensorRef_ser(out, value->dst))
    return false;
  if (!TensorRef_ser(out, value->src))
    return false;
  if (!Option_Dtype_ser(out, value->dtype))
    return false;
  return true;
}

bool BatchNormStats_ser(FILE *out, const Ptr<BatchNormStats> &value) {
  if (!serialize_tag(out, 175, 0, 3))
    return false;
  if (!TensorRef_ser(out, value->dst))
    return false;
  if (!TensorRef_ser(out, value->src))
    return false;
  if (!Option_Dtype_ser(out, value->dtype))
    return false;
  return true;
}

bool Reciprocal_ser(FILE *out, const Ptr<Reciprocal> &value) {
  if (!serialize_tag(out, 176, 0, 3))
    return false;
  if (!TensorRef_ser(out, value->dst))
    return false;
  if (!TensorRef_ser(out, value->src))
    return false;
  if (!Option_Dtype_ser(out, value->dtype))
    return false;
  return true;
}

bool Copy_ser(FILE *out, const Ptr<Copy> &value) {
  if (!serialize_tag(out, 177, 0, 3))
    return false;
  if (!TensorRef_ser(out, value->dst))
    return false;
  if (!TensorRef_ser(out, value->src))
    return false;
  if (!Option_TensorSubDim_ser(out, value->opDim))
    return false;
  return true;
}

bool TensorReduce_ser(FILE *out, const Ptr<TensorReduce> &value) {
  if (!serialize_tag(out, 179, 0, 7))
    return false;
  if (!TensorRef_ser(out, value->dst))
    return false;
  if (!TensorRef_ser(out, value->src))
    return false;
  if (!AluOp_ser(out, value->op))
    return false;
  if (!TensorSubDim_ser(out, value->opDim))
    return false;
  if (!Bool_ser(out, value->negated))
    return false;
  if (!Option_Dtype_ser(out, value->dtype))
    return false;
  if (!Bool_ser(out, value->keepdims))
    return false;
  return true;
}

bool TensorScalar_ser(FILE *out, const Ptr<TensorScalar> &value) {
  if (!serialize_tag(out, 180, 0, 9))
    return false;
  if (!TensorRef_ser(out, value->dst))
    return false;
  if (!TensorRef_ser(out, value->src))
    return false;
  if (!Operand_ser(out, value->imm0))
    return false;
  if (!AluOp_ser(out, value->op0))
    return false;
  if (!Option_Operand_ser(out, value->imm1))
    return false;
  if (!Option_AluOp_ser(out, value->op1))
    return false;
  if (!TensorScalarReverseOps_ser(out, value->reverse))
    return false;
  if (!Engine_ser(out, value->engine))
    return false;
  if (!Option_Dtype_ser(out, value->dtype))
    return false;
  return true;
}

bool TensorTensor_ser(FILE *out, const Ptr<TensorTensor> &value) {
  if (!serialize_tag(out, 182, 0, 6))
    return false;
  if (!TensorRef_ser(out, value->dst))
    return false;
  if (!TensorRef_ser(out, value->src0))
    return false;
  if (!TensorRef_ser(out, value->src1))
    return false;
  if (!AluOp_ser(out, value->op))
    return false;
  if (!Option_Dtype_ser(out, value->dtype))
    return false;
  if (!Engine_ser(out, value->engine))
    return false;
  return true;
}

bool NcMatMul_ser(FILE *out, const Ptr<NcMatMul> &value) {
  if (!serialize_tag(out, 183, 0, 9))
    return false;
  if (!TensorRef_ser(out, value->dst))
    return false;
  if (!TensorRef_ser(out, value->stationary))
    return false;
  if (!TensorRef_ser(out, value->moving))
    return false;
  if (!Bool_ser(out, value->isStationaryOneZero))
    return false;
  if (!Bool_ser(out, value->isMovingZero))
    return false;
  if (!Bool_ser(out, value->isTranspose))
    return false;
  if (!List_Nat_ser(out, value->tilePosition))
    return false;
  if (!List_Nat_ser(out, value->tileSize))
    return false;
  if (!MatmulPerfMode_ser(out, value->perfMode))
    return false;
  return true;
}

bool TensorScalarReduce_ser(FILE *out, const Ptr<TensorScalarReduce> &value) {
  if (!serialize_tag(out, 181, 0, 8))
    return false;
  if (!TensorRef_ser(out, value->dst))
    return false;
  if (!TensorRef_ser(out, value->src))
    return false;
  if (!Operand_ser(out, value->operand0))
    return false;
  if (!AluOp_ser(out, value->op0))
    return false;
  if (!Bool_ser(out, value->reverse0))
    return false;
  if (!Option_Dtype_ser(out, value->dtype))
    return false;
  if (!Option_AluOp_ser(out, value->reduceOp))
    return false;
  if (!TensorRef_ser(out, value->reduceRes))
    return false;
  return true;
}

bool TensorPartitionReduce_ser(FILE *out,
                               const Ptr<TensorPartitionReduce> &value) {
  if (!serialize_tag(out, 184, 0, 4))
    return false;
  if (!TensorRef_ser(out, value->dst))
    return false;
  if (!AluOp_ser(out, value->op))
    return false;
  if (!TensorRef_ser(out, value->data))
    return false;
  if (!Option_Dtype_ser(out, value->dtype))
    return false;
  return true;
}

bool NcActivate_ser(FILE *out, const Ptr<NcActivate> &value) {
  if (!serialize_tag(out, 149, 0, 9))
    return false;
  if (!TensorRef_ser(out, value->dst))
    return false;
  if (!TensorRef_ser(out, value->src))
    return false;
  if (!AccumCmd_ser(out, value->accumulatorCmd))
    return false;
  if (!ActivationFunc_ser(out, value->activationFunc))
    return false;
  if (!Operand_ser(out, value->scale))
    return false;
  if (!Option_TensorRef_ser(out, value->bias))
    return false;
  if (!Option_AluOp_ser(out, value->reduceOp))
    return false;
  if (!Option_TensorRef_ser(out, value->reduceRes))
    return false;
  if (!Option_Dtype_ser(out, value->dtype))
    return false;
  return true;
}

bool NcAffineSelect_ser(FILE *out, const Ptr<NcAffineSelect> &value) {
  if (!serialize_tag(out, 151, 0, 6))
    return false;
  if (!TensorRef_ser(out, value->dst))
    return false;
  if (!DataPattern_ser(out, value->pred))
    return false;
  if (!TensorRef_ser(out, value->onTrueTile))
    return false;
  if (!Immediate_ser(out, value->onFalseValue))
    return false;
  if (!Option_Dtype_ser(out, value->dtype))
    return false;
  if (!AluOp_ser(out, value->cmpOp))
    return false;
  return true;
}

bool NcDmaCopy_ser(FILE *out, const Ptr<NcDmaCopy> &value) {
  if (!serialize_tag(out, 153, 0, 7))
    return false;
  if (!TensorRef_ser(out, value->dst))
    return false;
  if (!TensorRef_ser(out, value->src))
    return false;
  if (!DgeComputeOp_ser(out, value->compute_op))
    return false;
  if (!DmaBounds_ser(out, value->oobMode))
    return false;
  if (!Nat_ser(out, value->dgeMode))
    return false;
  if (!Bool_ser(out, value->uniqueIndices))
    return false;
  if (!Engine_ser(out, value->engine))
    return false;
  return true;
}

bool NcLocalGather_ser(FILE *out, const Ptr<NcLocalGather> &value) {
  if (!serialize_tag(out, 163, 0, 5))
    return false;
  if (!TensorRef_ser(out, value->dst))
    return false;
  if (!TensorRef_ser(out, value->src))
    return false;
  if (!TensorRef_ser(out, value->index))
    return false;
  if (!Immediate_ser(out, value->numElemPerIdx))
    return false;
  if (!Option_Immediate_ser(out, value->numValidIndicies))
    return false;
  return true;
}

bool NcRangeSelect_ser(FILE *out, const Ptr<NcRangeSelect> &value) {
  if (!serialize_tag(out, 165, 0, 12))
    return false;
  if (!TensorRef_ser(out, value->dst))
    return false;
  if (!AccumCmd_ser(out, value->reduceCommand))
    return false;
  if (!Option_TensorRef_ser(out, value->reduceRes))
    return false;
  if (!Option_AluOp_ser(out, value->reduceOp))
    return false;
  if (!AluOp_ser(out, value->compOp0))
    return false;
  if (!AluOp_ser(out, value->compOp1))
    return false;
  if (!TensorRef_ser(out, value->bound0))
    return false;
  if (!TensorRef_ser(out, value->bound1))
    return false;
  if (!Immediate_ser(out, value->rangeStart))
    return false;
  if (!TensorRef_ser(out, value->onTrueTile))
    return false;
  if (!Immediate_ser(out, value->onFalseValue))
    return false;
  if (!Option_Dtype_ser(out, value->dtype))
    return false;
  return true;
}

bool NcScalarTensorTensor_ser(FILE *out,
                              const Ptr<NcScalarTensorTensor> &value) {
  if (!serialize_tag(out, 167, 0, 8))
    return false;
  if (!TensorRef_ser(out, value->dst))
    return false;
  if (!TensorRef_ser(out, value->data))
    return false;
  if (!Operand_ser(out, value->src0))
    return false;
  if (!Operand_ser(out, value->src1))
    return false;
  if (!AluOp_ser(out, value->op0))
    return false;
  if (!AluOp_ser(out, value->op1))
    return false;
  if (!TensorScalarReverseOps_ser(out, value->reverseOperands))
    return false;
  if (!Option_Dtype_ser(out, value->dtype))
    return false;
  return true;
}

bool NcCopy_ser(FILE *out, const Ptr<NcCopy> &value) {
  if (!serialize_tag(out, 178, 0, 4))
    return false;
  if (!TensorRef_ser(out, value->dst))
    return false;
  if (!TensorRef_ser(out, value->src))
    return false;
  if (!Option_Dtype_ser(out, value->dtype))
    return false;
  if (!Engine_ser(out, value->engine))
    return false;
  return true;
}

bool SelectReduce_ser(FILE *out, const Ptr<SelectReduce> &value) {
  if (!serialize_tag(out, 185, 0, 9))
    return false;
  if (!TensorRef_ser(out, value->dst))
    return false;
  if (!TensorRef_ser(out, value->predicate))
    return false;
  if (!TensorRef_ser(out, value->onTrue))
    return false;
  if (!Operand_ser(out, value->onFalse))
    return false;
  if (!Option_TensorRef_ser(out, value->reduceRes))
    return false;
  if (!AccumCmd_ser(out, value->reduceCmd))
    return false;
  if (!AluOp_ser(out, value->reduceOp))
    return false;
  if (!Bool_ser(out, value->reversePred))
    return false;
  if (!Option_Dtype_ser(out, value->dtype))
    return false;
  return true;
}

bool SequenceBounds_ser(FILE *out, const Ptr<SequenceBounds> &value) {
  if (!serialize_tag(out, 186, 0, 3))
    return false;
  if (!TensorRef_ser(out, value->dst))
    return false;
  if (!TensorRef_ser(out, value->segmentIds))
    return false;
  if (!Option_Dtype_ser(out, value->dtype))
    return false;
  return true;
}

bool SendRecv_ser(FILE *out, const Ptr<SendRecv> &value) {
  if (!serialize_tag(out, 187, 0, 6))
    return false;
  if (!TensorRef_ser(out, value->dst))
    return false;
  if (!TensorRef_ser(out, value->src))
    return false;
  if (!Immediate_ser(out, value->sendToRank))
    return false;
  if (!Immediate_ser(out, value->recvFromRank))
    return false;
  if (!Immediate_ser(out, value->pipeId))
    return false;
  if (!Bool_ser(out, value->useGpsimdDma))
    return false;
  return true;
}

bool SendRecvCompute_ser(FILE *out, const Ptr<SendRecvCompute> &value) {
  if (!serialize_tag(out, 188, 0, 6))
    return false;
  if (!List_TensorRef_ser(out, value->dsts))
    return false;
  if (!List_TensorRef_ser(out, value->srcs))
    return false;
  if (!List_Immediate_ser(out, value->sendToRanks))
    return false;
  if (!List_Immediate_ser(out, value->recvFromRanks))
    return false;
  if (!Immediate_ser(out, value->pipeId))
    return false;
  if (!AluOp_ser(out, value->op))
    return false;
  return true;
}

bool QuantizeMX_ser(FILE *out, const Ptr<QuantizeMX> &value) {
  if (!serialize_tag(out, 195, 0, 3))
    return false;
  if (!TensorRef_ser(out, value->dst))
    return false;
  if (!TensorRef_ser(out, value->src))
    return false;
  if (!TensorRef_ser(out, value->dstScale))
    return false;
  return true;
}

bool MatMulMX_ser(FILE *out, const Ptr<MatMulMX> &value) {
  if (!serialize_tag(out, 196, 0, 7))
    return false;
  if (!TensorRef_ser(out, value->dst))
    return false;
  if (!TensorRef_ser(out, value->stationary))
    return false;
  if (!TensorRef_ser(out, value->moving))
    return false;
  if (!TensorRef_ser(out, value->stationaryScale))
    return false;
  if (!TensorRef_ser(out, value->movingScale))
    return false;
  if (!Option_List_Nat_ser(out, value->tilePosition))
    return false;
  if (!Option_List_Nat_ser(out, value->tileSize))
    return false;
  return true;
}

bool DmaCompute_ser(FILE *out, const Ptr<DmaCompute> &value) {
  if (!serialize_tag(out, 197, 0, 4))
    return false;
  if (!TensorRef_ser(out, value->dst))
    return false;
  if (!List_TensorRef_ser(out, value->srcs))
    return false;
  if (!List_Immediate_ser(out, value->scales))
    return false;
  if (!AluOp_ser(out, value->reduceOp))
    return false;
  return true;
}

bool ReplicaGroup_ser(FILE *out, const Ptr<ReplicaGroup> &value) {
  u8 tag_val = 0;
  u8 field_count = 1; // All variants have exactly 1 field

  // Map ReplicaGroup tags to their serialization case numbers
  switch (value->tag) {
  case ReplicaGroup::Tag::unspecified:
    tag_val = 0;
    field_count = 0;
    break;
  case ReplicaGroup::Tag::named:
    tag_val = 1;
    field_count = 1;
    break;
  case ReplicaGroup::Tag::literal:
    tag_val = 2;
    field_count = 1;
    break;
  default:
    throw std::runtime_error("Unknown ReplicaGroup type in serialization");
    return false;
  }

  // Serialize the tag
  if (!serialize_tag(out, 198, tag_val, field_count))
    return false;

  // Serialize the fields based on the specific variant
  switch (value->tag) {
  case ReplicaGroup::Tag::unspecified: {
    auto *typed_value =
        static_cast<const ReplicaGroupUnspecifiedWrapper *>(value.get());
    return true; // unspecified variant has no fields to serialize
  }
  case ReplicaGroup::Tag::named: {
    auto *typed_value =
        static_cast<const ReplicaGroupNamedWrapper *>(value.get());
    return String_ser(out, typed_value->name);
  }
  case ReplicaGroup::Tag::literal: {
    auto *typed_value =
        static_cast<const ReplicaGroupLiteralWrapper *>(value.get());
    return List_List_Int_ser(out, typed_value->groups);
  }
  default:
    throw std::runtime_error("Unknown ReplicaGroup type in serialization");
    return false;
  }
}

bool CollectiveOp_ser(FILE *out, const Ptr<CollectiveOp> &value) {
  if (!serialize_tag(out, 199, 0, 8))
    return false;
  if (!List_TensorRef_ser(out, value->dsts))
    return false;
  if (!List_TensorRef_ser(out, value->srcs))
    return false;
  if (!Option_AluOp_ser(out, value->op))
    return false;
  if (!ReplicaGroup_ser(out, value->replicaGroup))
    return false;
  if (!Option_Int_ser(out, value->concatDim))
    return false;
  if (!Option_List_List_Int_ser(out, value->sourceTargetPairs))
    return false;
  if (!Option_Int_ser(out, value->channel_id))
    return false;
  if (!Option_Int_ser(out, value->num_channels))
    return false;
  return true;
}

bool RankId_ser(FILE *out, const Ptr<RankId> &value) {
  if (!serialize_tag(out, 200, 0, 1))
    return false;
  if (!String_ser(out, value->dst))
    return false;
  return true;
}

bool CurrentProcessingRankId_ser(FILE *out,
                                 const Ptr<CurrentProcessingRankId> &value) {
  if (!serialize_tag(out, 201, 0, 5))
    return false;
  if (!String_ser(out, value->dst))
    return false;
  if (!Int_ser(out, value->iterationId))
    return false;
  if (!Int_ser(out, value->channelId))
    return false;
  if (!Int_ser(out, value->numChannels))
    return false;
  if (!List_List_Int_ser(out, value->replicaGroup))
    return false;
  return true;
}

bool Send_ser(FILE *out, const Ptr<Send> &value) {
  if (!serialize_tag(out, 202, 0, 3))
    return false;
  if (!AluOp_ser(out, value->op))
    return false;
  if (!List_TensorRef_ser(out, value->srcs))
    return false;
  if (!Int_ser(out, value->peerId))
    return false;
  return true;
}

bool Recv_ser(FILE *out, const Ptr<Recv> &value) {
  if (!serialize_tag(out, 203, 0, 4))
    return false;
  if (!AluOp_ser(out, value->op))
    return false;
  if (!List_TensorRef_ser(out, value->dsts))
    return false;
  if (!List_Int_ser(out, value->replicaGroups))
    return false;
  if (!Int_ser(out, value->peerId))
    return false;
  return true;
}

bool BrCmpOp_ser(FILE *out, const BrCmpOp &value) {
  u8 tag_val = 0;
  switch (value) {
  case BrCmpOp::always:
    tag_val = 0;
    break;
  case BrCmpOp::lt_imm:
    tag_val = 1;
    break;
  case BrCmpOp::le_imm:
    tag_val = 2;
    break;
  case BrCmpOp::eq_imm:
    tag_val = 3;
    break;
  case BrCmpOp::ne_imm:
    tag_val = 4;
    break;
  case BrCmpOp::ge_imm:
    tag_val = 5;
    break;
  case BrCmpOp::gt_imm:
    tag_val = 6;
    break;
  case BrCmpOp::lt_reg:
    tag_val = 7;
    break;
  case BrCmpOp::le_reg:
    tag_val = 8;
    break;
  case BrCmpOp::eq_reg:
    tag_val = 9;
    break;
  case BrCmpOp::ne_reg:
    tag_val = 10;
    break;
  case BrCmpOp::ge_reg:
    tag_val = 11;
    break;
  case BrCmpOp::gt_reg:
    tag_val = 12;
    break;
  default:
    return false;
  }
  return serialize_tag(out, 189, tag_val, 0);
}

bool TensorLoad_ser(FILE *out, const Ptr<TensorLoad> &value) {
  if (!serialize_tag(out, 190, 0, 2))
    return false;
  if (!String_ser(out, value->dst))
    return false;
  if (!TensorRef_ser(out, value->src))
    return false;
  return true;
}

bool TensorStore_ser(FILE *out, const Ptr<TensorStore> &value) {
  if (!serialize_tag(out, 191, 0, 2))
    return false;
  if (!TensorRef_ser(out, value->dst))
    return false;
  if (!String_ser(out, value->src))
    return false;
  return true;
}

bool RegisterMove_ser(FILE *out, const Ptr<RegisterMove> &value) {
  if (!serialize_tag(out, 192, 0, 2))
    return false;
  if (!String_ser(out, value->dst))
    return false;
  if (!Int_ser(out, value->imm))
    return false;
  return true;
}

bool CmpBranch_ser(FILE *out, const Ptr<CmpBranch> &value) {
  if (!serialize_tag(out, 193, 0, 6))
    return false;
  if (!String_ser(out, value->reg1))
    return false;
  if (!String_ser(out, value->reg2))
    return false;
  if (!Int_ser(out, value->imm))
    return false;
  if (!BrCmpOp_ser(out, value->op))
    return false;
  if (!String_ser(out, value->trueLabel))
    return false;
  if (!String_ser(out, value->falseLabel))
    return false;
  return true;
}

bool RegisterAluOp_ser(FILE *out, const Ptr<RegisterAluOp> &value) {
  if (!serialize_tag(out, 194, 0, 4))
    return false;
  if (!String_ser(out, value->dst))
    return false;
  if (!String_ser(out, value->src))
    return false;
  if (!Int_ser(out, value->imm))
    return false;
  if (!AluOp_ser(out, value->op))
    return false;
  return true;
}

bool CoreBarrier_ser(FILE *out, const Ptr<CoreBarrier> &value) {
  if (!serialize_tag(out, 204, 0, 3))
    return false;
  if (!TensorRef_ser(out, value->data))
    return false;
  if (!List_Int_ser(out, value->cores))
    return false;
  if (!Engine_ser(out, value->engine))
    return false;
  return true;
}

bool Rng_ser(FILE *out, const Ptr<Rng> &value) {
  if (!serialize_tag(out, 205, 0, 2))
    return false;
  if (!TensorRef_ser(out, value->dst))
    return false;
  if (!Engine_ser(out, value->engine))
    return false;
  return true;
}

bool Rand2_ser(FILE *out, const Ptr<Rand2> &value) {
  if (!serialize_tag(out, 206, 0, 3))
    return false;
  if (!TensorRef_ser(out, value->dst))
    return false;
  if (!Operand_ser(out, value->min))
    return false;
  if (!Operand_ser(out, value->max))
    return false;
  return true;
}

bool RandGetState_ser(FILE *out, const Ptr<RandGetState> &value) {
  if (!serialize_tag(out, 207, 0, 2))
    return false;
  if (!TensorRef_ser(out, value->dst))
    return false;
  if (!Engine_ser(out, value->engine))
    return false;
  return true;
}

bool SetRngSeed_ser(FILE *out, const Ptr<SetRngSeed> &value) {
  if (!serialize_tag(out, 208, 0, 1))
    return false;
  if (!TensorRef_ser(out, value->src))
    return false;
  return true;
}

bool RandSetState_ser(FILE *out, const Ptr<RandSetState> &value) {
  if (!serialize_tag(out, 209, 0, 2))
    return false;
  if (!TensorRef_ser(out, value->src))
    return false;
  if (!Engine_ser(out, value->engine))
    return false;
  return true;
}

bool ExtendedInst_ser(FILE *out, const Ptr<ExtendedInst> &value) {
  if (!serialize_tag(out, 210, 0, 6))
    return false;
  if (!Nat_ser(out, value->opcode))
    return false;
  if (!Bool_ser(out, value->hasRead))
    return false;
  if (!Bool_ser(out, value->hasWrite))
    return false;
  if (!Nat_ser(out, value->ports))
    return false;
  if (!List_Nat_ser(out, value->data0))
    return false;
  if (!List_Nat_ser(out, value->data1))
    return false;
  return true;
}

bool TensorScalarCumulative_ser(FILE *out,
                                const Ptr<TensorScalarCumulative> &value) {
  if (!serialize_tag(out, 211, 0, 9))
    return false;
  if (!TensorRef_ser(out, value->dst))
    return false;
  if (!TensorRef_ser(out, value->src))
    return false;
  if (!AluOp_ser(out, value->op0))
    return false;
  if (!AluOp_ser(out, value->op1))
    return false;
  if (!Operand_ser(out, value->imm0))
    return false;
  if (!Option_Operand_ser(out, value->imm1))
    return false;
  if (!AccumCmd_ser(out, value->reduceCmd))
    return false;
  if (!TensorScalarReverseOps_ser(out, value->reverse))
    return false;
  if (!Option_Dtype_ser(out, value->dtype))
    return false;
  return true;
}

bool NcNGather_ser(FILE *out, const Ptr<NcNGather> &value) {
  if (!serialize_tag(out, 212, 0, 4))
    return false;
  if (!TensorRef_ser(out, value->dst))
    return false;
  if (!TensorRef_ser(out, value->data))
    return false;
  if (!TensorRef_ser(out, value->indices))
    return false;
  if (!Option_Dtype_ser(out, value->dtype))
    return false;
  return true;
}

bool NonzeroWithCount_ser(FILE *out, const Ptr<NonzeroWithCount> &value) {
  if (!serialize_tag(out, 213, 0, 4))
    return false;
  if (!TensorRef_ser(out, value->dst))
    return false;
  if (!TensorRef_ser(out, value->src))
    return false;
  if (!Immediate_ser(out, value->indexOffset))
    return false;
  if (!Immediate_ser(out, value->paddingVal))
    return false;
  return true;
}

bool PrintOutputBuffer_ser(FILE *out, const PrintOutputBuffer &value) {
  u8 tag_val = 0;
  switch (value) {
  case PrintOutputBuffer::stdout:
    tag_val = 0;
    break;
  case PrintOutputBuffer::stderr:
    tag_val = 1;
    break;
  default:
    return false;
  }
  return serialize_tag(out, 214, tag_val, 0);
}

bool DevicePrint_ser(FILE *out, const Ptr<DevicePrint> &value) {
  if (!serialize_tag(out, 215, 0, 3))
    return false;
  if (!TensorRef_ser(out, value->src))
    return false;
  if (!String_ser(out, value->printPrefix))
    return false;
  if (!PrintOutputBuffer_ser(out, value->buffer))
    return false;
  return true;
}

bool Exponential_ser(FILE *out, const Ptr<Exponential> &value) {
  if (!serialize_tag(out, 216, 0, 5))
    return false;
  if (!TensorRef_ser(out, value->dst))
    return false;
  if (!TensorRef_ser(out, value->src))
    return false;
  if (!Operand_ser(out, value->maxValue))
    return false;
  if (!AccumCmd_ser(out, value->reducecmd))
    return false;
  if (!Operand_ser(out, value->ReduceInit))
    return false;
  return true;
}

bool Operator_ser(FILE *out, const Ptr<Operator> &value) {
  u8 tag_val = 0;
  u8 field_count = 1; // All variants have exactly 1 field

  // Map Operator tags to their serialization case numbers
  switch (value->tag) {
  case Operator::Tag::activate:
    tag_val = 0;
    field_count = 1;
    break;
  case Operator::Tag::ncActivate:
    tag_val = 1;
    field_count = 1;
    break;
  case Operator::Tag::activationReduce:
    tag_val = 2;
    field_count = 1;
    break;
  case Operator::Tag::affineSelect:
    tag_val = 3;
    field_count = 1;
    break;
  case Operator::Tag::ncAffineSelect:
    tag_val = 4;
    field_count = 1;
    break;
  case Operator::Tag::batchNormAggregate:
    tag_val = 5;
    field_count = 1;
    break;
  case Operator::Tag::batchNormStats:
    tag_val = 6;
    field_count = 1;
    break;
  case Operator::Tag::copy:
    tag_val = 7;
    field_count = 1;
    break;
  case Operator::Tag::ncCopy:
    tag_val = 8;
    field_count = 1;
    break;
  case Operator::Tag::copyPredicated:
    tag_val = 9;
    field_count = 1;
    break;
  case Operator::Tag::dmaCopy:
    tag_val = 10;
    field_count = 1;
    break;
  case Operator::Tag::ncDmaCopy:
    tag_val = 11;
    field_count = 1;
    break;
  case Operator::Tag::dmaTranspose:
    tag_val = 12;
    field_count = 1;
    break;
  case Operator::Tag::dropout:
    tag_val = 13;
    field_count = 1;
    break;
  case Operator::Tag::findIndex8:
    tag_val = 14;
    field_count = 1;
    break;
  case Operator::Tag::iota:
    tag_val = 15;
    field_count = 1;
    break;
  case Operator::Tag::loadMaskRegister:
    tag_val = 16;
    field_count = 1;
    break;
  case Operator::Tag::loadStationary:
    tag_val = 17;
    field_count = 1;
    break;
  case Operator::Tag::localGather:
    tag_val = 18;
    field_count = 1;
    break;
  case Operator::Tag::ncLocalGather:
    tag_val = 19;
    field_count = 1;
    break;
  case Operator::Tag::matMul:
    tag_val = 20;
    field_count = 1;
    break;
  case Operator::Tag::ncMatMul:
    tag_val = 21;
    field_count = 1;
    break;
  case Operator::Tag::matchReplace8:
    tag_val = 22;
    field_count = 1;
    break;
  case Operator::Tag::matchValueLoad:
    tag_val = 23;
    field_count = 1;
    break;
  case Operator::Tag::max8:
    tag_val = 24;
    field_count = 1;
    break;
  case Operator::Tag::memSet:
    tag_val = 25;
    field_count = 1;
    break;
  case Operator::Tag::rangeSelect:
    tag_val = 26;
    field_count = 1;
    break;
  case Operator::Tag::ncRangeSelect:
    tag_val = 27;
    field_count = 1;
    break;
  case Operator::Tag::reciprocal:
    tag_val = 28;
    field_count = 1;
    break;
  case Operator::Tag::scalarTensorTensor:
    tag_val = 29;
    field_count = 1;
    break;
  case Operator::Tag::ncScalarTensorTensor:
    tag_val = 30;
    field_count = 1;
    break;
  case Operator::Tag::shuffle:
    tag_val = 31;
    field_count = 1;
    break;
  case Operator::Tag::tensorReduce:
    tag_val = 32;
    field_count = 1;
    break;
  case Operator::Tag::tensorScalar:
    tag_val = 33;
    field_count = 1;
    break;
  case Operator::Tag::tensorTensor:
    tag_val = 34;
    field_count = 1;
    break;
  case Operator::Tag::tensorTensorScan:
    tag_val = 35;
    field_count = 1;
    break;
  case Operator::Tag::tensorPartitionReduce:
    tag_val = 36;
    field_count = 1;
    break;
  case Operator::Tag::tensorScalarReduce:
    tag_val = 37;
    field_count = 1;
    break;
  case Operator::Tag::transpose:
    tag_val = 38;
    field_count = 1;
    break;
  case Operator::Tag::selectReduce:
    tag_val = 39;
    field_count = 1;
    break;
  case Operator::Tag::sequenceBounds:
    tag_val = 40;
    field_count = 1;
    break;
  case Operator::Tag::sendRecv:
    tag_val = 41;
    field_count = 1;
    break;
  case Operator::Tag::sendRecvCompute:
    tag_val = 42;
    field_count = 1;
    break;
  case Operator::Tag::tensorLoad:
    tag_val = 43;
    field_count = 1;
    break;
  case Operator::Tag::tensorStore:
    tag_val = 44;
    field_count = 1;
    break;
  case Operator::Tag::registerMove:
    tag_val = 45;
    field_count = 1;
    break;
  case Operator::Tag::cmpBranch:
    tag_val = 46;
    field_count = 1;
    break;
  case Operator::Tag::registerAluOp:
    tag_val = 47;
    field_count = 1;
    break;
  case Operator::Tag::quantizeMX:
    tag_val = 48;
    field_count = 1;
    break;
  case Operator::Tag::ncMatMulMX:
    tag_val = 49;
    field_count = 1;
    break;
  case Operator::Tag::dmaCompute:
    tag_val = 50;
    field_count = 1;
    break;
  case Operator::Tag::allReduce:
    tag_val = 51;
    field_count = 1;
    break;
  case Operator::Tag::allGather:
    tag_val = 52;
    field_count = 1;
    break;
  case Operator::Tag::reduceScatter:
    tag_val = 53;
    field_count = 1;
    break;
  case Operator::Tag::collectivePermute:
    tag_val = 54;
    field_count = 1;
    break;
  case Operator::Tag::collectivePermuteImplicit:
    tag_val = 55;
    field_count = 1;
    break;
  case Operator::Tag::collectivePermuteImplicitReduce:
    tag_val = 56;
    field_count = 1;
    break;
  case Operator::Tag::broadcast:
    tag_val = 57;
    field_count = 1;
    break;
  case Operator::Tag::allToAll:
    tag_val = 58;
    field_count = 1;
    break;
  case Operator::Tag::rankId:
    tag_val = 59;
    field_count = 1;
    break;
  case Operator::Tag::currentProcessingRankId:
    tag_val = 60;
    field_count = 1;
    break;
  case Operator::Tag::send:
    tag_val = 61;
    field_count = 1;
    break;
  case Operator::Tag::recv:
    tag_val = 62;
    field_count = 1;
    break;
  case Operator::Tag::coreBarrier:
    tag_val = 63;
    field_count = 1;
    break;
  case Operator::Tag::rng:
    tag_val = 64;
    field_count = 1;
    break;
  case Operator::Tag::rand2:
    tag_val = 65;
    field_count = 1;
    break;
  case Operator::Tag::randGetState:
    tag_val = 66;
    field_count = 1;
    break;
  case Operator::Tag::setRngSeed:
    tag_val = 67;
    field_count = 1;
    break;
  case Operator::Tag::randSetState:
    tag_val = 68;
    field_count = 1;
    break;
  case Operator::Tag::extendedInst:
    tag_val = 69;
    field_count = 1;
    break;
  case Operator::Tag::tensorScalarCumulative:
    tag_val = 70;
    field_count = 1;
    break;
  case Operator::Tag::ncNGather:
    tag_val = 71;
    field_count = 1;
    break;
  case Operator::Tag::nonzeroWithCount:
    tag_val = 72;
    field_count = 1;
    break;
  case Operator::Tag::devicePrint:
    tag_val = 73;
    field_count = 1;
    break;
  case Operator::Tag::exponential:
    tag_val = 74;
    field_count = 1;
    break;
  default:
    throw std::runtime_error("Unknown Operator type in serialization");
    return false;
  }

  // Serialize the tag
  if (!serialize_tag(out, 217, tag_val, field_count))
    return false;

  // Serialize the fields based on the specific variant
  switch (value->tag) {
  case Operator::Tag::activate: {
    auto *typed_value =
        static_cast<const OperatorActivateWrapper *>(value.get());
    return Activate_ser(out, typed_value->op);
  }
  case Operator::Tag::ncActivate: {
    auto *typed_value =
        static_cast<const OperatorNcActivateWrapper *>(value.get());
    return NcActivate_ser(out, typed_value->op);
  }
  case Operator::Tag::activationReduce: {
    auto *typed_value =
        static_cast<const OperatorActivationReduceWrapper *>(value.get());
    return NcActivate_ser(out, typed_value->op);
  }
  case Operator::Tag::affineSelect: {
    auto *typed_value =
        static_cast<const OperatorAffineSelectWrapper *>(value.get());
    return AffineSelect_ser(out, typed_value->op);
  }
  case Operator::Tag::ncAffineSelect: {
    auto *typed_value =
        static_cast<const OperatorNcAffineSelectWrapper *>(value.get());
    return NcAffineSelect_ser(out, typed_value->op);
  }
  case Operator::Tag::batchNormAggregate: {
    auto *typed_value =
        static_cast<const OperatorBatchNormAggregateWrapper *>(value.get());
    return BatchNormAggregate_ser(out, typed_value->op);
  }
  case Operator::Tag::batchNormStats: {
    auto *typed_value =
        static_cast<const OperatorBatchNormStatsWrapper *>(value.get());
    return BatchNormStats_ser(out, typed_value->op);
  }
  case Operator::Tag::copy: {
    auto *typed_value = static_cast<const OperatorCopyWrapper *>(value.get());
    return Copy_ser(out, typed_value->op);
  }
  case Operator::Tag::ncCopy: {
    auto *typed_value = static_cast<const OperatorNcCopyWrapper *>(value.get());
    return NcCopy_ser(out, typed_value->op);
  }
  case Operator::Tag::copyPredicated: {
    auto *typed_value =
        static_cast<const OperatorCopyPredicatedWrapper *>(value.get());
    return CopyPredicated_ser(out, typed_value->op);
  }
  case Operator::Tag::dmaCopy: {
    auto *typed_value =
        static_cast<const OperatorDmaCopyWrapper *>(value.get());
    return DmaCopy_ser(out, typed_value->op);
  }
  case Operator::Tag::ncDmaCopy: {
    auto *typed_value =
        static_cast<const OperatorNcDmaCopyWrapper *>(value.get());
    return NcDmaCopy_ser(out, typed_value->op);
  }
  case Operator::Tag::dmaTranspose: {
    auto *typed_value =
        static_cast<const OperatorDmaTransposeWrapper *>(value.get());
    return DmaTranspose_ser(out, typed_value->op);
  }
  case Operator::Tag::dropout: {
    auto *typed_value =
        static_cast<const OperatorDropoutWrapper *>(value.get());
    return Dropout_ser(out, typed_value->op);
  }
  case Operator::Tag::findIndex8: {
    auto *typed_value =
        static_cast<const OperatorFindIndex8Wrapper *>(value.get());
    return FindIndex8_ser(out, typed_value->op);
  }
  case Operator::Tag::iota: {
    auto *typed_value = static_cast<const OperatorIotaWrapper *>(value.get());
    return Iota_ser(out, typed_value->op);
  }
  case Operator::Tag::loadMaskRegister: {
    auto *typed_value =
        static_cast<const OperatorLoadMaskRegisterWrapper *>(value.get());
    return LoadMaskRegister_ser(out, typed_value->op);
  }
  case Operator::Tag::loadStationary: {
    auto *typed_value =
        static_cast<const OperatorLoadStationaryWrapper *>(value.get());
    return LoadStationary_ser(out, typed_value->op);
  }
  case Operator::Tag::localGather: {
    auto *typed_value =
        static_cast<const OperatorLocalGatherWrapper *>(value.get());
    return LocalGather_ser(out, typed_value->op);
  }
  case Operator::Tag::ncLocalGather: {
    auto *typed_value =
        static_cast<const OperatorNcLocalGatherWrapper *>(value.get());
    return NcLocalGather_ser(out, typed_value->op);
  }
  case Operator::Tag::matMul: {
    auto *typed_value = static_cast<const OperatorMatMulWrapper *>(value.get());
    return MatMul_ser(out, typed_value->op);
  }
  case Operator::Tag::ncMatMul: {
    auto *typed_value =
        static_cast<const OperatorNcMatMulWrapper *>(value.get());
    return NcMatMul_ser(out, typed_value->op);
  }
  case Operator::Tag::matchReplace8: {
    auto *typed_value =
        static_cast<const OperatorMatchReplace8Wrapper *>(value.get());
    return MatchReplace8_ser(out, typed_value->op);
  }
  case Operator::Tag::matchValueLoad: {
    auto *typed_value =
        static_cast<const OperatorMatchValueLoadWrapper *>(value.get());
    return MatchValueLoad_ser(out, typed_value->op);
  }
  case Operator::Tag::max8: {
    auto *typed_value = static_cast<const OperatorMax8Wrapper *>(value.get());
    return Max8_ser(out, typed_value->op);
  }
  case Operator::Tag::memSet: {
    auto *typed_value = static_cast<const OperatorMemSetWrapper *>(value.get());
    return MemSet_ser(out, typed_value->op);
  }
  case Operator::Tag::rangeSelect: {
    auto *typed_value =
        static_cast<const OperatorRangeSelectWrapper *>(value.get());
    return RangeSelect_ser(out, typed_value->op);
  }
  case Operator::Tag::ncRangeSelect: {
    auto *typed_value =
        static_cast<const OperatorNcRangeSelectWrapper *>(value.get());
    return NcRangeSelect_ser(out, typed_value->op);
  }
  case Operator::Tag::reciprocal: {
    auto *typed_value =
        static_cast<const OperatorReciprocalWrapper *>(value.get());
    return Reciprocal_ser(out, typed_value->op);
  }
  case Operator::Tag::scalarTensorTensor: {
    auto *typed_value =
        static_cast<const OperatorScalarTensorTensorWrapper *>(value.get());
    return ScalarTensorTensor_ser(out, typed_value->op);
  }
  case Operator::Tag::ncScalarTensorTensor: {
    auto *typed_value =
        static_cast<const OperatorNcScalarTensorTensorWrapper *>(value.get());
    return NcScalarTensorTensor_ser(out, typed_value->op);
  }
  case Operator::Tag::shuffle: {
    auto *typed_value =
        static_cast<const OperatorShuffleWrapper *>(value.get());
    return Shuffle_ser(out, typed_value->op);
  }
  case Operator::Tag::tensorReduce: {
    auto *typed_value =
        static_cast<const OperatorTensorReduceWrapper *>(value.get());
    return TensorReduce_ser(out, typed_value->op);
  }
  case Operator::Tag::tensorScalar: {
    auto *typed_value =
        static_cast<const OperatorTensorScalarWrapper *>(value.get());
    return TensorScalar_ser(out, typed_value->op);
  }
  case Operator::Tag::tensorTensor: {
    auto *typed_value =
        static_cast<const OperatorTensorTensorWrapper *>(value.get());
    return TensorTensor_ser(out, typed_value->op);
  }
  case Operator::Tag::tensorTensorScan: {
    auto *typed_value =
        static_cast<const OperatorTensorTensorScanWrapper *>(value.get());
    return TensorTensorScan_ser(out, typed_value->op);
  }
  case Operator::Tag::tensorPartitionReduce: {
    auto *typed_value =
        static_cast<const OperatorTensorPartitionReduceWrapper *>(value.get());
    return TensorPartitionReduce_ser(out, typed_value->op);
  }
  case Operator::Tag::tensorScalarReduce: {
    auto *typed_value =
        static_cast<const OperatorTensorScalarReduceWrapper *>(value.get());
    return TensorScalarReduce_ser(out, typed_value->op);
  }
  case Operator::Tag::transpose: {
    auto *typed_value =
        static_cast<const OperatorTransposeWrapper *>(value.get());
    return Transpose_ser(out, typed_value->op);
  }
  case Operator::Tag::selectReduce: {
    auto *typed_value =
        static_cast<const OperatorSelectReduceWrapper *>(value.get());
    return SelectReduce_ser(out, typed_value->op);
  }
  case Operator::Tag::sequenceBounds: {
    auto *typed_value =
        static_cast<const OperatorSequenceBoundsWrapper *>(value.get());
    return SequenceBounds_ser(out, typed_value->op);
  }
  case Operator::Tag::sendRecv: {
    auto *typed_value =
        static_cast<const OperatorSendRecvWrapper *>(value.get());
    return SendRecv_ser(out, typed_value->op);
  }
  case Operator::Tag::sendRecvCompute: {
    auto *typed_value =
        static_cast<const OperatorSendRecvComputeWrapper *>(value.get());
    return SendRecvCompute_ser(out, typed_value->op);
  }
  case Operator::Tag::tensorLoad: {
    auto *typed_value =
        static_cast<const OperatorTensorLoadWrapper *>(value.get());
    return TensorLoad_ser(out, typed_value->op);
  }
  case Operator::Tag::tensorStore: {
    auto *typed_value =
        static_cast<const OperatorTensorStoreWrapper *>(value.get());
    return TensorStore_ser(out, typed_value->op);
  }
  case Operator::Tag::registerMove: {
    auto *typed_value =
        static_cast<const OperatorRegisterMoveWrapper *>(value.get());
    return RegisterMove_ser(out, typed_value->op);
  }
  case Operator::Tag::cmpBranch: {
    auto *typed_value =
        static_cast<const OperatorCmpBranchWrapper *>(value.get());
    return CmpBranch_ser(out, typed_value->op);
  }
  case Operator::Tag::registerAluOp: {
    auto *typed_value =
        static_cast<const OperatorRegisterAluOpWrapper *>(value.get());
    return RegisterAluOp_ser(out, typed_value->op);
  }
  case Operator::Tag::quantizeMX: {
    auto *typed_value =
        static_cast<const OperatorQuantizeMXWrapper *>(value.get());
    return QuantizeMX_ser(out, typed_value->op);
  }
  case Operator::Tag::ncMatMulMX: {
    auto *typed_value =
        static_cast<const OperatorNcMatMulMXWrapper *>(value.get());
    return MatMulMX_ser(out, typed_value->op);
  }
  case Operator::Tag::dmaCompute: {
    auto *typed_value =
        static_cast<const OperatorDmaComputeWrapper *>(value.get());
    return DmaCompute_ser(out, typed_value->op);
  }
  case Operator::Tag::allReduce: {
    auto *typed_value =
        static_cast<const OperatorAllReduceWrapper *>(value.get());
    return CollectiveOp_ser(out, typed_value->op);
  }
  case Operator::Tag::allGather: {
    auto *typed_value =
        static_cast<const OperatorAllGatherWrapper *>(value.get());
    return CollectiveOp_ser(out, typed_value->op);
  }
  case Operator::Tag::reduceScatter: {
    auto *typed_value =
        static_cast<const OperatorReduceScatterWrapper *>(value.get());
    return CollectiveOp_ser(out, typed_value->op);
  }
  case Operator::Tag::collectivePermute: {
    auto *typed_value =
        static_cast<const OperatorCollectivePermuteWrapper *>(value.get());
    return CollectiveOp_ser(out, typed_value->op);
  }
  case Operator::Tag::collectivePermuteImplicit: {
    auto *typed_value =
        static_cast<const OperatorCollectivePermuteImplicitWrapper *>(
            value.get());
    return CollectiveOp_ser(out, typed_value->op);
  }
  case Operator::Tag::collectivePermuteImplicitReduce: {
    auto *typed_value =
        static_cast<const OperatorCollectivePermuteImplicitReduceWrapper *>(
            value.get());
    return CollectiveOp_ser(out, typed_value->op);
  }
  case Operator::Tag::broadcast: {
    auto *typed_value =
        static_cast<const OperatorBroadcastWrapper *>(value.get());
    return CollectiveOp_ser(out, typed_value->op);
  }
  case Operator::Tag::allToAll: {
    auto *typed_value =
        static_cast<const OperatorAllToAllWrapper *>(value.get());
    return CollectiveOp_ser(out, typed_value->op);
  }
  case Operator::Tag::rankId: {
    auto *typed_value = static_cast<const OperatorRankIdWrapper *>(value.get());
    return RankId_ser(out, typed_value->op);
  }
  case Operator::Tag::currentProcessingRankId: {
    auto *typed_value =
        static_cast<const OperatorCurrentProcessingRankIdWrapper *>(
            value.get());
    return CurrentProcessingRankId_ser(out, typed_value->op);
  }
  case Operator::Tag::send: {
    auto *typed_value = static_cast<const OperatorSendWrapper *>(value.get());
    return Send_ser(out, typed_value->op);
  }
  case Operator::Tag::recv: {
    auto *typed_value = static_cast<const OperatorRecvWrapper *>(value.get());
    return Recv_ser(out, typed_value->op);
  }
  case Operator::Tag::coreBarrier: {
    auto *typed_value =
        static_cast<const OperatorCoreBarrierWrapper *>(value.get());
    return CoreBarrier_ser(out, typed_value->op);
  }
  case Operator::Tag::rng: {
    auto *typed_value = static_cast<const OperatorRngWrapper *>(value.get());
    return Rng_ser(out, typed_value->op);
  }
  case Operator::Tag::rand2: {
    auto *typed_value = static_cast<const OperatorRand2Wrapper *>(value.get());
    return Rand2_ser(out, typed_value->op);
  }
  case Operator::Tag::randGetState: {
    auto *typed_value =
        static_cast<const OperatorRandGetStateWrapper *>(value.get());
    return RandGetState_ser(out, typed_value->op);
  }
  case Operator::Tag::setRngSeed: {
    auto *typed_value =
        static_cast<const OperatorSetRngSeedWrapper *>(value.get());
    return SetRngSeed_ser(out, typed_value->op);
  }
  case Operator::Tag::randSetState: {
    auto *typed_value =
        static_cast<const OperatorRandSetStateWrapper *>(value.get());
    return RandSetState_ser(out, typed_value->op);
  }
  case Operator::Tag::extendedInst: {
    auto *typed_value =
        static_cast<const OperatorExtendedInstWrapper *>(value.get());
    return ExtendedInst_ser(out, typed_value->op);
  }
  case Operator::Tag::tensorScalarCumulative: {
    auto *typed_value =
        static_cast<const OperatorTensorScalarCumulativeWrapper *>(value.get());
    return TensorScalarCumulative_ser(out, typed_value->op);
  }
  case Operator::Tag::ncNGather: {
    auto *typed_value =
        static_cast<const OperatorNcNGatherWrapper *>(value.get());
    return NcNGather_ser(out, typed_value->op);
  }
  case Operator::Tag::nonzeroWithCount: {
    auto *typed_value =
        static_cast<const OperatorNonzeroWithCountWrapper *>(value.get());
    return NonzeroWithCount_ser(out, typed_value->op);
  }
  case Operator::Tag::devicePrint: {
    auto *typed_value =
        static_cast<const OperatorDevicePrintWrapper *>(value.get());
    return DevicePrint_ser(out, typed_value->op);
  }
  case Operator::Tag::exponential: {
    auto *typed_value =
        static_cast<const OperatorExponentialWrapper *>(value.get());
    return Exponential_ser(out, typed_value->op);
  }
  default:
    throw std::runtime_error("Unknown Operator type in serialization");
    return false;
  }
}

bool Stmt_ser(FILE *out, const Ptr<Stmt> &value) {
  u8 tag_val = 0;
  u8 field_count = 1; // All variants have exactly 1 field

  // Map Stmt tags to their serialization case numbers
  switch (value->tag) {
  case Stmt::Tag::oper:
    tag_val = 0;
    field_count = 3;
    break;
  default:
    throw std::runtime_error("Unknown Stmt type in serialization");
    return false;
  }

  // Serialize the tag
  if (!serialize_tag(out, 103, tag_val, field_count))
    return false;

  // Serialize the fields based on the specific variant
  switch (value->tag) {
  case Stmt::Tag::oper: {
    auto *typed_value = static_cast<const StmtOperWrapper *>(value.get());
    if (!Operator_ser(out, typed_value->op))
      return false;
    if (!Option_String_ser(out, typed_value->name))
      return false;
    return Pos_ser(out, typed_value->pos);
  }
  default:
    throw std::runtime_error("Unknown Stmt type in serialization");
    return false;
  }
}

bool Block_ser(FILE *out, const Ptr<Block> &value) {
  if (!serialize_tag(out, 104, 0, 2))
    return false;
  if (!String_ser(out, value->label))
    return false;
  if (!List_Stmt_ser(out, value->body))
    return false;
  return true;
}

bool Kernel_ser(FILE *out, const Ptr<Kernel> &value) {
  if (!serialize_tag(out, 105, 0, 4))
    return false;
  if (!String_ser(out, value->name))
    return false;
  if (!List_TensorName_ser(out, value->inputs))
    return false;
  if (!List_TensorName_ser(out, value->outputs))
    return false;
  if (!List_Block_ser(out, value->body))
    return false;
  return true;
}

bool SharedConstantFile_ser(FILE *out, const Ptr<SharedConstantFile> &value) {
  if (!serialize_tag(out, 106, 0, 2))
    return false;
  if (!String_ser(out, value->name))
    return false;
  if (!String_ser(out, value->fileName))
    return false;
  return true;
}

bool Edges_ser(FILE *out, const Ptr<Edges> &value) {
  if (!serialize_tag(out, 107, 0, 2))
    return false;
  if (!String_ser(out, value->fromEdge))
    return false;
  if (!List_String_ser(out, value->toEdges))
    return false;
  return true;
}

bool LncKernel_ser(FILE *out, const Ptr<LncKernel> &value) {
  if (!serialize_tag(out, 108, 0, 7))
    return false;
  if (!String_ser(out, value->name))
    return false;
  if (!List_TensorName_ser(out, value->inputs))
    return false;
  if (!List_TensorName_ser(out, value->outputs))
    return false;
  if (!List_List_Block_ser(out, value->bodies))
    return false;
  if (!List_SharedConstantFile_ser(out, value->sharedConstants))
    return false;
  if (!List_TensorName_ser(out, value->sharedBuffers))
    return false;
  if (!List_Edges_ser(out, value->edges))
    return false;
  return true;
}

bool List_Index_ser(FILE *out, const List<Ptr<Index>> &value) {
  if (!serialize_array_start(out, value.size()))
    return false;

  for (const auto &item : value) {
    if (!Index_ser(out, item))
      return false;
  }
  return true;
}

bool List_APPair_ser(FILE *out, const List<Ptr<APPair>> &value) {
  if (!serialize_array_start(out, value.size()))
    return false;

  for (const auto &item : value) {
    if (!APPair_ser(out, item))
      return false;
  }
  return true;
}

bool Option_ScalarOffset_ser(FILE *out,
                             const Option<Ptr<ScalarOffset>> &value) {
  if (!serialize_option(out, value.has_value()))
    return false;

  if (value.has_value()) {
    return ScalarOffset_ser(out, value.value());
  }
  return true;
}

bool Option_Access_ser(FILE *out, const Option<Ptr<Access>> &value) {
  if (!serialize_option(out, value.has_value()))
    return false;

  if (value.has_value()) {
    return Access_ser(out, value.value());
  }
  return true;
}

bool Option_Dtype_ser(FILE *out, const Option<Dtype> &value) {
  if (!serialize_option(out, value.has_value()))
    return false;

  if (value.has_value()) {
    return Dtype_ser(out, value.value());
  }
  return true;
}

bool List_Immediate_ser(FILE *out, const List<Ptr<Immediate>> &value) {
  if (!serialize_array_start(out, value.size()))
    return false;

  for (const auto &item : value) {
    if (!Immediate_ser(out, item))
      return false;
  }
  return true;
}

bool Option_TensorRef_ser(FILE *out, const Option<Ptr<TensorRef>> &value) {
  if (!serialize_option(out, value.has_value()))
    return false;

  if (value.has_value()) {
    return TensorRef_ser(out, value.value());
  }
  return true;
}

bool Option_TensorSubDim_ser(FILE *out, const Option<TensorSubDim> &value) {
  if (!serialize_option(out, value.has_value()))
    return false;

  if (value.has_value()) {
    return TensorSubDim_ser(out, value.value());
  }
  return true;
}

bool Option_Operand_ser(FILE *out, const Option<Ptr<Operand>> &value) {
  if (!serialize_option(out, value.has_value()))
    return false;

  if (value.has_value()) {
    return Operand_ser(out, value.value());
  }
  return true;
}

bool Option_AluOp_ser(FILE *out, const Option<AluOp> &value) {
  if (!serialize_option(out, value.has_value()))
    return false;

  if (value.has_value()) {
    return AluOp_ser(out, value.value());
  }
  return true;
}

bool Option_Immediate_ser(FILE *out, const Option<Ptr<Immediate>> &value) {
  if (!serialize_option(out, value.has_value()))
    return false;

  if (value.has_value()) {
    return Immediate_ser(out, value.value());
  }
  return true;
}

bool List_TensorRef_ser(FILE *out, const List<Ptr<TensorRef>> &value) {
  if (!serialize_array_start(out, value.size()))
    return false;

  for (const auto &item : value) {
    if (!TensorRef_ser(out, item))
      return false;
  }
  return true;
}

bool List_Stmt_ser(FILE *out, const List<Ptr<Stmt>> &value) {
  if (!serialize_array_start(out, value.size()))
    return false;

  for (const auto &item : value) {
    if (!Stmt_ser(out, item))
      return false;
  }
  return true;
}

bool List_TensorName_ser(FILE *out, const List<Ptr<TensorName>> &value) {
  if (!serialize_array_start(out, value.size()))
    return false;

  for (const auto &item : value) {
    if (!TensorName_ser(out, item))
      return false;
  }
  return true;
}

bool List_Block_ser(FILE *out, const List<Ptr<Block>> &value) {
  if (!serialize_array_start(out, value.size()))
    return false;

  for (const auto &item : value) {
    if (!Block_ser(out, item))
      return false;
  }
  return true;
}

bool List_List_Block_ser(FILE *out, const List<List<Ptr<Block>>> &value) {
  if (!serialize_array_start(out, value.size()))
    return false;

  for (const auto &item : value) {
    if (!List_Block_ser(out, item))
      return false;
  }
  return true;
}

bool List_SharedConstantFile_ser(FILE *out,
                                 const List<Ptr<SharedConstantFile>> &value) {
  if (!serialize_array_start(out, value.size()))
    return false;

  for (const auto &item : value) {
    if (!SharedConstantFile_ser(out, item))
      return false;
  }
  return true;
}

bool List_Edges_ser(FILE *out, const List<Ptr<Edges>> &value) {
  if (!serialize_array_start(out, value.size()))
    return false;

  for (const auto &item : value) {
    if (!Edges_ser(out, item))
      return false;
  }
  return true;
}

Ptr<Immediate> Immediate_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not read tag");
  if (t != 131)
    throw std::runtime_error("Unexpected type tag");
  switch (c) {
  case 0: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<ImmediateRegisterWrapper> x = ptr<ImmediateRegisterWrapper>();
    x->reg = Nat_des(in);
    return x;
    break;
  }
  case 1: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    Ptr<ImmediatePointerWrapper> x = ptr<ImmediatePointerWrapper>();
    return x;
    break;
  }
  case 2: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<ImmediateIntWrapper> x = ptr<ImmediateIntWrapper>();
    x->i = Int_des(in);
    return x;
    break;
  }
  case 3: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<ImmediateFloatWrapper> x = ptr<ImmediateFloatWrapper>();
    x->f = Float_des(in);
    return x;
    break;
  }
  default:
    throw std::runtime_error("Invalid value tag");
  }
}

Memory Memory_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not read tag");
  if (t != 110)
    throw std::runtime_error("Unexpected type tag");
  switch (c) {
  case 0: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return Memory::hbm;
    break;
  }
  case 1: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return Memory::sbuf;
    break;
  }
  case 2: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return Memory::psum;
    break;
  }
  case 3: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return Memory::reg;
    break;
  }
  case 4: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return Memory::shared_hbm;
    break;
  }
  case 5: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return Memory::private_hbm;
    break;
  }
  default:
    throw std::runtime_error("Invalid value tag");
  }
}

Dtype Dtype_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not read tag");
  if (t != 111)
    throw std::runtime_error("Unexpected type tag");
  switch (c) {
  case 0: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return Dtype::bfloat16;
    break;
  }
  case 1: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return Dtype::float8e3;
    break;
  }
  case 2: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return Dtype::float8e4;
    break;
  }
  case 3: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return Dtype::float8e5;
    break;
  }
  case 4: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return Dtype::float16;
    break;
  }
  case 5: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return Dtype::float32;
    break;
  }
  case 6: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return Dtype::float32r;
    break;
  }
  case 7: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return Dtype::int8;
    break;
  }
  case 8: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return Dtype::int16;
    break;
  }
  case 9: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return Dtype::int64;
    break;
  }
  case 10: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return Dtype::int32;
    break;
  }
  case 11: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return Dtype::uint8;
    break;
  }
  case 12: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return Dtype::uint16;
    break;
  }
  case 13: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return Dtype::uint32;
    break;
  }
  case 14: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return Dtype::uint64;
    break;
  }
  case 15: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return Dtype::float8_e4m3;
    break;
  }
  case 16: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return Dtype::float8_e4m3fn;
    break;
  }
  case 17: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return Dtype::float8_e5m2_x4;
    break;
  }
  case 18: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return Dtype::float8_e4m3fn_x4;
    break;
  }
  case 19: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return Dtype::float4_e2m1fn_x4;
    break;
  }
  default:
    throw std::runtime_error("Invalid value tag");
  }
}

Ptr<Shape> Shape_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting Shape:112,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 112 || c != 0 || l != 2) {
    std::ostringstream msg;
    msg << "Expecting Shape:(112,0,2)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<Shape> x = ptr<Shape>();
  x->parDim = Nat_des(in);
  x->freeDims = List_Nat_des(in);
  return x;
}

Ptr<Address> Address_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting Address:113,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 113 || c != 0 || l != 7) {
    std::ostringstream msg;
    msg << "Expecting Address:(113,0,7)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<Address> x = ptr<Address>();
  x->name = String_des(in);
  x->memory = Memory_des(in);
  x->parSize = Nat_des(in);
  x->freeSize = Nat_des(in);
  x->parOffset = Option_Nat_des(in);
  x->freeOffset = Option_Nat_des(in);
  x->isShared = Bool_des(in);
  return x;
}

Ptr<TensorName> TensorName_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting TensorName:114,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 114 || c != 0 || l != 8) {
    std::ostringstream msg;
    msg << "Expecting TensorName:(114,0,8)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<TensorName> x = ptr<TensorName>();
  x->name = String_des(in);
  x->dtype = Dtype_des(in);
  x->shape = Shape_des(in);
  x->address = Address_des(in);
  x->freeElements = Nat_des(in);
  x->parWF = Prop_des(in);
  x->freeWF = Prop_des(in);
  x->addressRotation = Bool_des(in);
  return x;
}

Ptr<Slice> Slice_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting Slice:115,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 115 || c != 0 || l != 4) {
    std::ostringstream msg;
    msg << "Expecting Slice:(115,0,4)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<Slice> x = ptr<Slice>();
  x->l = Nat_des(in);
  x->u = Nat_des(in);
  x->step = Int_des(in);
  x->wf = Prop_des(in);
  return x;
}

Ptr<Index> Index_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not read tag");
  if (t != 117)
    throw std::runtime_error("Unexpected type tag");
  switch (c) {
  case 0: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<IndexCoordWrapper> x = ptr<IndexCoordWrapper>();
    x->e = Nat_des(in);
    return x;
    break;
  }
  case 1: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<IndexSliceWrapper> x = ptr<IndexSliceWrapper>();
    x->slice = Slice_des(in);
    return x;
    break;
  }
  default:
    throw std::runtime_error("Invalid value tag");
  }
}

Ptr<AccessBasic> AccessBasic_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting AccessBasic:118,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 118 || c != 0 || l != 3) {
    std::ostringstream msg;
    msg << "Expecting AccessBasic:(118,0,3)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<AccessBasic> x = ptr<AccessBasic>();
  x->tensor = TensorName_des(in);
  x->indexes = List_Index_des(in);
  x->lenWF = Prop_des(in);
  return x;
}

Ptr<APPair> APPair_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting APPair:119,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 119 || c != 0 || l != 3) {
    std::ostringstream msg;
    msg << "Expecting APPair:(119,0,3)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<APPair> x = ptr<APPair>();
  x->step = Int_des(in);
  x->num = Nat_des(in);
  x->offset = Nat_des(in);
  return x;
}

Ptr<AccessPattern> AccessPattern_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting AccessPattern:120,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 120 || c != 0 || l != 6) {
    std::ostringstream msg;
    msg << "Expecting AccessPattern:(120,0,6)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<AccessPattern> x = ptr<AccessPattern>();
  x->tensor = TensorName_des(in);
  x->parNum = Nat_des(in);
  x->pattern = List_APPair_des(in);
  x->parOffset = Nat_des(in);
  x->freeOffset = Nat_des(in);
  x->fixedAxis = List_Nat_des(in);
  return x;
}

Ptr<ScalarOffset> ScalarOffset_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not read tag");
  if (t != 123)
    throw std::runtime_error("Unexpected type tag");
  switch (c) {
  case 0: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<ScalarOffsetRegWrapper> x = ptr<ScalarOffsetRegWrapper>();
    x->r = String_des(in);
    return x;
    break;
  }
  case 1: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<ScalarOffsetAccWrapper> x = ptr<ScalarOffsetAccWrapper>();
    x->a = Access_des(in);
    return x;
    break;
  }
  default:
    throw std::runtime_error("Invalid value tag");
  }
}

Ptr<BirAccessPattern> BirAccessPattern_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting BirAccessPattern:124,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 124 || c != 0 || l != 7) {
    std::ostringstream msg;
    msg << "Expecting BirAccessPattern:(124,0,7)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<BirAccessPattern> x = ptr<BirAccessPattern>();
  x->tensor = TensorName_des(in);
  x->offset = Nat_des(in);
  x->pattern = List_APPair_des(in);
  x->scalarOffset = Option_ScalarOffset_des(in);
  x->vectorOffset = Option_Access_des(in);
  x->indirectDim = Int_des(in);
  x->dtypeOverride = Option_Dtype_des(in);
  return x;
}

Ptr<Access> Access_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not read tag");
  if (t != 125)
    throw std::runtime_error("Unexpected type tag");
  switch (c) {
  case 0: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<AccessSimpleWrapper> x = ptr<AccessSimpleWrapper>();
    x->tensor = TensorName_des(in);
    return x;
    break;
  }
  case 1: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<AccessBasicWrapper> x = ptr<AccessBasicWrapper>();
    x->access = AccessBasic_des(in);
    return x;
    break;
  }
  case 2: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<AccessPatternWrapper> x = ptr<AccessPatternWrapper>();
    x->access = AccessPattern_des(in);
    return x;
    break;
  }
  case 3: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<AccessBirPatternWrapper> x = ptr<AccessBirPatternWrapper>();
    x->access = BirAccessPattern_des(in);
    return x;
    break;
  }
  default:
    throw std::runtime_error("Invalid value tag");
  }
}

Ptr<TensorHbm> TensorHbm_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting TensorHbm:126,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 126 || c != 0 || l != 4) {
    std::ostringstream msg;
    msg << "Expecting TensorHbm:(126,0,4)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<TensorHbm> x = ptr<TensorHbm>();
  x->name = String_des(in);
  x->dtype = Dtype_des(in);
  x->address = Nat_des(in);
  x->dims = List_APPair_des(in);
  return x;
}

Ptr<TensorSram> TensorSram_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting TensorSram:127,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 127 || c != 0 || l != 6) {
    std::ostringstream msg;
    msg << "Expecting TensorSram:(127,0,6)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<TensorSram> x = ptr<TensorSram>();
  x->name = String_des(in);
  x->dtype = Dtype_des(in);
  x->parNum = Nat_des(in);
  x->pattern = List_APPair_des(in);
  x->parOffset = Nat_des(in);
  x->freeOffset = Nat_des(in);
  return x;
}

Ptr<TensorRef> TensorRef_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not read tag");
  if (t != 128)
    throw std::runtime_error("Unexpected type tag");
  switch (c) {
  case 0: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<TensorRefAbstractWrapper> x = ptr<TensorRefAbstractWrapper>();
    x->access = Access_des(in);
    return x;
    break;
  }
  case 1: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<TensorRefSbufWrapper> x = ptr<TensorRefSbufWrapper>();
    x->view = TensorSram_des(in);
    return x;
    break;
  }
  case 2: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<TensorRefPsumWrapper> x = ptr<TensorRefPsumWrapper>();
    x->view = TensorSram_des(in);
    return x;
    break;
  }
  case 3: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<TensorRefHbmWrapper> x = ptr<TensorRefHbmWrapper>();
    x->view = TensorHbm_des(in);
    return x;
    break;
  }
  case 4: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<TensorRefRegisterWrapper> x = ptr<TensorRefRegisterWrapper>();
    x->reg = Nat_des(in);
    return x;
    break;
  }
  default:
    throw std::runtime_error("Invalid value tag");
  }
}

MatmulPerfMode MatmulPerfMode_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not read tag");
  if (t != 129)
    throw std::runtime_error("Unexpected type tag");
  switch (c) {
  case 0: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return MatmulPerfMode::None;
    break;
  }
  case 1: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return MatmulPerfMode::DoubleRow;
    break;
  }
  case 2: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return MatmulPerfMode::DoubleRowSwInterleave;
    break;
  }
  default:
    throw std::runtime_error("Invalid value tag");
  }
}

Engine Engine_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not read tag");
  if (t != 130)
    throw std::runtime_error("Unexpected type tag");
  switch (c) {
  case 0: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return Engine::unassigned;
    break;
  }
  case 1: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return Engine::act;
    break;
  }
  case 2: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return Engine::dma;
    break;
  }
  case 3: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return Engine::dve;
    break;
  }
  case 4: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return Engine::pe;
    break;
  }
  case 5: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return Engine::pool;
    break;
  }
  case 6: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return Engine::sp;
    break;
  }
  default:
    throw std::runtime_error("Invalid value tag");
  }
}

Ptr<ActivationImm> ActivationImm_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not read tag");
  if (t != 132)
    throw std::runtime_error("Unexpected type tag");
  switch (c) {
  case 0: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<ActivationImmRegisterWrapper> x = ptr<ActivationImmRegisterWrapper>();
    x->reg = Nat_des(in);
    return x;
    break;
  }
  case 1: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    Ptr<ActivationImmPointerWrapper> x = ptr<ActivationImmPointerWrapper>();
    return x;
    break;
  }
  case 2: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<ActivationImmFloatWrapper> x = ptr<ActivationImmFloatWrapper>();
    x->f = Float_des(in);
    return x;
    break;
  }
  default:
    throw std::runtime_error("Invalid value tag");
  }
}

Ptr<Operand> Operand_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not read tag");
  if (t != 133)
    throw std::runtime_error("Unexpected type tag");
  switch (c) {
  case 0: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperandImmWrapper> x = ptr<OperandImmWrapper>();
    x->i = Immediate_des(in);
    return x;
    break;
  }
  case 1: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperandTileWrapper> x = ptr<OperandTileWrapper>();
    x->t = TensorRef_des(in);
    return x;
    break;
  }
  default:
    throw std::runtime_error("Invalid value tag");
  }
}

Ptr<DataPattern> DataPattern_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting DataPattern:134,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 134 || c != 0 || l != 3) {
    std::ostringstream msg;
    msg << "Expecting DataPattern:(134,0,3)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<DataPattern> x = ptr<DataPattern>();
  x->offset = Int_des(in);
  x->pattern = List_APPair_des(in);
  x->channelMultiplier = Int_des(in);
  return x;
}

AluOp AluOp_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not read tag");
  if (t != 135)
    throw std::runtime_error("Unexpected type tag");
  switch (c) {
  case 0: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return AluOp::abs;
    break;
  }
  case 1: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return AluOp::add;
    break;
  }
  case 2: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return AluOp::arith_shift_left;
    break;
  }
  case 3: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return AluOp::arith_shift_right;
    break;
  }
  case 4: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return AluOp::average;
    break;
  }
  case 5: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return AluOp::bitwise_and;
    break;
  }
  case 6: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return AluOp::bitwise_not;
    break;
  }
  case 7: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return AluOp::bitwise_or;
    break;
  }
  case 8: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return AluOp::bitwise_xor;
    break;
  }
  case 9: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return AluOp::bypass;
    break;
  }
  case 10: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return AluOp::divide;
    break;
  }
  case 11: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return AluOp::is_equal;
    break;
  }
  case 12: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return AluOp::is_ge;
    break;
  }
  case 13: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return AluOp::is_gt;
    break;
  }
  case 14: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return AluOp::is_le;
    break;
  }
  case 15: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return AluOp::is_lt;
    break;
  }
  case 16: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return AluOp::logical_and;
    break;
  }
  case 17: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return AluOp::logical_or;
    break;
  }
  case 18: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return AluOp::logical_shift_left;
    break;
  }
  case 19: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return AluOp::logical_shift_right;
    break;
  }
  case 20: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return AluOp::logical_xor;
    break;
  }
  case 21: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return AluOp::max;
    break;
  }
  case 22: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return AluOp::min;
    break;
  }
  case 23: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return AluOp::mod;
    break;
  }
  case 24: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return AluOp::mult;
    break;
  }
  case 25: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return AluOp::not_equal;
    break;
  }
  case 26: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return AluOp::pow;
    break;
  }
  case 27: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return AluOp::rsqrt;
    break;
  }
  case 28: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return AluOp::subtract;
    break;
  }
  default:
    throw std::runtime_error("Invalid value tag");
  }
}

DropoutThresholdType DropoutThresholdType_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not read tag");
  if (t != 136)
    throw std::runtime_error("Unexpected type tag");
  switch (c) {
  case 0: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return DropoutThresholdType::DropRate;
    break;
  }
  case 1: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return DropoutThresholdType::KeepRate;
    break;
  }
  default:
    throw std::runtime_error("Invalid value tag");
  }
}

AccumCmd AccumCmd_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not read tag");
  if (t != 137)
    throw std::runtime_error("Unexpected type tag");
  switch (c) {
  case 0: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return AccumCmd::Idle;
    break;
  }
  case 1: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return AccumCmd::Zero;
    break;
  }
  case 2: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return AccumCmd::Accumulate;
    break;
  }
  case 3: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return AccumCmd::ZeroAccumulate;
    break;
  }
  case 4: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return AccumCmd::LoadAccumulate;
    break;
  }
  default:
    throw std::runtime_error("Invalid value tag");
  }
}

ActivationFunc ActivationFunc_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not read tag");
  if (t != 138)
    throw std::runtime_error("Unexpected type tag");
  switch (c) {
  case 0: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return ActivationFunc::abs;
    break;
  }
  case 1: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return ActivationFunc::arctan;
    break;
  }
  case 2: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return ActivationFunc::copy;
    break;
  }
  case 3: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return ActivationFunc::erf;
    break;
  }
  case 4: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return ActivationFunc::erf_dx;
    break;
  }
  case 5: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return ActivationFunc::exp;
    break;
  }
  case 6: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return ActivationFunc::gelu;
    break;
  }
  case 7: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return ActivationFunc::gelu_apprx_tanh;
    break;
  }
  case 8: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return ActivationFunc::gelu_dx;
    break;
  }
  case 9: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return ActivationFunc::log;
    break;
  }
  case 10: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return ActivationFunc::mish;
    break;
  }
  case 11: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return ActivationFunc::reciprocal;
    break;
  }
  case 12: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return ActivationFunc::relu;
    break;
  }
  case 13: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return ActivationFunc::rsqrt;
    break;
  }
  case 14: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return ActivationFunc::sigmoid;
    break;
  }
  case 15: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return ActivationFunc::sign;
    break;
  }
  case 16: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return ActivationFunc::silu;
    break;
  }
  case 17: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return ActivationFunc::silu_dx;
    break;
  }
  case 18: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return ActivationFunc::sin;
    break;
  }
  case 19: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return ActivationFunc::softplus;
    break;
  }
  case 20: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return ActivationFunc::sqrt;
    break;
  }
  case 21: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return ActivationFunc::square;
    break;
  }
  case 22: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return ActivationFunc::tanh;
    break;
  }
  case 23: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return ActivationFunc::gelu_apprx_sigmoid;
    break;
  }
  case 24: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return ActivationFunc::gelu_apprx_sigmoid_dx;
    break;
  }
  default:
    throw std::runtime_error("Invalid value tag");
  }
}

AffineSelectCmp AffineSelectCmp_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not read tag");
  if (t != 139)
    throw std::runtime_error("Unexpected type tag");
  switch (c) {
  case 0: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return AffineSelectCmp::GreaterThan;
    break;
  }
  case 1: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return AffineSelectCmp::GreaterThanEq;
    break;
  }
  case 2: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return AffineSelectCmp::Eq;
    break;
  }
  case 3: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return AffineSelectCmp::NotEq;
    break;
  }
  default:
    throw std::runtime_error("Invalid value tag");
  }
}

DgeComputeOp DgeComputeOp_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not read tag");
  if (t != 140)
    throw std::runtime_error("Unexpected type tag");
  switch (c) {
  case 0: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return DgeComputeOp::none;
    break;
  }
  case 1: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return DgeComputeOp::add;
    break;
  }
  default:
    throw std::runtime_error("Invalid value tag");
  }
}

Ptr<DmaBounds> DmaBounds_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not read tag");
  if (t != 141)
    throw std::runtime_error("Unexpected type tag");
  switch (c) {
  case 0: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    Ptr<DmaBoundsSkipWrapper> x = ptr<DmaBoundsSkipWrapper>();
    return x;
    break;
  }
  case 1: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    Ptr<DmaBoundsErrorWrapper> x = ptr<DmaBoundsErrorWrapper>();
    return x;
    break;
  }
  case 2: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<DmaBoundsRegWrapper> x = ptr<DmaBoundsRegWrapper>();
    x->reg = Nat_des(in);
    return x;
    break;
  }
  default:
    throw std::runtime_error("Invalid value tag");
  }
}

MatmulGroupElement MatmulGroupElement_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not read tag");
  if (t != 142)
    throw std::runtime_error("Unexpected type tag");
  switch (c) {
  case 0: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return MatmulGroupElement::first;
    break;
  }
  case 1: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return MatmulGroupElement::middle;
    break;
  }
  case 2: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return MatmulGroupElement::last;
    break;
  }
  case 3: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return MatmulGroupElement::whole;
    break;
  }
  default:
    throw std::runtime_error("Invalid value tag");
  }
}

Ptr<IndexMissBehavior> IndexMissBehavior_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not read tag");
  if (t != 143)
    throw std::runtime_error("Unexpected type tag");
  switch (c) {
  case 0: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<IndexMissBehaviorImmWrapper> x = ptr<IndexMissBehaviorImmWrapper>();
    x->value = Immediate_des(in);
    return x;
    break;
  }
  case 1: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    Ptr<IndexMissBehaviorSkipWrapper> x = ptr<IndexMissBehaviorSkipWrapper>();
    return x;
    break;
  }
  default:
    throw std::runtime_error("Invalid value tag");
  }
}

TensorScalarReverseOps TensorScalarReverseOps_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not read tag");
  if (t != 144)
    throw std::runtime_error("Unexpected type tag");
  switch (c) {
  case 0: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return TensorScalarReverseOps::none;
    break;
  }
  case 1: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return TensorScalarReverseOps::first;
    break;
  }
  case 2: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return TensorScalarReverseOps::second;
    break;
  }
  case 3: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return TensorScalarReverseOps::both;
    break;
  }
  default:
    throw std::runtime_error("Invalid value tag");
  }
}

TensorSubDim TensorSubDim_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not read tag");
  if (t != 145)
    throw std::runtime_error("Unexpected type tag");
  switch (c) {
  case 0: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return TensorSubDim::X;
    break;
  }
  case 1: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return TensorSubDim::XY;
    break;
  }
  case 2: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return TensorSubDim::XYZ;
    break;
  }
  case 3: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return TensorSubDim::XYZW;
    break;
  }
  default:
    throw std::runtime_error("Invalid value tag");
  }
}

TransposeOps TransposeOps_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not read tag");
  if (t != 146)
    throw std::runtime_error("Unexpected type tag");
  switch (c) {
  case 0: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return TransposeOps::None;
    break;
  }
  case 1: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return TransposeOps::WZXY;
    break;
  }
  case 2: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return TransposeOps::WXZY;
    break;
  }
  case 3: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return TransposeOps::WYXZ;
    break;
  }
  case 4: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return TransposeOps::ZWYX;
    break;
  }
  case 5: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return TransposeOps::ZYWX;
    break;
  }
  case 6: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return TransposeOps::ZYXW;
    break;
  }
  case 7: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return TransposeOps::YXWZ;
    break;
  }
  case 8: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return TransposeOps::YXZW;
    break;
  }
  case 9: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return TransposeOps::YWZX;
    break;
  }
  case 10: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return TransposeOps::XWZY;
    break;
  }
  case 11: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return TransposeOps::XZYW;
    break;
  }
  case 12: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return TransposeOps::XYZW;
    break;
  }
  case 13: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return TransposeOps::XYWZ;
    break;
  }
  default:
    throw std::runtime_error("Invalid value tag");
  }
}

Ptr<Dropout> Dropout_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting Dropout:147,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 147 || c != 0 || l != 5) {
    std::ostringstream msg;
    msg << "Expecting Dropout:(147,0,5)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<Dropout> x = ptr<Dropout>();
  x->dst = TensorRef_des(in);
  x->src = TensorRef_des(in);
  x->thresholdType = DropoutThresholdType_des(in);
  x->threshold = Operand_des(in);
  x->dtype = Option_Dtype_des(in);
  return x;
}

Ptr<Activate> Activate_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting Activate:148,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 148 || c != 0 || l != 7) {
    std::ostringstream msg;
    msg << "Expecting Activate:(148,0,7)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<Activate> x = ptr<Activate>();
  x->dst = TensorRef_des(in);
  x->src = TensorRef_des(in);
  x->accumulatorCmd = AccumCmd_des(in);
  x->activationFunc = ActivationFunc_des(in);
  x->scale = Immediate_des(in);
  x->bias = Immediate_des(in);
  x->imm = Immediate_des(in);
  return x;
}

Ptr<AffineSelect> AffineSelect_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting AffineSelect:150,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 150 || c != 0 || l != 5) {
    std::ostringstream msg;
    msg << "Expecting AffineSelect:(150,0,5)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<AffineSelect> x = ptr<AffineSelect>();
  x->dst = TensorRef_des(in);
  x->src = TensorRef_des(in);
  x->fillMode = AffineSelectCmp_des(in);
  x->fillReg = Nat_des(in);
  x->maskPattern = DataPattern_des(in);
  return x;
}

Ptr<DmaCopy> DmaCopy_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting DmaCopy:152,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 152 || c != 0 || l != 5) {
    std::ostringstream msg;
    msg << "Expecting DmaCopy:(152,0,5)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<DmaCopy> x = ptr<DmaCopy>();
  x->dst = TensorRef_des(in);
  x->src = TensorRef_des(in);
  x->compute_op = DgeComputeOp_des(in);
  x->dstBoundsCheck = DmaBounds_des(in);
  x->srcBoundsCheck = DmaBounds_des(in);
  return x;
}

Ptr<DmaTranspose> DmaTranspose_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting DmaTranspose:154,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 154 || c != 0 || l != 6) {
    std::ostringstream msg;
    msg << "Expecting DmaTranspose:(154,0,6)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<DmaTranspose> x = ptr<DmaTranspose>();
  x->dst = TensorRef_des(in);
  x->src = TensorRef_des(in);
  x->axes = TransposeOps_des(in);
  x->dtype = Option_Dtype_des(in);
  x->dgeMode = Nat_des(in);
  x->oobMode = DmaBounds_des(in);
  return x;
}

Ptr<Transpose> Transpose_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting Transpose:155,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 155 || c != 0 || l != 4) {
    std::ostringstream msg;
    msg << "Expecting Transpose:(155,0,4)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<Transpose> x = ptr<Transpose>();
  x->dst = TensorRef_des(in);
  x->src = TensorRef_des(in);
  x->dtype = Option_Dtype_des(in);
  x->engine = Engine_des(in);
  return x;
}

Ptr<LoadMaskRegister> LoadMaskRegister_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting LoadMaskRegister:156,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 156 || c != 0 || l != 1) {
    std::ostringstream msg;
    msg << "Expecting LoadMaskRegister:(156,0,1)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<LoadMaskRegister> x = ptr<LoadMaskRegister>();
  x->regNum = Nat_des(in);
  return x;
}

Ptr<Shuffle> Shuffle_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting Shuffle:157,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 157 || c != 0 || l != 4) {
    std::ostringstream msg;
    msg << "Expecting Shuffle:(157,0,4)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<Shuffle> x = ptr<Shuffle>();
  x->dst = TensorRef_des(in);
  x->src = TensorRef_des(in);
  x->shuffleMask = List_Immediate_des(in);
  x->dtype = Option_Dtype_des(in);
  return x;
}

Ptr<MemSet> MemSet_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting MemSet:158,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 158 || c != 0 || l != 4) {
    std::ostringstream msg;
    msg << "Expecting MemSet:(158,0,4)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<MemSet> x = ptr<MemSet>();
  x->dst = TensorRef_des(in);
  x->value = Immediate_des(in);
  x->dtype = Dtype_des(in);
  x->engine = Engine_des(in);
  return x;
}

Ptr<Iota> Iota_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting Iota:159,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 159 || c != 0 || l != 3) {
    std::ostringstream msg;
    msg << "Expecting Iota:(159,0,3)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<Iota> x = ptr<Iota>();
  x->dst = TensorRef_des(in);
  x->pattern = DataPattern_des(in);
  x->dtype = Option_Dtype_des(in);
  return x;
}

Ptr<LoadStationary> LoadStationary_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting LoadStationary:160,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 160 || c != 0 || l != 2) {
    std::ostringstream msg;
    msg << "Expecting LoadStationary:(160,0,2)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<LoadStationary> x = ptr<LoadStationary>();
  x->src = TensorRef_des(in);
  x->isTranspose = Bool_des(in);
  return x;
}

Ptr<MatMul> MatMul_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting MatMul:161,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 161 || c != 0 || l != 2) {
    std::ostringstream msg;
    msg << "Expecting MatMul:(161,0,2)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<MatMul> x = ptr<MatMul>();
  x->dst = TensorRef_des(in);
  x->moving = TensorRef_des(in);
  return x;
}

Ptr<LocalGather> LocalGather_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting LocalGather:162,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 162 || c != 0 || l != 4) {
    std::ostringstream msg;
    msg << "Expecting LocalGather:(162,0,4)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<LocalGather> x = ptr<LocalGather>();
  x->dst = TensorRef_des(in);
  x->src = TensorRef_des(in);
  x->indexMissBehavior = IndexMissBehavior_des(in);
  x->freePoolBuffer = Bool_des(in);
  return x;
}

Ptr<RangeSelect> RangeSelect_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting RangeSelect:164,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 164 || c != 0 || l != 10) {
    std::ostringstream msg;
    msg << "Expecting RangeSelect:(164,0,10)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<RangeSelect> x = ptr<RangeSelect>();
  x->dst = TensorRef_des(in);
  x->src = TensorRef_des(in);
  x->reduceCommand = AccumCmd_des(in);
  x->reduceOp = AluOp_des(in);
  x->base = Float_des(in);
  x->fillValue = Float_des(in);
  x->compOp0 = AluOp_des(in);
  x->compOp1 = AluOp_des(in);
  x->bound0 = Immediate_des(in);
  x->bound1 = Immediate_des(in);
  return x;
}

Ptr<ScalarTensorTensor> ScalarTensorTensor_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting ScalarTensorTensor:166,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 166 || c != 0 || l != 8) {
    std::ostringstream msg;
    msg << "Expecting ScalarTensorTensor:(166,0,8)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<ScalarTensorTensor> x = ptr<ScalarTensorTensor>();
  x->dst = TensorRef_des(in);
  x->src0 = TensorRef_des(in);
  x->src1 = TensorRef_des(in);
  x->op0 = AluOp_des(in);
  x->op1 = AluOp_des(in);
  x->reverseOperands = TensorScalarReverseOps_des(in);
  x->imm0 = Immediate_des(in);
  x->accumulatorCmd = AccumCmd_des(in);
  return x;
}

Ptr<CopyPredicated> CopyPredicated_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting CopyPredicated:168,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 168 || c != 0 || l != 5) {
    std::ostringstream msg;
    msg << "Expecting CopyPredicated:(168,0,5)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<CopyPredicated> x = ptr<CopyPredicated>();
  x->dst = TensorRef_des(in);
  x->src = TensorRef_des(in);
  x->predicate = TensorRef_des(in);
  x->dtype = Option_Dtype_des(in);
  x->reversePred = Bool_des(in);
  return x;
}

Ptr<TensorTensorScan> TensorTensorScan_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting TensorTensorScan:169,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 169 || c != 0 || l != 9) {
    std::ostringstream msg;
    msg << "Expecting TensorTensorScan:(169,0,9)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<TensorTensorScan> x = ptr<TensorTensorScan>();
  x->dst = TensorRef_des(in);
  x->src0 = TensorRef_des(in);
  x->src1 = TensorRef_des(in);
  x->op0 = AluOp_des(in);
  x->op1 = AluOp_des(in);
  x->reverseOperands = TensorScalarReverseOps_des(in);
  x->imm0 = Operand_des(in);
  x->accumulatorCmd = AccumCmd_des(in);
  x->dtype = Option_Dtype_des(in);
  return x;
}

Ptr<MatchValueLoad> MatchValueLoad_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting MatchValueLoad:170,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 170 || c != 0 || l != 1) {
    std::ostringstream msg;
    msg << "Expecting MatchValueLoad:(170,0,1)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<MatchValueLoad> x = ptr<MatchValueLoad>();
  x->src = TensorRef_des(in);
  return x;
}

Ptr<FindIndex8> FindIndex8_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting FindIndex8:171,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 171 || c != 0 || l != 4) {
    std::ostringstream msg;
    msg << "Expecting FindIndex8:(171,0,4)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<FindIndex8> x = ptr<FindIndex8>();
  x->dst = TensorRef_des(in);
  x->src = TensorRef_des(in);
  x->vals = TensorRef_des(in);
  x->dtype = Option_Dtype_des(in);
  return x;
}

Ptr<MatchReplace8> MatchReplace8_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting MatchReplace8:172,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 172 || c != 0 || l != 6) {
    std::ostringstream msg;
    msg << "Expecting MatchReplace8:(172,0,6)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<MatchReplace8> x = ptr<MatchReplace8>();
  x->dst = TensorRef_des(in);
  x->src = TensorRef_des(in);
  x->vals = TensorRef_des(in);
  x->replaceValue = Immediate_des(in);
  x->dstIdx = Option_TensorRef_des(in);
  x->dtype = Option_Dtype_des(in);
  return x;
}

Ptr<Max8> Max8_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting Max8:173,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 173 || c != 0 || l != 3) {
    std::ostringstream msg;
    msg << "Expecting Max8:(173,0,3)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<Max8> x = ptr<Max8>();
  x->dst = TensorRef_des(in);
  x->src = TensorRef_des(in);
  x->dtype = Option_Dtype_des(in);
  return x;
}

Ptr<BatchNormAggregate> BatchNormAggregate_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting BatchNormAggregate:174,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 174 || c != 0 || l != 3) {
    std::ostringstream msg;
    msg << "Expecting BatchNormAggregate:(174,0,3)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<BatchNormAggregate> x = ptr<BatchNormAggregate>();
  x->dst = TensorRef_des(in);
  x->src = TensorRef_des(in);
  x->dtype = Option_Dtype_des(in);
  return x;
}

Ptr<BatchNormStats> BatchNormStats_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting BatchNormStats:175,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 175 || c != 0 || l != 3) {
    std::ostringstream msg;
    msg << "Expecting BatchNormStats:(175,0,3)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<BatchNormStats> x = ptr<BatchNormStats>();
  x->dst = TensorRef_des(in);
  x->src = TensorRef_des(in);
  x->dtype = Option_Dtype_des(in);
  return x;
}

Ptr<Reciprocal> Reciprocal_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting Reciprocal:176,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 176 || c != 0 || l != 3) {
    std::ostringstream msg;
    msg << "Expecting Reciprocal:(176,0,3)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<Reciprocal> x = ptr<Reciprocal>();
  x->dst = TensorRef_des(in);
  x->src = TensorRef_des(in);
  x->dtype = Option_Dtype_des(in);
  return x;
}

Ptr<Copy> Copy_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting Copy:177,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 177 || c != 0 || l != 3) {
    std::ostringstream msg;
    msg << "Expecting Copy:(177,0,3)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<Copy> x = ptr<Copy>();
  x->dst = TensorRef_des(in);
  x->src = TensorRef_des(in);
  x->opDim = Option_TensorSubDim_des(in);
  return x;
}

Ptr<TensorReduce> TensorReduce_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting TensorReduce:179,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 179 || c != 0 || l != 7) {
    std::ostringstream msg;
    msg << "Expecting TensorReduce:(179,0,7)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<TensorReduce> x = ptr<TensorReduce>();
  x->dst = TensorRef_des(in);
  x->src = TensorRef_des(in);
  x->op = AluOp_des(in);
  x->opDim = TensorSubDim_des(in);
  x->negated = Bool_des(in);
  x->dtype = Option_Dtype_des(in);
  x->keepdims = Bool_des(in);
  return x;
}

Ptr<TensorScalar> TensorScalar_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting TensorScalar:180,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 180 || c != 0 || l != 9) {
    std::ostringstream msg;
    msg << "Expecting TensorScalar:(180,0,9)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<TensorScalar> x = ptr<TensorScalar>();
  x->dst = TensorRef_des(in);
  x->src = TensorRef_des(in);
  x->imm0 = Operand_des(in);
  x->op0 = AluOp_des(in);
  x->imm1 = Option_Operand_des(in);
  x->op1 = Option_AluOp_des(in);
  x->reverse = TensorScalarReverseOps_des(in);
  x->engine = Engine_des(in);
  x->dtype = Option_Dtype_des(in);
  return x;
}

Ptr<TensorTensor> TensorTensor_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting TensorTensor:182,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 182 || c != 0 || l != 6) {
    std::ostringstream msg;
    msg << "Expecting TensorTensor:(182,0,6)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<TensorTensor> x = ptr<TensorTensor>();
  x->dst = TensorRef_des(in);
  x->src0 = TensorRef_des(in);
  x->src1 = TensorRef_des(in);
  x->op = AluOp_des(in);
  x->dtype = Option_Dtype_des(in);
  x->engine = Engine_des(in);
  return x;
}

Ptr<NcMatMul> NcMatMul_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting NcMatMul:183,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 183 || c != 0 || l != 9) {
    std::ostringstream msg;
    msg << "Expecting NcMatMul:(183,0,9)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<NcMatMul> x = ptr<NcMatMul>();
  x->dst = TensorRef_des(in);
  x->stationary = TensorRef_des(in);
  x->moving = TensorRef_des(in);
  x->isStationaryOneZero = Bool_des(in);
  x->isMovingZero = Bool_des(in);
  x->isTranspose = Bool_des(in);
  x->tilePosition = List_Nat_des(in);
  x->tileSize = List_Nat_des(in);
  x->perfMode = MatmulPerfMode_des(in);
  return x;
}

Ptr<TensorScalarReduce> TensorScalarReduce_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting TensorScalarReduce:181,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 181 || c != 0 || l != 8) {
    std::ostringstream msg;
    msg << "Expecting TensorScalarReduce:(181,0,8)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<TensorScalarReduce> x = ptr<TensorScalarReduce>();
  x->dst = TensorRef_des(in);
  x->src = TensorRef_des(in);
  x->operand0 = Operand_des(in);
  x->op0 = AluOp_des(in);
  x->reverse0 = Bool_des(in);
  x->dtype = Option_Dtype_des(in);
  x->reduceOp = Option_AluOp_des(in);
  x->reduceRes = TensorRef_des(in);
  return x;
}

Ptr<TensorPartitionReduce> TensorPartitionReduce_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting TensorPartitionReduce:184,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 184 || c != 0 || l != 4) {
    std::ostringstream msg;
    msg << "Expecting TensorPartitionReduce:(184,0,4)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<TensorPartitionReduce> x = ptr<TensorPartitionReduce>();
  x->dst = TensorRef_des(in);
  x->op = AluOp_des(in);
  x->data = TensorRef_des(in);
  x->dtype = Option_Dtype_des(in);
  return x;
}

Ptr<NcActivate> NcActivate_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting NcActivate:149,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 149 || c != 0 || l != 9) {
    std::ostringstream msg;
    msg << "Expecting NcActivate:(149,0,9)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<NcActivate> x = ptr<NcActivate>();
  x->dst = TensorRef_des(in);
  x->src = TensorRef_des(in);
  x->accumulatorCmd = AccumCmd_des(in);
  x->activationFunc = ActivationFunc_des(in);
  x->scale = Operand_des(in);
  x->bias = Option_TensorRef_des(in);
  x->reduceOp = Option_AluOp_des(in);
  x->reduceRes = Option_TensorRef_des(in);
  x->dtype = Option_Dtype_des(in);
  return x;
}

Ptr<NcAffineSelect> NcAffineSelect_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting NcAffineSelect:151,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 151 || c != 0 || l != 6) {
    std::ostringstream msg;
    msg << "Expecting NcAffineSelect:(151,0,6)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<NcAffineSelect> x = ptr<NcAffineSelect>();
  x->dst = TensorRef_des(in);
  x->pred = DataPattern_des(in);
  x->onTrueTile = TensorRef_des(in);
  x->onFalseValue = Immediate_des(in);
  x->dtype = Option_Dtype_des(in);
  x->cmpOp = AluOp_des(in);
  return x;
}

Ptr<NcDmaCopy> NcDmaCopy_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting NcDmaCopy:153,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 153 || c != 0 || l != 7) {
    std::ostringstream msg;
    msg << "Expecting NcDmaCopy:(153,0,7)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<NcDmaCopy> x = ptr<NcDmaCopy>();
  x->dst = TensorRef_des(in);
  x->src = TensorRef_des(in);
  x->compute_op = DgeComputeOp_des(in);
  x->oobMode = DmaBounds_des(in);
  x->dgeMode = Nat_des(in);
  x->uniqueIndices = Bool_des(in);
  x->engine = Engine_des(in);
  return x;
}

Ptr<NcLocalGather> NcLocalGather_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting NcLocalGather:163,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 163 || c != 0 || l != 5) {
    std::ostringstream msg;
    msg << "Expecting NcLocalGather:(163,0,5)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<NcLocalGather> x = ptr<NcLocalGather>();
  x->dst = TensorRef_des(in);
  x->src = TensorRef_des(in);
  x->index = TensorRef_des(in);
  x->numElemPerIdx = Immediate_des(in);
  x->numValidIndicies = Option_Immediate_des(in);
  return x;
}

Ptr<NcRangeSelect> NcRangeSelect_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting NcRangeSelect:165,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 165 || c != 0 || l != 12) {
    std::ostringstream msg;
    msg << "Expecting NcRangeSelect:(165,0,12)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<NcRangeSelect> x = ptr<NcRangeSelect>();
  x->dst = TensorRef_des(in);
  x->reduceCommand = AccumCmd_des(in);
  x->reduceRes = Option_TensorRef_des(in);
  x->reduceOp = Option_AluOp_des(in);
  x->compOp0 = AluOp_des(in);
  x->compOp1 = AluOp_des(in);
  x->bound0 = TensorRef_des(in);
  x->bound1 = TensorRef_des(in);
  x->rangeStart = Immediate_des(in);
  x->onTrueTile = TensorRef_des(in);
  x->onFalseValue = Immediate_des(in);
  x->dtype = Option_Dtype_des(in);
  return x;
}

Ptr<NcScalarTensorTensor> NcScalarTensorTensor_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting NcScalarTensorTensor:167,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 167 || c != 0 || l != 8) {
    std::ostringstream msg;
    msg << "Expecting NcScalarTensorTensor:(167,0,8)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<NcScalarTensorTensor> x = ptr<NcScalarTensorTensor>();
  x->dst = TensorRef_des(in);
  x->data = TensorRef_des(in);
  x->src0 = Operand_des(in);
  x->src1 = Operand_des(in);
  x->op0 = AluOp_des(in);
  x->op1 = AluOp_des(in);
  x->reverseOperands = TensorScalarReverseOps_des(in);
  x->dtype = Option_Dtype_des(in);
  return x;
}

Ptr<NcCopy> NcCopy_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting NcCopy:178,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 178 || c != 0 || l != 4) {
    std::ostringstream msg;
    msg << "Expecting NcCopy:(178,0,4)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<NcCopy> x = ptr<NcCopy>();
  x->dst = TensorRef_des(in);
  x->src = TensorRef_des(in);
  x->dtype = Option_Dtype_des(in);
  x->engine = Engine_des(in);
  return x;
}

Ptr<SelectReduce> SelectReduce_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting SelectReduce:185,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 185 || c != 0 || l != 9) {
    std::ostringstream msg;
    msg << "Expecting SelectReduce:(185,0,9)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<SelectReduce> x = ptr<SelectReduce>();
  x->dst = TensorRef_des(in);
  x->predicate = TensorRef_des(in);
  x->onTrue = TensorRef_des(in);
  x->onFalse = Operand_des(in);
  x->reduceRes = Option_TensorRef_des(in);
  x->reduceCmd = AccumCmd_des(in);
  x->reduceOp = AluOp_des(in);
  x->reversePred = Bool_des(in);
  x->dtype = Option_Dtype_des(in);
  return x;
}

Ptr<SequenceBounds> SequenceBounds_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting SequenceBounds:186,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 186 || c != 0 || l != 3) {
    std::ostringstream msg;
    msg << "Expecting SequenceBounds:(186,0,3)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<SequenceBounds> x = ptr<SequenceBounds>();
  x->dst = TensorRef_des(in);
  x->segmentIds = TensorRef_des(in);
  x->dtype = Option_Dtype_des(in);
  return x;
}

Ptr<SendRecv> SendRecv_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting SendRecv:187,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 187 || c != 0 || l != 6) {
    std::ostringstream msg;
    msg << "Expecting SendRecv:(187,0,6)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<SendRecv> x = ptr<SendRecv>();
  x->dst = TensorRef_des(in);
  x->src = TensorRef_des(in);
  x->sendToRank = Immediate_des(in);
  x->recvFromRank = Immediate_des(in);
  x->pipeId = Immediate_des(in);
  x->useGpsimdDma = Bool_des(in);
  return x;
}

Ptr<SendRecvCompute> SendRecvCompute_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting SendRecvCompute:188,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 188 || c != 0 || l != 6) {
    std::ostringstream msg;
    msg << "Expecting SendRecvCompute:(188,0,6)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<SendRecvCompute> x = ptr<SendRecvCompute>();
  x->dsts = List_TensorRef_des(in);
  x->srcs = List_TensorRef_des(in);
  x->sendToRanks = List_Immediate_des(in);
  x->recvFromRanks = List_Immediate_des(in);
  x->pipeId = Immediate_des(in);
  x->op = AluOp_des(in);
  return x;
}

Ptr<QuantizeMX> QuantizeMX_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting QuantizeMX:195,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 195 || c != 0 || l != 3) {
    std::ostringstream msg;
    msg << "Expecting QuantizeMX:(195,0,3)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<QuantizeMX> x = ptr<QuantizeMX>();
  x->dst = TensorRef_des(in);
  x->src = TensorRef_des(in);
  x->dstScale = TensorRef_des(in);
  return x;
}

Ptr<MatMulMX> MatMulMX_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting MatMulMX:196,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 196 || c != 0 || l != 7) {
    std::ostringstream msg;
    msg << "Expecting MatMulMX:(196,0,7)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<MatMulMX> x = ptr<MatMulMX>();
  x->dst = TensorRef_des(in);
  x->stationary = TensorRef_des(in);
  x->moving = TensorRef_des(in);
  x->stationaryScale = TensorRef_des(in);
  x->movingScale = TensorRef_des(in);
  x->tilePosition = Option_List_Nat_des(in);
  x->tileSize = Option_List_Nat_des(in);
  return x;
}

Ptr<DmaCompute> DmaCompute_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting DmaCompute:197,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 197 || c != 0 || l != 4) {
    std::ostringstream msg;
    msg << "Expecting DmaCompute:(197,0,4)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<DmaCompute> x = ptr<DmaCompute>();
  x->dst = TensorRef_des(in);
  x->srcs = List_TensorRef_des(in);
  x->scales = List_Immediate_des(in);
  x->reduceOp = AluOp_des(in);
  return x;
}

Ptr<ReplicaGroup> ReplicaGroup_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not read tag");
  if (t != 198)
    throw std::runtime_error("Unexpected type tag");
  switch (c) {
  case 0: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    Ptr<ReplicaGroupUnspecifiedWrapper> x =
        ptr<ReplicaGroupUnspecifiedWrapper>();
    return x;
    break;
  }
  case 1: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<ReplicaGroupNamedWrapper> x = ptr<ReplicaGroupNamedWrapper>();
    x->name = String_des(in);
    return x;
    break;
  }
  case 2: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<ReplicaGroupLiteralWrapper> x = ptr<ReplicaGroupLiteralWrapper>();
    x->groups = List_List_Int_des(in);
    return x;
    break;
  }
  default:
    throw std::runtime_error("Invalid value tag");
  }
}

Ptr<CollectiveOp> CollectiveOp_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting CollectiveOp:199,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 199 || c != 0 || l != 8) {
    std::ostringstream msg;
    msg << "Expecting CollectiveOp:(199,0,8)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<CollectiveOp> x = ptr<CollectiveOp>();
  x->dsts = List_TensorRef_des(in);
  x->srcs = List_TensorRef_des(in);
  x->op = Option_AluOp_des(in);
  x->replicaGroup = ReplicaGroup_des(in);
  x->concatDim = Option_Int_des(in);
  x->sourceTargetPairs = Option_List_List_Int_des(in);
  x->channel_id = Option_Int_des(in);
  x->num_channels = Option_Int_des(in);
  return x;
}

Ptr<RankId> RankId_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting RankId:200,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 200 || c != 0 || l != 1) {
    std::ostringstream msg;
    msg << "Expecting RankId:(200,0,1)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<RankId> x = ptr<RankId>();
  x->dst = String_des(in);
  return x;
}

Ptr<CurrentProcessingRankId> CurrentProcessingRankId_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting CurrentProcessingRankId:201,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 201 || c != 0 || l != 5) {
    std::ostringstream msg;
    msg << "Expecting CurrentProcessingRankId:(201,0,5)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<CurrentProcessingRankId> x = ptr<CurrentProcessingRankId>();
  x->dst = String_des(in);
  x->iterationId = Int_des(in);
  x->channelId = Int_des(in);
  x->numChannels = Int_des(in);
  x->replicaGroup = List_List_Int_des(in);
  return x;
}

Ptr<Send> Send_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting Send:202,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 202 || c != 0 || l != 3) {
    std::ostringstream msg;
    msg << "Expecting Send:(202,0,3)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<Send> x = ptr<Send>();
  x->op = AluOp_des(in);
  x->srcs = List_TensorRef_des(in);
  x->peerId = Int_des(in);
  return x;
}

Ptr<Recv> Recv_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting Recv:203,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 203 || c != 0 || l != 4) {
    std::ostringstream msg;
    msg << "Expecting Recv:(203,0,4)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<Recv> x = ptr<Recv>();
  x->op = AluOp_des(in);
  x->dsts = List_TensorRef_des(in);
  x->replicaGroups = List_Int_des(in);
  x->peerId = Int_des(in);
  return x;
}

BrCmpOp BrCmpOp_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not read tag");
  if (t != 189)
    throw std::runtime_error("Unexpected type tag");
  switch (c) {
  case 0: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return BrCmpOp::always;
    break;
  }
  case 1: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return BrCmpOp::lt_imm;
    break;
  }
  case 2: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return BrCmpOp::le_imm;
    break;
  }
  case 3: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return BrCmpOp::eq_imm;
    break;
  }
  case 4: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return BrCmpOp::ne_imm;
    break;
  }
  case 5: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return BrCmpOp::ge_imm;
    break;
  }
  case 6: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return BrCmpOp::gt_imm;
    break;
  }
  case 7: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return BrCmpOp::lt_reg;
    break;
  }
  case 8: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return BrCmpOp::le_reg;
    break;
  }
  case 9: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return BrCmpOp::eq_reg;
    break;
  }
  case 10: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return BrCmpOp::ne_reg;
    break;
  }
  case 11: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return BrCmpOp::ge_reg;
    break;
  }
  case 12: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return BrCmpOp::gt_reg;
    break;
  }
  default:
    throw std::runtime_error("Invalid value tag");
  }
}

Ptr<TensorLoad> TensorLoad_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting TensorLoad:190,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 190 || c != 0 || l != 2) {
    std::ostringstream msg;
    msg << "Expecting TensorLoad:(190,0,2)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<TensorLoad> x = ptr<TensorLoad>();
  x->dst = String_des(in);
  x->src = TensorRef_des(in);
  return x;
}

Ptr<TensorStore> TensorStore_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting TensorStore:191,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 191 || c != 0 || l != 2) {
    std::ostringstream msg;
    msg << "Expecting TensorStore:(191,0,2)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<TensorStore> x = ptr<TensorStore>();
  x->dst = TensorRef_des(in);
  x->src = String_des(in);
  return x;
}

Ptr<RegisterMove> RegisterMove_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting RegisterMove:192,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 192 || c != 0 || l != 2) {
    std::ostringstream msg;
    msg << "Expecting RegisterMove:(192,0,2)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<RegisterMove> x = ptr<RegisterMove>();
  x->dst = String_des(in);
  x->imm = Int_des(in);
  return x;
}

Ptr<CmpBranch> CmpBranch_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting CmpBranch:193,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 193 || c != 0 || l != 6) {
    std::ostringstream msg;
    msg << "Expecting CmpBranch:(193,0,6)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<CmpBranch> x = ptr<CmpBranch>();
  x->reg1 = String_des(in);
  x->reg2 = String_des(in);
  x->imm = Int_des(in);
  x->op = BrCmpOp_des(in);
  x->trueLabel = String_des(in);
  x->falseLabel = String_des(in);
  return x;
}

Ptr<RegisterAluOp> RegisterAluOp_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting RegisterAluOp:194,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 194 || c != 0 || l != 4) {
    std::ostringstream msg;
    msg << "Expecting RegisterAluOp:(194,0,4)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<RegisterAluOp> x = ptr<RegisterAluOp>();
  x->dst = String_des(in);
  x->src = String_des(in);
  x->imm = Int_des(in);
  x->op = AluOp_des(in);
  return x;
}

Ptr<CoreBarrier> CoreBarrier_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting CoreBarrier:204,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 204 || c != 0 || l != 3) {
    std::ostringstream msg;
    msg << "Expecting CoreBarrier:(204,0,3)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<CoreBarrier> x = ptr<CoreBarrier>();
  x->data = TensorRef_des(in);
  x->cores = List_Int_des(in);
  x->engine = Engine_des(in);
  return x;
}

Ptr<Rng> Rng_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting Rng:205,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 205 || c != 0 || l != 2) {
    std::ostringstream msg;
    msg << "Expecting Rng:(205,0,2)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<Rng> x = ptr<Rng>();
  x->dst = TensorRef_des(in);
  x->engine = Engine_des(in);
  return x;
}

Ptr<Rand2> Rand2_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting Rand2:206,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 206 || c != 0 || l != 3) {
    std::ostringstream msg;
    msg << "Expecting Rand2:(206,0,3)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<Rand2> x = ptr<Rand2>();
  x->dst = TensorRef_des(in);
  x->min = Operand_des(in);
  x->max = Operand_des(in);
  return x;
}

Ptr<RandGetState> RandGetState_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting RandGetState:207,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 207 || c != 0 || l != 2) {
    std::ostringstream msg;
    msg << "Expecting RandGetState:(207,0,2)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<RandGetState> x = ptr<RandGetState>();
  x->dst = TensorRef_des(in);
  x->engine = Engine_des(in);
  return x;
}

Ptr<SetRngSeed> SetRngSeed_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting SetRngSeed:208,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 208 || c != 0 || l != 1) {
    std::ostringstream msg;
    msg << "Expecting SetRngSeed:(208,0,1)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<SetRngSeed> x = ptr<SetRngSeed>();
  x->src = TensorRef_des(in);
  return x;
}

Ptr<RandSetState> RandSetState_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting RandSetState:209,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 209 || c != 0 || l != 2) {
    std::ostringstream msg;
    msg << "Expecting RandSetState:(209,0,2)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<RandSetState> x = ptr<RandSetState>();
  x->src = TensorRef_des(in);
  x->engine = Engine_des(in);
  return x;
}

Ptr<ExtendedInst> ExtendedInst_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting ExtendedInst:210,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 210 || c != 0 || l != 6) {
    std::ostringstream msg;
    msg << "Expecting ExtendedInst:(210,0,6)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<ExtendedInst> x = ptr<ExtendedInst>();
  x->opcode = Nat_des(in);
  x->hasRead = Bool_des(in);
  x->hasWrite = Bool_des(in);
  x->ports = Nat_des(in);
  x->data0 = List_Nat_des(in);
  x->data1 = List_Nat_des(in);
  return x;
}

Ptr<TensorScalarCumulative> TensorScalarCumulative_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting TensorScalarCumulative:211,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 211 || c != 0 || l != 9) {
    std::ostringstream msg;
    msg << "Expecting TensorScalarCumulative:(211,0,9)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<TensorScalarCumulative> x = ptr<TensorScalarCumulative>();
  x->dst = TensorRef_des(in);
  x->src = TensorRef_des(in);
  x->op0 = AluOp_des(in);
  x->op1 = AluOp_des(in);
  x->imm0 = Operand_des(in);
  x->imm1 = Option_Operand_des(in);
  x->reduceCmd = AccumCmd_des(in);
  x->reverse = TensorScalarReverseOps_des(in);
  x->dtype = Option_Dtype_des(in);
  return x;
}

Ptr<NcNGather> NcNGather_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting NcNGather:212,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 212 || c != 0 || l != 4) {
    std::ostringstream msg;
    msg << "Expecting NcNGather:(212,0,4)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<NcNGather> x = ptr<NcNGather>();
  x->dst = TensorRef_des(in);
  x->data = TensorRef_des(in);
  x->indices = TensorRef_des(in);
  x->dtype = Option_Dtype_des(in);
  return x;
}

Ptr<NonzeroWithCount> NonzeroWithCount_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting NonzeroWithCount:213,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 213 || c != 0 || l != 4) {
    std::ostringstream msg;
    msg << "Expecting NonzeroWithCount:(213,0,4)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<NonzeroWithCount> x = ptr<NonzeroWithCount>();
  x->dst = TensorRef_des(in);
  x->src = TensorRef_des(in);
  x->indexOffset = Immediate_des(in);
  x->paddingVal = Immediate_des(in);
  return x;
}

PrintOutputBuffer PrintOutputBuffer_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not read tag");
  if (t != 214)
    throw std::runtime_error("Unexpected type tag");
  switch (c) {
  case 0: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return PrintOutputBuffer::stdout;
    break;
  }
  case 1: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return PrintOutputBuffer::stderr;
    break;
  }
  default:
    throw std::runtime_error("Invalid value tag");
  }
}

Ptr<DevicePrint> DevicePrint_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting DevicePrint:215,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 215 || c != 0 || l != 3) {
    std::ostringstream msg;
    msg << "Expecting DevicePrint:(215,0,3)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<DevicePrint> x = ptr<DevicePrint>();
  x->src = TensorRef_des(in);
  x->printPrefix = String_des(in);
  x->buffer = PrintOutputBuffer_des(in);
  return x;
}

Ptr<Exponential> Exponential_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting Exponential:216,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 216 || c != 0 || l != 5) {
    std::ostringstream msg;
    msg << "Expecting Exponential:(216,0,5)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<Exponential> x = ptr<Exponential>();
  x->dst = TensorRef_des(in);
  x->src = TensorRef_des(in);
  x->maxValue = Operand_des(in);
  x->reducecmd = AccumCmd_des(in);
  x->ReduceInit = Operand_des(in);
  return x;
}

Ptr<Operator> Operator_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not read tag");
  if (t != 217)
    throw std::runtime_error("Unexpected type tag");
  switch (c) {
  case 0: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorActivateWrapper> x = ptr<OperatorActivateWrapper>();
    x->op = Activate_des(in);
    return x;
    break;
  }
  case 1: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorNcActivateWrapper> x = ptr<OperatorNcActivateWrapper>();
    x->op = NcActivate_des(in);
    return x;
    break;
  }
  case 2: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorActivationReduceWrapper> x =
        ptr<OperatorActivationReduceWrapper>();
    x->op = NcActivate_des(in);
    return x;
    break;
  }
  case 3: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorAffineSelectWrapper> x = ptr<OperatorAffineSelectWrapper>();
    x->op = AffineSelect_des(in);
    return x;
    break;
  }
  case 4: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorNcAffineSelectWrapper> x = ptr<OperatorNcAffineSelectWrapper>();
    x->op = NcAffineSelect_des(in);
    return x;
    break;
  }
  case 5: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorBatchNormAggregateWrapper> x =
        ptr<OperatorBatchNormAggregateWrapper>();
    x->op = BatchNormAggregate_des(in);
    return x;
    break;
  }
  case 6: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorBatchNormStatsWrapper> x = ptr<OperatorBatchNormStatsWrapper>();
    x->op = BatchNormStats_des(in);
    return x;
    break;
  }
  case 7: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorCopyWrapper> x = ptr<OperatorCopyWrapper>();
    x->op = Copy_des(in);
    return x;
    break;
  }
  case 8: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorNcCopyWrapper> x = ptr<OperatorNcCopyWrapper>();
    x->op = NcCopy_des(in);
    return x;
    break;
  }
  case 9: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorCopyPredicatedWrapper> x = ptr<OperatorCopyPredicatedWrapper>();
    x->op = CopyPredicated_des(in);
    return x;
    break;
  }
  case 10: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorDmaCopyWrapper> x = ptr<OperatorDmaCopyWrapper>();
    x->op = DmaCopy_des(in);
    return x;
    break;
  }
  case 11: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorNcDmaCopyWrapper> x = ptr<OperatorNcDmaCopyWrapper>();
    x->op = NcDmaCopy_des(in);
    return x;
    break;
  }
  case 12: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorDmaTransposeWrapper> x = ptr<OperatorDmaTransposeWrapper>();
    x->op = DmaTranspose_des(in);
    return x;
    break;
  }
  case 13: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorDropoutWrapper> x = ptr<OperatorDropoutWrapper>();
    x->op = Dropout_des(in);
    return x;
    break;
  }
  case 14: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorFindIndex8Wrapper> x = ptr<OperatorFindIndex8Wrapper>();
    x->op = FindIndex8_des(in);
    return x;
    break;
  }
  case 15: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorIotaWrapper> x = ptr<OperatorIotaWrapper>();
    x->op = Iota_des(in);
    return x;
    break;
  }
  case 16: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorLoadMaskRegisterWrapper> x =
        ptr<OperatorLoadMaskRegisterWrapper>();
    x->op = LoadMaskRegister_des(in);
    return x;
    break;
  }
  case 17: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorLoadStationaryWrapper> x = ptr<OperatorLoadStationaryWrapper>();
    x->op = LoadStationary_des(in);
    return x;
    break;
  }
  case 18: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorLocalGatherWrapper> x = ptr<OperatorLocalGatherWrapper>();
    x->op = LocalGather_des(in);
    return x;
    break;
  }
  case 19: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorNcLocalGatherWrapper> x = ptr<OperatorNcLocalGatherWrapper>();
    x->op = NcLocalGather_des(in);
    return x;
    break;
  }
  case 20: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorMatMulWrapper> x = ptr<OperatorMatMulWrapper>();
    x->op = MatMul_des(in);
    return x;
    break;
  }
  case 21: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorNcMatMulWrapper> x = ptr<OperatorNcMatMulWrapper>();
    x->op = NcMatMul_des(in);
    return x;
    break;
  }
  case 22: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorMatchReplace8Wrapper> x = ptr<OperatorMatchReplace8Wrapper>();
    x->op = MatchReplace8_des(in);
    return x;
    break;
  }
  case 23: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorMatchValueLoadWrapper> x = ptr<OperatorMatchValueLoadWrapper>();
    x->op = MatchValueLoad_des(in);
    return x;
    break;
  }
  case 24: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorMax8Wrapper> x = ptr<OperatorMax8Wrapper>();
    x->op = Max8_des(in);
    return x;
    break;
  }
  case 25: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorMemSetWrapper> x = ptr<OperatorMemSetWrapper>();
    x->op = MemSet_des(in);
    return x;
    break;
  }
  case 26: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorRangeSelectWrapper> x = ptr<OperatorRangeSelectWrapper>();
    x->op = RangeSelect_des(in);
    return x;
    break;
  }
  case 27: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorNcRangeSelectWrapper> x = ptr<OperatorNcRangeSelectWrapper>();
    x->op = NcRangeSelect_des(in);
    return x;
    break;
  }
  case 28: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorReciprocalWrapper> x = ptr<OperatorReciprocalWrapper>();
    x->op = Reciprocal_des(in);
    return x;
    break;
  }
  case 29: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorScalarTensorTensorWrapper> x =
        ptr<OperatorScalarTensorTensorWrapper>();
    x->op = ScalarTensorTensor_des(in);
    return x;
    break;
  }
  case 30: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorNcScalarTensorTensorWrapper> x =
        ptr<OperatorNcScalarTensorTensorWrapper>();
    x->op = NcScalarTensorTensor_des(in);
    return x;
    break;
  }
  case 31: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorShuffleWrapper> x = ptr<OperatorShuffleWrapper>();
    x->op = Shuffle_des(in);
    return x;
    break;
  }
  case 32: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorTensorReduceWrapper> x = ptr<OperatorTensorReduceWrapper>();
    x->op = TensorReduce_des(in);
    return x;
    break;
  }
  case 33: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorTensorScalarWrapper> x = ptr<OperatorTensorScalarWrapper>();
    x->op = TensorScalar_des(in);
    return x;
    break;
  }
  case 34: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorTensorTensorWrapper> x = ptr<OperatorTensorTensorWrapper>();
    x->op = TensorTensor_des(in);
    return x;
    break;
  }
  case 35: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorTensorTensorScanWrapper> x =
        ptr<OperatorTensorTensorScanWrapper>();
    x->op = TensorTensorScan_des(in);
    return x;
    break;
  }
  case 36: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorTensorPartitionReduceWrapper> x =
        ptr<OperatorTensorPartitionReduceWrapper>();
    x->op = TensorPartitionReduce_des(in);
    return x;
    break;
  }
  case 37: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorTensorScalarReduceWrapper> x =
        ptr<OperatorTensorScalarReduceWrapper>();
    x->op = TensorScalarReduce_des(in);
    return x;
    break;
  }
  case 38: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorTransposeWrapper> x = ptr<OperatorTransposeWrapper>();
    x->op = Transpose_des(in);
    return x;
    break;
  }
  case 39: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorSelectReduceWrapper> x = ptr<OperatorSelectReduceWrapper>();
    x->op = SelectReduce_des(in);
    return x;
    break;
  }
  case 40: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorSequenceBoundsWrapper> x = ptr<OperatorSequenceBoundsWrapper>();
    x->op = SequenceBounds_des(in);
    return x;
    break;
  }
  case 41: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorSendRecvWrapper> x = ptr<OperatorSendRecvWrapper>();
    x->op = SendRecv_des(in);
    return x;
    break;
  }
  case 42: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorSendRecvComputeWrapper> x =
        ptr<OperatorSendRecvComputeWrapper>();
    x->op = SendRecvCompute_des(in);
    return x;
    break;
  }
  case 43: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorTensorLoadWrapper> x = ptr<OperatorTensorLoadWrapper>();
    x->op = TensorLoad_des(in);
    return x;
    break;
  }
  case 44: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorTensorStoreWrapper> x = ptr<OperatorTensorStoreWrapper>();
    x->op = TensorStore_des(in);
    return x;
    break;
  }
  case 45: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorRegisterMoveWrapper> x = ptr<OperatorRegisterMoveWrapper>();
    x->op = RegisterMove_des(in);
    return x;
    break;
  }
  case 46: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorCmpBranchWrapper> x = ptr<OperatorCmpBranchWrapper>();
    x->op = CmpBranch_des(in);
    return x;
    break;
  }
  case 47: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorRegisterAluOpWrapper> x = ptr<OperatorRegisterAluOpWrapper>();
    x->op = RegisterAluOp_des(in);
    return x;
    break;
  }
  case 48: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorQuantizeMXWrapper> x = ptr<OperatorQuantizeMXWrapper>();
    x->op = QuantizeMX_des(in);
    return x;
    break;
  }
  case 49: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorNcMatMulMXWrapper> x = ptr<OperatorNcMatMulMXWrapper>();
    x->op = MatMulMX_des(in);
    return x;
    break;
  }
  case 50: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorDmaComputeWrapper> x = ptr<OperatorDmaComputeWrapper>();
    x->op = DmaCompute_des(in);
    return x;
    break;
  }
  case 51: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorAllReduceWrapper> x = ptr<OperatorAllReduceWrapper>();
    x->op = CollectiveOp_des(in);
    return x;
    break;
  }
  case 52: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorAllGatherWrapper> x = ptr<OperatorAllGatherWrapper>();
    x->op = CollectiveOp_des(in);
    return x;
    break;
  }
  case 53: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorReduceScatterWrapper> x = ptr<OperatorReduceScatterWrapper>();
    x->op = CollectiveOp_des(in);
    return x;
    break;
  }
  case 54: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorCollectivePermuteWrapper> x =
        ptr<OperatorCollectivePermuteWrapper>();
    x->op = CollectiveOp_des(in);
    return x;
    break;
  }
  case 55: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorCollectivePermuteImplicitWrapper> x =
        ptr<OperatorCollectivePermuteImplicitWrapper>();
    x->op = CollectiveOp_des(in);
    return x;
    break;
  }
  case 56: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorCollectivePermuteImplicitReduceWrapper> x =
        ptr<OperatorCollectivePermuteImplicitReduceWrapper>();
    x->op = CollectiveOp_des(in);
    return x;
    break;
  }
  case 57: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorBroadcastWrapper> x = ptr<OperatorBroadcastWrapper>();
    x->op = CollectiveOp_des(in);
    return x;
    break;
  }
  case 58: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorAllToAllWrapper> x = ptr<OperatorAllToAllWrapper>();
    x->op = CollectiveOp_des(in);
    return x;
    break;
  }
  case 59: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorRankIdWrapper> x = ptr<OperatorRankIdWrapper>();
    x->op = RankId_des(in);
    return x;
    break;
  }
  case 60: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorCurrentProcessingRankIdWrapper> x =
        ptr<OperatorCurrentProcessingRankIdWrapper>();
    x->op = CurrentProcessingRankId_des(in);
    return x;
    break;
  }
  case 61: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorSendWrapper> x = ptr<OperatorSendWrapper>();
    x->op = Send_des(in);
    return x;
    break;
  }
  case 62: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorRecvWrapper> x = ptr<OperatorRecvWrapper>();
    x->op = Recv_des(in);
    return x;
    break;
  }
  case 63: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorCoreBarrierWrapper> x = ptr<OperatorCoreBarrierWrapper>();
    x->op = CoreBarrier_des(in);
    return x;
    break;
  }
  case 64: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorRngWrapper> x = ptr<OperatorRngWrapper>();
    x->op = Rng_des(in);
    return x;
    break;
  }
  case 65: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorRand2Wrapper> x = ptr<OperatorRand2Wrapper>();
    x->op = Rand2_des(in);
    return x;
    break;
  }
  case 66: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorRandGetStateWrapper> x = ptr<OperatorRandGetStateWrapper>();
    x->op = RandGetState_des(in);
    return x;
    break;
  }
  case 67: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorSetRngSeedWrapper> x = ptr<OperatorSetRngSeedWrapper>();
    x->op = SetRngSeed_des(in);
    return x;
    break;
  }
  case 68: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorRandSetStateWrapper> x = ptr<OperatorRandSetStateWrapper>();
    x->op = RandSetState_des(in);
    return x;
    break;
  }
  case 69: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorExtendedInstWrapper> x = ptr<OperatorExtendedInstWrapper>();
    x->op = ExtendedInst_des(in);
    return x;
    break;
  }
  case 70: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorTensorScalarCumulativeWrapper> x =
        ptr<OperatorTensorScalarCumulativeWrapper>();
    x->op = TensorScalarCumulative_des(in);
    return x;
    break;
  }
  case 71: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorNcNGatherWrapper> x = ptr<OperatorNcNGatherWrapper>();
    x->op = NcNGather_des(in);
    return x;
    break;
  }
  case 72: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorNonzeroWithCountWrapper> x =
        ptr<OperatorNonzeroWithCountWrapper>();
    x->op = NonzeroWithCount_des(in);
    return x;
    break;
  }
  case 73: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorDevicePrintWrapper> x = ptr<OperatorDevicePrintWrapper>();
    x->op = DevicePrint_des(in);
    return x;
    break;
  }
  case 74: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorExponentialWrapper> x = ptr<OperatorExponentialWrapper>();
    x->op = Exponential_des(in);
    return x;
    break;
  }
  default:
    throw std::runtime_error("Invalid value tag");
  }
}

Ptr<Stmt> Stmt_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not read tag");
  if (t != 103)
    throw std::runtime_error("Unexpected type tag");
  switch (c) {
  case 0: {
    if (l != 3)
      throw std::runtime_error("Wrong number of elements");
    Ptr<StmtOperWrapper> x = ptr<StmtOperWrapper>();
    x->op = Operator_des(in);
    x->name = Option_String_des(in);
    x->pos = Pos_des(in);
    return x;
    break;
  }
  default:
    throw std::runtime_error("Invalid value tag");
  }
}

Ptr<Block> Block_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting Block:104,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 104 || c != 0 || l != 2) {
    std::ostringstream msg;
    msg << "Expecting Block:(104,0,2)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<Block> x = ptr<Block>();
  x->label = String_des(in);
  x->body = List_Stmt_des(in);
  return x;
}

Ptr<Kernel> Kernel_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting Kernel:105,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 105 || c != 0 || l != 4) {
    std::ostringstream msg;
    msg << "Expecting Kernel:(105,0,4)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<Kernel> x = ptr<Kernel>();
  x->name = String_des(in);
  x->inputs = List_TensorName_des(in);
  x->outputs = List_TensorName_des(in);
  x->body = List_Block_des(in);
  return x;
}

Ptr<SharedConstantFile> SharedConstantFile_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting SharedConstantFile:106,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 106 || c != 0 || l != 2) {
    std::ostringstream msg;
    msg << "Expecting SharedConstantFile:(106,0,2)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<SharedConstantFile> x = ptr<SharedConstantFile>();
  x->name = String_des(in);
  x->fileName = String_des(in);
  return x;
}

Ptr<Edges> Edges_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting Edges:107,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 107 || c != 0 || l != 2) {
    std::ostringstream msg;
    msg << "Expecting Edges:(107,0,2)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<Edges> x = ptr<Edges>();
  x->fromEdge = String_des(in);
  x->toEdges = List_String_des(in);
  return x;
}

Ptr<LncKernel> LncKernel_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting LncKernel:108,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 108 || c != 0 || l != 7) {
    std::ostringstream msg;
    msg << "Expecting LncKernel:(108,0,7)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<LncKernel> x = ptr<LncKernel>();
  x->name = String_des(in);
  x->inputs = List_TensorName_des(in);
  x->outputs = List_TensorName_des(in);
  x->bodies = List_List_Block_des(in);
  x->sharedConstants = List_SharedConstantFile_des(in);
  x->sharedBuffers = List_TensorName_des(in);
  x->edges = List_Edges_des(in);
  return x;
}

List<Ptr<Index>> List_Index_des(FILE *in) {
  u64 size = 0;
  if (!deserialize_array_start(in, &size))
    throw std::runtime_error("expecting List");

  List<Ptr<Index>> l;
  while (size-- > 0) {
    Ptr<Index> b = Index_des(in);
    l.push_back(b);
  }
  return l;
}

List<Ptr<APPair>> List_APPair_des(FILE *in) {
  u64 size = 0;
  if (!deserialize_array_start(in, &size))
    throw std::runtime_error("expecting List");

  List<Ptr<APPair>> l;
  while (size-- > 0) {
    Ptr<APPair> b = APPair_des(in);
    l.push_back(b);
  }
  return l;
}

Option<Ptr<ScalarOffset>> Option_ScalarOffset_des(FILE *in) {
  bool isSome;
  if (!deserialize_option(in, &isSome))
    throw std::runtime_error("expecting Bool");

  Option<Ptr<ScalarOffset>> x;
  if (isSome)
    x = ScalarOffset_des(in);
  return x;
}

Option<Ptr<Access>> Option_Access_des(FILE *in) {
  bool isSome;
  if (!deserialize_option(in, &isSome))
    throw std::runtime_error("expecting Bool");

  Option<Ptr<Access>> x;
  if (isSome)
    x = Access_des(in);
  return x;
}

Option<Dtype> Option_Dtype_des(FILE *in) {
  bool isSome;
  if (!deserialize_option(in, &isSome))
    throw std::runtime_error("expecting Bool");

  Option<Dtype> x;
  if (isSome)
    x = Dtype_des(in);
  return x;
}

List<Ptr<Immediate>> List_Immediate_des(FILE *in) {
  u64 size = 0;
  if (!deserialize_array_start(in, &size))
    throw std::runtime_error("expecting List");

  List<Ptr<Immediate>> l;
  while (size-- > 0) {
    Ptr<Immediate> b = Immediate_des(in);
    l.push_back(b);
  }
  return l;
}

Option<Ptr<TensorRef>> Option_TensorRef_des(FILE *in) {
  bool isSome;
  if (!deserialize_option(in, &isSome))
    throw std::runtime_error("expecting Bool");

  Option<Ptr<TensorRef>> x;
  if (isSome)
    x = TensorRef_des(in);
  return x;
}

Option<TensorSubDim> Option_TensorSubDim_des(FILE *in) {
  bool isSome;
  if (!deserialize_option(in, &isSome))
    throw std::runtime_error("expecting Bool");

  Option<TensorSubDim> x;
  if (isSome)
    x = TensorSubDim_des(in);
  return x;
}

Option<Ptr<Operand>> Option_Operand_des(FILE *in) {
  bool isSome;
  if (!deserialize_option(in, &isSome))
    throw std::runtime_error("expecting Bool");

  Option<Ptr<Operand>> x;
  if (isSome)
    x = Operand_des(in);
  return x;
}

Option<AluOp> Option_AluOp_des(FILE *in) {
  bool isSome;
  if (!deserialize_option(in, &isSome))
    throw std::runtime_error("expecting Bool");

  Option<AluOp> x;
  if (isSome)
    x = AluOp_des(in);
  return x;
}

Option<Ptr<Immediate>> Option_Immediate_des(FILE *in) {
  bool isSome;
  if (!deserialize_option(in, &isSome))
    throw std::runtime_error("expecting Bool");

  Option<Ptr<Immediate>> x;
  if (isSome)
    x = Immediate_des(in);
  return x;
}

List<Ptr<TensorRef>> List_TensorRef_des(FILE *in) {
  u64 size = 0;
  if (!deserialize_array_start(in, &size))
    throw std::runtime_error("expecting List");

  List<Ptr<TensorRef>> l;
  while (size-- > 0) {
    Ptr<TensorRef> b = TensorRef_des(in);
    l.push_back(b);
  }
  return l;
}

List<Ptr<Stmt>> List_Stmt_des(FILE *in) {
  u64 size = 0;
  if (!deserialize_array_start(in, &size))
    throw std::runtime_error("expecting List");

  List<Ptr<Stmt>> l;
  while (size-- > 0) {
    Ptr<Stmt> b = Stmt_des(in);
    l.push_back(b);
  }
  return l;
}

List<Ptr<TensorName>> List_TensorName_des(FILE *in) {
  u64 size = 0;
  if (!deserialize_array_start(in, &size))
    throw std::runtime_error("expecting List");

  List<Ptr<TensorName>> l;
  while (size-- > 0) {
    Ptr<TensorName> b = TensorName_des(in);
    l.push_back(b);
  }
  return l;
}

List<Ptr<Block>> List_Block_des(FILE *in) {
  u64 size = 0;
  if (!deserialize_array_start(in, &size))
    throw std::runtime_error("expecting List");

  List<Ptr<Block>> l;
  while (size-- > 0) {
    Ptr<Block> b = Block_des(in);
    l.push_back(b);
  }
  return l;
}

List<List<Ptr<Block>>> List_List_Block_des(FILE *in) {
  u64 size = 0;
  if (!deserialize_array_start(in, &size))
    throw std::runtime_error("expecting List");

  List<List<Ptr<Block>>> l;
  while (size-- > 0) {
    List<Ptr<Block>> b = List_Block_des(in);
    l.push_back(b);
  }
  return l;
}

List<Ptr<SharedConstantFile>> List_SharedConstantFile_des(FILE *in) {
  u64 size = 0;
  if (!deserialize_array_start(in, &size))
    throw std::runtime_error("expecting List");

  List<Ptr<SharedConstantFile>> l;
  while (size-- > 0) {
    Ptr<SharedConstantFile> b = SharedConstantFile_des(in);
    l.push_back(b);
  }
  return l;
}

List<Ptr<Edges>> List_Edges_des(FILE *in) {
  u64 size = 0;
  if (!deserialize_array_start(in, &size))
    throw std::runtime_error("expecting List");

  List<Ptr<Edges>> l;
  while (size-- > 0) {
    Ptr<Edges> b = Edges_des(in);
    l.push_back(b);
  }
  return l;
}

bool KLRFile_ser(FILE *out, const Ptr<KLRFile> &value) {
  if (!serialize_tag(out, 217, 247, 3))
    return false;
  if (!Nat_ser(out, value->major))
    return false;
  if (!Nat_ser(out, value->minor))
    return false;
  if (!Nat_ser(out, value->patch))
    return false;
  return true;
}

bool KLRMetaData_ser(FILE *out, const Ptr<KLRMetaData> &value) {
  if (!serialize_tag(out, 235, 0, 1))
    return false;
  if (!String_ser(out, value->format))
    return false;
  return true;
}

bool Contents_ser(FILE *out, const Ptr<Contents> &value) {
  u8 tag_val = 0;
  u8 field_count = 1; // All variants have exactly 1 field

  // Map Contents tags to their serialization case numbers
  switch (value->tag) {
  case Contents::Tag::python:
    tag_val = 0;
    field_count = 1;
    break;
  case Contents::Tag::nki:
    tag_val = 1;
    field_count = 1;
    break;
  case Contents::Tag::kernel:
    tag_val = 2;
    field_count = 1;
    break;
  case Contents::Tag::lnc:
    tag_val = 3;
    field_count = 1;
    break;
  case Contents::Tag::hlo:
    tag_val = 4;
    field_count = 1;
    break;
  default:
    throw std::runtime_error("Unknown Contents type in serialization");
    return false;
  }

  // Serialize the tag
  if (!serialize_tag(out, 236, tag_val, field_count))
    return false;

  // Serialize the fields based on the specific variant
  switch (value->tag) {
  case Contents::Tag::python: {
    auto *typed_value = static_cast<const ContentsPythonWrapper *>(value.get());
    return Kernel_ser(out, typed_value->kernel);
  }
  case Contents::Tag::nki: {
    auto *typed_value = static_cast<const ContentsNkiWrapper *>(value.get());
    return Kernel_ser(out, typed_value->kernel);
  }
  case Contents::Tag::kernel: {
    auto *typed_value = static_cast<const ContentsKernelWrapper *>(value.get());
    return Kernel_ser(out, typed_value->kernel);
  }
  case Contents::Tag::lnc: {
    auto *typed_value = static_cast<const ContentsLncWrapper *>(value.get());
    return LncKernel_ser(out, typed_value->kernel);
  }
  case Contents::Tag::hlo: {
    auto *typed_value = static_cast<const ContentsHloWrapper *>(value.get());
    return String_ser(out, typed_value->name);
  }
  default:
    throw std::runtime_error("Unknown Contents type in serialization");
    return false;
  }
}

Ptr<KLRFile> KLRFile_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting KLRFile:217,247";
    throw std::runtime_error(msg.str());
  }
  if (t != 217 || c != 247 || l != 3) {
    std::ostringstream msg;
    msg << "Expecting KLRFile:(217,247,3)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<KLRFile> x = ptr<KLRFile>();
  x->major = Nat_des(in);
  x->minor = Nat_des(in);
  x->patch = Nat_des(in);
  return x;
}

Ptr<KLRMetaData> KLRMetaData_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l)) {
    std::ostringstream msg;
    msg << "Could not find tag, expecting KLRMetaData:235,0";
    throw std::runtime_error(msg.str());
  }
  if (t != 235 || c != 0 || l != 1) {
    std::ostringstream msg;
    msg << "Expecting KLRMetaData:(235,0,1)";
    msg << " got:(" << (int)t << "," << (int)c << "," << (int)l << ")";
    throw std::runtime_error(msg.str());
  }
  Ptr<KLRMetaData> x = ptr<KLRMetaData>();
  x->format = String_des(in);
  return x;
}

Ptr<Contents> Contents_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not read tag");
  if (t != 236)
    throw std::runtime_error("Unexpected type tag");
  switch (c) {
  case 0: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<ContentsPythonWrapper> x = ptr<ContentsPythonWrapper>();
    x->kernel = Kernel_des(in);
    return x;
    break;
  }
  case 1: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<ContentsNkiWrapper> x = ptr<ContentsNkiWrapper>();
    x->kernel = Kernel_des(in);
    return x;
    break;
  }
  case 2: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<ContentsKernelWrapper> x = ptr<ContentsKernelWrapper>();
    x->kernel = Kernel_des(in);
    return x;
    break;
  }
  case 3: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<ContentsLncWrapper> x = ptr<ContentsLncWrapper>();
    x->kernel = LncKernel_des(in);
    return x;
    break;
  }
  case 4: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<ContentsHloWrapper> x = ptr<ContentsHloWrapper>();
    x->name = String_des(in);
    return x;
    break;
  }
  default:
    throw std::runtime_error("Invalid value tag");
  }
}
} // namespace klr
