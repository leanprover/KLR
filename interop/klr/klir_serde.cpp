/*
Copyright (c) 2025 Amazon.com, Inc. or its affiliates. All Rights Reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Written by the KLR Contributors (https://github.com/leanprover/KLR)
*/

// This file is automatically generated from KLR.
// Manual edits to this file will be overwritten.

#include "klir_common.hpp"
#include "klir_serde.hpp"

namespace klr {

List<Bool> List_Bool_des(FILE *in) {
  u64 size = 0;
  if (!deserialize_array_start(in, &size))
    throw std::runtime_error("expecting List");

  List<Bool> l;
  while (size-- > 0) {
    Bool b = Bool_des(in);
    l.push_back(b);
  }
  return l;
}

List<Nat> List_Nat_des(FILE *in) {
  u64 size = 0;
  if (!deserialize_array_start(in, &size))
    throw std::runtime_error("expecting List");

  List<Nat> l;
  while (size-- > 0) {
    Nat b = Nat_des(in);
    l.push_back(b);
  }
  return l;
}

List<Int> List_Int_des(FILE *in) {
  u64 size = 0;
  if (!deserialize_array_start(in, &size))
    throw std::runtime_error("expecting List");

  List<Int> l;
  while (size-- > 0) {
    Int b = Int_des(in);
    l.push_back(b);
  }
  return l;
}

List<Float> List_Float_des(FILE *in) {
  u64 size = 0;
  if (!deserialize_array_start(in, &size))
    throw std::runtime_error("expecting List");

  List<Float> l;
  while (size-- > 0) {
    Float b = Float_des(in);
    l.push_back(b);
  }
  return l;
}

List<String> List_String_des(FILE *in) {
  u64 size = 0;
  if (!deserialize_array_start(in, &size))
    throw std::runtime_error("expecting List");

  List<String> l;
  while (size-- > 0) {
    String b = String_des(in);
    l.push_back(b);
  }
  return l;
}

Option<Bool> Option_Bool_des(FILE *in) {
  bool isSome;
  if (!deserialize_option(in, &isSome))
    throw std::runtime_error("expecting Bool");

  Option<Bool> x;
  if (isSome)
    x = Bool_des(in);
  return x;
}

Option<Nat> Option_Nat_des(FILE *in) {
  bool isSome;
  if (!deserialize_option(in, &isSome))
    throw std::runtime_error("expecting Bool");

  Option<Nat> x;
  if (isSome)
    x = Nat_des(in);
  return x;
}

Option<Int> Option_Int_des(FILE *in) {
  bool isSome;
  if (!deserialize_option(in, &isSome))
    throw std::runtime_error("expecting Bool");

  Option<Int> x;
  if (isSome)
    x = Int_des(in);
  return x;
}

Option<Float> Option_Float_des(FILE *in) {
  bool isSome;
  if (!deserialize_option(in, &isSome))
    throw std::runtime_error("expecting Bool");

  Option<Float> x;
  if (isSome)
    x = Float_des(in);
  return x;
}

Option<String> Option_String_des(FILE *in) {
  bool isSome;
  if (!deserialize_option(in, &isSome))
    throw std::runtime_error("expecting Bool");

  Option<String> x;
  if (isSome)
    x = String_des(in);
  return x;
}

Ptr<Pos> Pos_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not find tag");
  if (t != 100 || c != 0 || l != 4)
    throw std::runtime_error("Invalid Tag");
  Ptr<Pos> x = ptr<Pos>();
  x->line = Nat_des(in);
  x->column = Nat_des(in);
  x->lineEnd = Option_Nat_des(in);
  x->columnEnd = Option_Nat_des(in);
  return x;
}

Memory Memory_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not read tag");
  if (t != 110)
    throw std::runtime_error("Unexpected type tag");
  switch (c) {
  case 0: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return Memory::hbm;
    break;
  }
  case 1: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return Memory::sbuf;
    break;
  }
  case 2: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return Memory::psum;
    break;
  }
  case 3: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return Memory::reg;
    break;
  }
  default:
    throw std::runtime_error("Invalid value tag");
  }
}

Dtype Dtype_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not read tag");
  if (t != 111)
    throw std::runtime_error("Unexpected type tag");
  switch (c) {
  case 0: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return Dtype::bfloat16;
    break;
  }
  case 1: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return Dtype::float8e3;
    break;
  }
  case 2: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return Dtype::float8e4;
    break;
  }
  case 3: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return Dtype::float8e5;
    break;
  }
  case 4: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return Dtype::float16;
    break;
  }
  case 5: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return Dtype::float32;
    break;
  }
  case 6: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return Dtype::float32r;
    break;
  }
  case 7: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return Dtype::int8;
    break;
  }
  case 8: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return Dtype::int16;
    break;
  }
  case 9: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return Dtype::int64;
    break;
  }
  case 10: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return Dtype::int32;
    break;
  }
  case 11: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return Dtype::uint8;
    break;
  }
  case 12: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return Dtype::uint16;
    break;
  }
  case 13: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return Dtype::uint32;
    break;
  }
  case 14: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return Dtype::uint64;
    break;
  }
  default:
    throw std::runtime_error("Invalid value tag");
  }
}

Ptr<Shape> Shape_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not find tag");
  if (t != 112 || c != 0 || l != 2)
    throw std::runtime_error("Invalid Tag");
  Ptr<Shape> x = ptr<Shape>();
  x->parDim = Nat_des(in);
  x->freeDims = List_Nat_des(in);
  return x;
}

Ptr<Address> Address_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not find tag");
  if (t != 113 || c != 0 || l != 6)
    throw std::runtime_error("Invalid Tag");
  Ptr<Address> x = ptr<Address>();
  x->name = String_des(in);
  x->memory = Memory_des(in);
  x->parSize = Nat_des(in);
  x->freeSize = Nat_des(in);
  x->parOffset = Option_Nat_des(in);
  x->freeOffset = Option_Nat_des(in);
  return x;
}

Ptr<TensorName> TensorName_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not find tag");
  if (t != 114 || c != 0 || l != 7)
    throw std::runtime_error("Invalid Tag");
  Ptr<TensorName> x = ptr<TensorName>();
  x->name = String_des(in);
  x->dtype = Dtype_des(in);
  x->shape = Shape_des(in);
  x->address = Address_des(in);
  x->freeElements = Nat_des(in);
  x->parWF = Prop_des(in);
  x->freeWF = Prop_des(in);
  return x;
}

Ptr<Slice> Slice_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not find tag");
  if (t != 115 || c != 0 || l != 4)
    throw std::runtime_error("Invalid Tag");
  Ptr<Slice> x = ptr<Slice>();
  x->l = Nat_des(in);
  x->u = Nat_des(in);
  x->step = Int_des(in);
  x->wf = Prop_des(in);
  return x;
}

Ptr<Index> Index_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not read tag");
  if (t != 116)
    throw std::runtime_error("Unexpected type tag");
  switch (c) {
  case 0: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<IndexCoordWrapper> x = ptr<IndexCoordWrapper>();
    x->e = Nat_des(in);
    return x;
    break;
  }
  case 1: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<IndexSliceWrapper> x = ptr<IndexSliceWrapper>();
    x->slice = Slice_des(in);
    return x;
    break;
  }
  default:
    throw std::runtime_error("Invalid value tag");
  }
}

Ptr<AccessBasic> AccessBasic_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not find tag");
  if (t != 117 || c != 0 || l != 3)
    throw std::runtime_error("Invalid Tag");
  Ptr<AccessBasic> x = ptr<AccessBasic>();
  x->tensor = TensorName_des(in);
  x->indexes = List_Index_des(in);
  x->lenWF = Prop_des(in);
  return x;
}

Ptr<APPair> APPair_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not find tag");
  if (t != 118 || c != 0 || l != 2)
    throw std::runtime_error("Invalid Tag");
  Ptr<APPair> x = ptr<APPair>();
  x->step = Int_des(in);
  x->num = Nat_des(in);
  return x;
}

Ptr<AccessPattern> AccessPattern_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not find tag");
  if (t != 119 || c != 0 || l != 5)
    throw std::runtime_error("Invalid Tag");
  Ptr<AccessPattern> x = ptr<AccessPattern>();
  x->tensor = TensorName_des(in);
  x->parNum = Nat_des(in);
  x->freePattern = List_APPair_des(in);
  x->parOffset = Nat_des(in);
  x->freeOffset = Nat_des(in);
  return x;
}

Ptr<BirAccessPattern> BirAccessPattern_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not find tag");
  if (t != 120 || c != 0 || l != 3)
    throw std::runtime_error("Invalid Tag");
  Ptr<BirAccessPattern> x = ptr<BirAccessPattern>();
  x->tensor = TensorName_des(in);
  x->offset = Nat_des(in);
  x->pattern = List_APPair_des(in);
  return x;
}

Ptr<Access> Access_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not read tag");
  if (t != 121)
    throw std::runtime_error("Unexpected type tag");
  switch (c) {
  case 0: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<AccessSimpleWrapper> x = ptr<AccessSimpleWrapper>();
    x->tensor = TensorName_des(in);
    return x;
    break;
  }
  case 1: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<AccessBasicWrapper> x = ptr<AccessBasicWrapper>();
    x->access = AccessBasic_des(in);
    return x;
    break;
  }
  case 2: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<AccessPatternWrapper> x = ptr<AccessPatternWrapper>();
    x->access = AccessPattern_des(in);
    return x;
    break;
  }
  case 3: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<AccessBirPatternWrapper> x = ptr<AccessBirPatternWrapper>();
    x->access = BirAccessPattern_des(in);
    return x;
    break;
  }
  default:
    throw std::runtime_error("Invalid value tag");
  }
}

Ptr<TensorHbm> TensorHbm_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not find tag");
  if (t != 122 || c != 0 || l != 4)
    throw std::runtime_error("Invalid Tag");
  Ptr<TensorHbm> x = ptr<TensorHbm>();
  x->name = String_des(in);
  x->dtype = Dtype_des(in);
  x->address = Nat_des(in);
  x->dims = List_APPair_des(in);
  return x;
}

Ptr<TensorSram> TensorSram_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not find tag");
  if (t != 123 || c != 0 || l != 6)
    throw std::runtime_error("Invalid Tag");
  Ptr<TensorSram> x = ptr<TensorSram>();
  x->name = String_des(in);
  x->dtype = Dtype_des(in);
  x->parNum = Nat_des(in);
  x->freePattern = List_APPair_des(in);
  x->parOffset = Nat_des(in);
  x->freeOffset = Nat_des(in);
  return x;
}

Ptr<TensorRef> TensorRef_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not read tag");
  if (t != 124)
    throw std::runtime_error("Unexpected type tag");
  switch (c) {
  case 0: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<TensorRefAbstractWrapper> x = ptr<TensorRefAbstractWrapper>();
    x->access = Access_des(in);
    return x;
    break;
  }
  case 1: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<TensorRefSbufWrapper> x = ptr<TensorRefSbufWrapper>();
    x->view = TensorSram_des(in);
    return x;
    break;
  }
  case 2: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<TensorRefPsumWrapper> x = ptr<TensorRefPsumWrapper>();
    x->view = TensorSram_des(in);
    return x;
    break;
  }
  case 3: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<TensorRefHbmWrapper> x = ptr<TensorRefHbmWrapper>();
    x->view = TensorHbm_des(in);
    return x;
    break;
  }
  case 4: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<TensorRefRegisterWrapper> x = ptr<TensorRefRegisterWrapper>();
    x->reg = Nat_des(in);
    return x;
    break;
  }
  default:
    throw std::runtime_error("Invalid value tag");
  }
}

Engine Engine_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not read tag");
  if (t != 130)
    throw std::runtime_error("Unexpected type tag");
  switch (c) {
  case 0: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return Engine::unassigned;
    break;
  }
  case 1: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return Engine::act;
    break;
  }
  case 2: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return Engine::dma;
    break;
  }
  case 3: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return Engine::dve;
    break;
  }
  case 4: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return Engine::pe;
    break;
  }
  case 5: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return Engine::pool;
    break;
  }
  case 6: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return Engine::sp;
    break;
  }
  default:
    throw std::runtime_error("Invalid value tag");
  }
}

Ptr<Immediate> Immediate_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not read tag");
  if (t != 131)
    throw std::runtime_error("Unexpected type tag");
  switch (c) {
  case 0: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<ImmediateRegisterWrapper> x = ptr<ImmediateRegisterWrapper>();
    x->reg = Nat_des(in);
    return x;
    break;
  }
  case 1: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    Ptr<ImmediatePointerWrapper> x = ptr<ImmediatePointerWrapper>();
    return x;
    break;
  }
  case 2: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<ImmediateIntWrapper> x = ptr<ImmediateIntWrapper>();
    x->i = Int_des(in);
    return x;
    break;
  }
  case 3: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<ImmediateFloatWrapper> x = ptr<ImmediateFloatWrapper>();
    x->f = Float_des(in);
    return x;
    break;
  }
  default:
    throw std::runtime_error("Invalid value tag");
  }
}

Ptr<ActivationImm> ActivationImm_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not read tag");
  if (t != 132)
    throw std::runtime_error("Unexpected type tag");
  switch (c) {
  case 0: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<ActivationImmRegisterWrapper> x = ptr<ActivationImmRegisterWrapper>();
    x->reg = Nat_des(in);
    return x;
    break;
  }
  case 1: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    Ptr<ActivationImmPointerWrapper> x = ptr<ActivationImmPointerWrapper>();
    return x;
    break;
  }
  case 2: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<ActivationImmFloatWrapper> x = ptr<ActivationImmFloatWrapper>();
    x->f = Float_des(in);
    return x;
    break;
  }
  default:
    throw std::runtime_error("Invalid value tag");
  }
}

Ptr<Operand> Operand_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not read tag");
  if (t != 133)
    throw std::runtime_error("Unexpected type tag");
  switch (c) {
  case 0: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperandImmWrapper> x = ptr<OperandImmWrapper>();
    x->i = Immediate_des(in);
    return x;
    break;
  }
  case 1: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperandTileWrapper> x = ptr<OperandTileWrapper>();
    x->t = TensorRef_des(in);
    return x;
    break;
  }
  default:
    throw std::runtime_error("Invalid value tag");
  }
}

Ptr<DataPattern> DataPattern_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not find tag");
  if (t != 134 || c != 0 || l != 3)
    throw std::runtime_error("Invalid Tag");
  Ptr<DataPattern> x = ptr<DataPattern>();
  x->offset = Nat_des(in);
  x->pattern = List_APPair_des(in);
  x->channelMultiplier = Int_des(in);
  return x;
}

AluOp AluOp_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not read tag");
  if (t != 135)
    throw std::runtime_error("Unexpected type tag");
  switch (c) {
  case 0: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return AluOp::abs;
    break;
  }
  case 1: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return AluOp::add;
    break;
  }
  case 2: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return AluOp::arith_shift_left;
    break;
  }
  case 3: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return AluOp::arith_shift_right;
    break;
  }
  case 4: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return AluOp::average;
    break;
  }
  case 5: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return AluOp::bitwise_and;
    break;
  }
  case 6: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return AluOp::bitwise_not;
    break;
  }
  case 7: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return AluOp::bitwise_or;
    break;
  }
  case 8: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return AluOp::bitwise_xor;
    break;
  }
  case 9: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return AluOp::bypass;
    break;
  }
  case 10: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return AluOp::divide;
    break;
  }
  case 11: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return AluOp::is_equal;
    break;
  }
  case 12: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return AluOp::is_ge;
    break;
  }
  case 13: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return AluOp::is_gt;
    break;
  }
  case 14: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return AluOp::is_le;
    break;
  }
  case 15: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return AluOp::is_lt;
    break;
  }
  case 16: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return AluOp::logical_and;
    break;
  }
  case 17: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return AluOp::logical_or;
    break;
  }
  case 18: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return AluOp::logical_shift_left;
    break;
  }
  case 19: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return AluOp::logical_shift_right;
    break;
  }
  case 20: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return AluOp::logical_xor;
    break;
  }
  case 21: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return AluOp::max;
    break;
  }
  case 22: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return AluOp::min;
    break;
  }
  case 23: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return AluOp::mod;
    break;
  }
  case 24: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return AluOp::mult;
    break;
  }
  case 25: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return AluOp::not_equal;
    break;
  }
  case 26: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return AluOp::pow;
    break;
  }
  case 27: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return AluOp::rsqrt;
    break;
  }
  case 28: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return AluOp::subtract;
    break;
  }
  default:
    throw std::runtime_error("Invalid value tag");
  }
}

DropoutThresholdType DropoutThresholdType_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not read tag");
  if (t != 136)
    throw std::runtime_error("Unexpected type tag");
  switch (c) {
  case 0: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return DropoutThresholdType::DropRate;
    break;
  }
  case 1: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return DropoutThresholdType::KeepRate;
    break;
  }
  default:
    throw std::runtime_error("Invalid value tag");
  }
}

AccumCmd AccumCmd_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not read tag");
  if (t != 137)
    throw std::runtime_error("Unexpected type tag");
  switch (c) {
  case 0: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return AccumCmd::Idle;
    break;
  }
  case 1: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return AccumCmd::Zero;
    break;
  }
  case 2: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return AccumCmd::Accumulate;
    break;
  }
  case 3: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return AccumCmd::ZeroAccumulate;
    break;
  }
  case 4: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return AccumCmd::LoadAccumulate;
    break;
  }
  default:
    throw std::runtime_error("Invalid value tag");
  }
}

ActivationFunc ActivationFunc_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not read tag");
  if (t != 138)
    throw std::runtime_error("Unexpected type tag");
  switch (c) {
  case 0: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return ActivationFunc::abs;
    break;
  }
  case 1: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return ActivationFunc::arctan;
    break;
  }
  case 2: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return ActivationFunc::copy;
    break;
  }
  case 3: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return ActivationFunc::erf;
    break;
  }
  case 4: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return ActivationFunc::erf_dx;
    break;
  }
  case 5: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return ActivationFunc::exp;
    break;
  }
  case 6: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return ActivationFunc::gelu;
    break;
  }
  case 7: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return ActivationFunc::gelu_apprx_tanh;
    break;
  }
  case 8: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return ActivationFunc::gelu_dx;
    break;
  }
  case 9: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return ActivationFunc::log;
    break;
  }
  case 10: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return ActivationFunc::mish;
    break;
  }
  case 11: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return ActivationFunc::reciprocal;
    break;
  }
  case 12: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return ActivationFunc::relu;
    break;
  }
  case 13: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return ActivationFunc::rsqrt;
    break;
  }
  case 14: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return ActivationFunc::sigmoid;
    break;
  }
  case 15: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return ActivationFunc::sign;
    break;
  }
  case 16: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return ActivationFunc::silu;
    break;
  }
  case 17: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return ActivationFunc::silu_dx;
    break;
  }
  case 18: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return ActivationFunc::sin;
    break;
  }
  case 19: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return ActivationFunc::softplus;
    break;
  }
  case 20: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return ActivationFunc::sqrt;
    break;
  }
  case 21: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return ActivationFunc::square;
    break;
  }
  case 22: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return ActivationFunc::tanh;
    break;
  }
  default:
    throw std::runtime_error("Invalid value tag");
  }
}

AffineSelectCmp AffineSelectCmp_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not read tag");
  if (t != 139)
    throw std::runtime_error("Unexpected type tag");
  switch (c) {
  case 0: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return AffineSelectCmp::GreaterThan;
    break;
  }
  case 1: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return AffineSelectCmp::GreaterThanEq;
    break;
  }
  case 2: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return AffineSelectCmp::Eq;
    break;
  }
  case 3: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return AffineSelectCmp::NotEq;
    break;
  }
  default:
    throw std::runtime_error("Invalid value tag");
  }
}

DgeComputeOp DgeComputeOp_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not read tag");
  if (t != 140)
    throw std::runtime_error("Unexpected type tag");
  switch (c) {
  case 0: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return DgeComputeOp::none;
    break;
  }
  case 1: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return DgeComputeOp::add;
    break;
  }
  default:
    throw std::runtime_error("Invalid value tag");
  }
}

Ptr<DmaBounds> DmaBounds_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not read tag");
  if (t != 141)
    throw std::runtime_error("Unexpected type tag");
  switch (c) {
  case 0: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    Ptr<DmaBoundsDisableWrapper> x = ptr<DmaBoundsDisableWrapper>();
    return x;
    break;
  }
  case 1: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    Ptr<DmaBoundsEnableWrapper> x = ptr<DmaBoundsEnableWrapper>();
    return x;
    break;
  }
  case 2: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<DmaBoundsRegWrapper> x = ptr<DmaBoundsRegWrapper>();
    x->reg = Nat_des(in);
    return x;
    break;
  }
  default:
    throw std::runtime_error("Invalid value tag");
  }
}

MatmulGroupElement MatmulGroupElement_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not read tag");
  if (t != 142)
    throw std::runtime_error("Unexpected type tag");
  switch (c) {
  case 0: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return MatmulGroupElement::first;
    break;
  }
  case 1: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return MatmulGroupElement::middle;
    break;
  }
  case 2: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return MatmulGroupElement::last;
    break;
  }
  case 3: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return MatmulGroupElement::whole;
    break;
  }
  default:
    throw std::runtime_error("Invalid value tag");
  }
}

Ptr<IndexMissBehavior> IndexMissBehavior_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not read tag");
  if (t != 143)
    throw std::runtime_error("Unexpected type tag");
  switch (c) {
  case 0: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<IndexMissBehaviorImmWrapper> x = ptr<IndexMissBehaviorImmWrapper>();
    x->value = Immediate_des(in);
    return x;
    break;
  }
  case 1: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    Ptr<IndexMissBehaviorSkipWrapper> x = ptr<IndexMissBehaviorSkipWrapper>();
    return x;
    break;
  }
  default:
    throw std::runtime_error("Invalid value tag");
  }
}

TensorScalarReverseOps TensorScalarReverseOps_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not read tag");
  if (t != 144)
    throw std::runtime_error("Unexpected type tag");
  switch (c) {
  case 0: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return TensorScalarReverseOps::none;
    break;
  }
  case 1: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return TensorScalarReverseOps::first;
    break;
  }
  case 2: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return TensorScalarReverseOps::second;
    break;
  }
  case 3: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return TensorScalarReverseOps::both;
    break;
  }
  default:
    throw std::runtime_error("Invalid value tag");
  }
}

TensorSubDim TensorSubDim_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not read tag");
  if (t != 145)
    throw std::runtime_error("Unexpected type tag");
  switch (c) {
  case 0: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return TensorSubDim::X;
    break;
  }
  case 1: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return TensorSubDim::XY;
    break;
  }
  case 2: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return TensorSubDim::XYZ;
    break;
  }
  case 3: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return TensorSubDim::XYZW;
    break;
  }
  default:
    throw std::runtime_error("Invalid value tag");
  }
}

TransposeOps TransposeOps_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not read tag");
  if (t != 146)
    throw std::runtime_error("Unexpected type tag");
  switch (c) {
  case 0: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return TransposeOps::None;
    break;
  }
  case 1: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return TransposeOps::WZXY;
    break;
  }
  case 2: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return TransposeOps::WXZY;
    break;
  }
  case 3: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return TransposeOps::WYXZ;
    break;
  }
  case 4: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return TransposeOps::ZWYX;
    break;
  }
  case 5: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return TransposeOps::ZYWX;
    break;
  }
  case 6: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return TransposeOps::ZYXW;
    break;
  }
  case 7: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return TransposeOps::YXWZ;
    break;
  }
  case 8: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return TransposeOps::YXZW;
    break;
  }
  case 9: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return TransposeOps::YWZX;
    break;
  }
  case 10: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return TransposeOps::XWZY;
    break;
  }
  case 11: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return TransposeOps::XZYW;
    break;
  }
  case 12: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return TransposeOps::XYZW;
    break;
  }
  case 13: {
    if (l != 0)
      throw std::runtime_error("Wrong number of elements");
    return TransposeOps::XYWZ;
    break;
  }
  default:
    throw std::runtime_error("Invalid value tag");
  }
}

Ptr<Dropout> Dropout_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not find tag");
  if (t != 147 || c != 0 || l != 5)
    throw std::runtime_error("Invalid Tag");
  Ptr<Dropout> x = ptr<Dropout>();
  x->dst = TensorRef_des(in);
  x->src = TensorRef_des(in);
  x->thresholdType = DropoutThresholdType_des(in);
  x->threshold = Operand_des(in);
  x->dtype = Option_Dtype_des(in);
  return x;
}

Ptr<Activate> Activate_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not find tag");
  if (t != 148 || c != 0 || l != 7)
    throw std::runtime_error("Invalid Tag");
  Ptr<Activate> x = ptr<Activate>();
  x->dst = TensorRef_des(in);
  x->src = TensorRef_des(in);
  x->accumulatorCmd = AccumCmd_des(in);
  x->activationFunc = ActivationFunc_des(in);
  x->scale = Immediate_des(in);
  x->bias = Immediate_des(in);
  x->imm = Immediate_des(in);
  return x;
}

Ptr<AffineSelect> AffineSelect_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not find tag");
  if (t != 150 || c != 0 || l != 5)
    throw std::runtime_error("Invalid Tag");
  Ptr<AffineSelect> x = ptr<AffineSelect>();
  x->dst = TensorRef_des(in);
  x->src = TensorRef_des(in);
  x->fillMode = AffineSelectCmp_des(in);
  x->fillReg = Nat_des(in);
  x->maskPattern = DataPattern_des(in);
  return x;
}

Ptr<DmaCopy> DmaCopy_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not find tag");
  if (t != 152 || c != 0 || l != 5)
    throw std::runtime_error("Invalid Tag");
  Ptr<DmaCopy> x = ptr<DmaCopy>();
  x->dst = TensorRef_des(in);
  x->src = TensorRef_des(in);
  x->compute_op = DgeComputeOp_des(in);
  x->dstBoundsCheck = DmaBounds_des(in);
  x->srcBoundsCheck = DmaBounds_des(in);
  return x;
}

Ptr<DmaTranspose> DmaTranspose_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not find tag");
  if (t != 154 || c != 0 || l != 5)
    throw std::runtime_error("Invalid Tag");
  Ptr<DmaTranspose> x = ptr<DmaTranspose>();
  x->dst = TensorRef_des(in);
  x->src = TensorRef_des(in);
  x->axes = TransposeOps_des(in);
  x->dtype = Option_Dtype_des(in);
  x->dgeMode = Nat_des(in);
  return x;
}

Ptr<Transpose> Transpose_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not find tag");
  if (t != 155 || c != 0 || l != 4)
    throw std::runtime_error("Invalid Tag");
  Ptr<Transpose> x = ptr<Transpose>();
  x->dst = TensorRef_des(in);
  x->src = TensorRef_des(in);
  x->dtype = Option_Dtype_des(in);
  x->engine = Engine_des(in);
  return x;
}

Ptr<LoadMaskRegister> LoadMaskRegister_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not find tag");
  if (t != 156 || c != 0 || l != 1)
    throw std::runtime_error("Invalid Tag");
  Ptr<LoadMaskRegister> x = ptr<LoadMaskRegister>();
  x->regNum = Nat_des(in);
  return x;
}

Ptr<Shuffle> Shuffle_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not find tag");
  if (t != 157 || c != 0 || l != 4)
    throw std::runtime_error("Invalid Tag");
  Ptr<Shuffle> x = ptr<Shuffle>();
  x->dst = TensorRef_des(in);
  x->src = TensorRef_des(in);
  x->shuffleMask = List_Immediate_des(in);
  x->dtype = Option_Dtype_des(in);
  return x;
}

Ptr<MemSet> MemSet_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not find tag");
  if (t != 158 || c != 0 || l != 4)
    throw std::runtime_error("Invalid Tag");
  Ptr<MemSet> x = ptr<MemSet>();
  x->dst = TensorRef_des(in);
  x->value = Immediate_des(in);
  x->dtype = Dtype_des(in);
  x->engine = Engine_des(in);
  return x;
}

Ptr<Iota> Iota_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not find tag");
  if (t != 159 || c != 0 || l != 3)
    throw std::runtime_error("Invalid Tag");
  Ptr<Iota> x = ptr<Iota>();
  x->dst = TensorRef_des(in);
  x->pattern = DataPattern_des(in);
  x->dtype = Option_Dtype_des(in);
  return x;
}

Ptr<LoadStationary> LoadStationary_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not find tag");
  if (t != 160 || c != 0 || l != 2)
    throw std::runtime_error("Invalid Tag");
  Ptr<LoadStationary> x = ptr<LoadStationary>();
  x->src = TensorRef_des(in);
  x->isTranspose = Bool_des(in);
  return x;
}

Ptr<MatMul> MatMul_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not find tag");
  if (t != 161 || c != 0 || l != 3)
    throw std::runtime_error("Invalid Tag");
  Ptr<MatMul> x = ptr<MatMul>();
  x->dst = TensorRef_des(in);
  x->moving = TensorRef_des(in);
  x->psumAccumulateFlag = MatmulGroupElement_des(in);
  return x;
}

Ptr<LocalGather> LocalGather_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not find tag");
  if (t != 162 || c != 0 || l != 4)
    throw std::runtime_error("Invalid Tag");
  Ptr<LocalGather> x = ptr<LocalGather>();
  x->dst = TensorRef_des(in);
  x->src = TensorRef_des(in);
  x->indexMissBehavior = IndexMissBehavior_des(in);
  x->freePoolBuffer = Bool_des(in);
  return x;
}

Ptr<RangeSelect> RangeSelect_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not find tag");
  if (t != 164 || c != 0 || l != 10)
    throw std::runtime_error("Invalid Tag");
  Ptr<RangeSelect> x = ptr<RangeSelect>();
  x->dst = TensorRef_des(in);
  x->src = TensorRef_des(in);
  x->reduceCommand = AccumCmd_des(in);
  x->reduceOp = AluOp_des(in);
  x->base = Float_des(in);
  x->fillValue = Float_des(in);
  x->compOp0 = AluOp_des(in);
  x->compOp1 = AluOp_des(in);
  x->bound0 = Immediate_des(in);
  x->bound1 = Immediate_des(in);
  return x;
}

Ptr<ScalarTensorTensor> ScalarTensorTensor_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not find tag");
  if (t != 166 || c != 0 || l != 8)
    throw std::runtime_error("Invalid Tag");
  Ptr<ScalarTensorTensor> x = ptr<ScalarTensorTensor>();
  x->dst = TensorRef_des(in);
  x->src0 = TensorRef_des(in);
  x->src1 = TensorRef_des(in);
  x->op0 = AluOp_des(in);
  x->op1 = AluOp_des(in);
  x->reverseOperands = TensorScalarReverseOps_des(in);
  x->imm0 = Immediate_des(in);
  x->accumulatorCmd = AccumCmd_des(in);
  return x;
}

Ptr<CopyPredicated> CopyPredicated_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not find tag");
  if (t != 168 || c != 0 || l != 5)
    throw std::runtime_error("Invalid Tag");
  Ptr<CopyPredicated> x = ptr<CopyPredicated>();
  x->dst = TensorRef_des(in);
  x->src = TensorRef_des(in);
  x->predicate = TensorRef_des(in);
  x->dtype = Option_Dtype_des(in);
  x->reversePred = Bool_des(in);
  return x;
}

Ptr<TensorTensorScan> TensorTensorScan_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not find tag");
  if (t != 169 || c != 0 || l != 9)
    throw std::runtime_error("Invalid Tag");
  Ptr<TensorTensorScan> x = ptr<TensorTensorScan>();
  x->dst = TensorRef_des(in);
  x->src0 = TensorRef_des(in);
  x->src1 = TensorRef_des(in);
  x->op0 = AluOp_des(in);
  x->op1 = AluOp_des(in);
  x->reverseOperands = TensorScalarReverseOps_des(in);
  x->imm0 = Operand_des(in);
  x->accumulatorCmd = AccumCmd_des(in);
  x->dtype = Option_Dtype_des(in);
  return x;
}

Ptr<MatchValueLoad> MatchValueLoad_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not find tag");
  if (t != 170 || c != 0 || l != 1)
    throw std::runtime_error("Invalid Tag");
  Ptr<MatchValueLoad> x = ptr<MatchValueLoad>();
  x->src = TensorRef_des(in);
  return x;
}

Ptr<FindIndex8> FindIndex8_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not find tag");
  if (t != 171 || c != 0 || l != 4)
    throw std::runtime_error("Invalid Tag");
  Ptr<FindIndex8> x = ptr<FindIndex8>();
  x->dst = TensorRef_des(in);
  x->src = TensorRef_des(in);
  x->vals = TensorRef_des(in);
  x->dtype = Option_Dtype_des(in);
  return x;
}

Ptr<MatchReplace8> MatchReplace8_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not find tag");
  if (t != 172 || c != 0 || l != 6)
    throw std::runtime_error("Invalid Tag");
  Ptr<MatchReplace8> x = ptr<MatchReplace8>();
  x->dst = TensorRef_des(in);
  x->src = TensorRef_des(in);
  x->vals = TensorRef_des(in);
  x->replaceValue = Immediate_des(in);
  x->dstIdx = Option_TensorRef_des(in);
  x->dtype = Option_Dtype_des(in);
  return x;
}

Ptr<Max8> Max8_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not find tag");
  if (t != 173 || c != 0 || l != 3)
    throw std::runtime_error("Invalid Tag");
  Ptr<Max8> x = ptr<Max8>();
  x->dst = TensorRef_des(in);
  x->src = TensorRef_des(in);
  x->dtype = Option_Dtype_des(in);
  return x;
}

Ptr<BatchNormAggregate> BatchNormAggregate_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not find tag");
  if (t != 174 || c != 0 || l != 3)
    throw std::runtime_error("Invalid Tag");
  Ptr<BatchNormAggregate> x = ptr<BatchNormAggregate>();
  x->dst = TensorRef_des(in);
  x->src = TensorRef_des(in);
  x->dtype = Option_Dtype_des(in);
  return x;
}

Ptr<BatchNormStats> BatchNormStats_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not find tag");
  if (t != 175 || c != 0 || l != 3)
    throw std::runtime_error("Invalid Tag");
  Ptr<BatchNormStats> x = ptr<BatchNormStats>();
  x->dst = TensorRef_des(in);
  x->src = TensorRef_des(in);
  x->dtype = Option_Dtype_des(in);
  return x;
}

Ptr<Reciprocal> Reciprocal_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not find tag");
  if (t != 176 || c != 0 || l != 3)
    throw std::runtime_error("Invalid Tag");
  Ptr<Reciprocal> x = ptr<Reciprocal>();
  x->dst = TensorRef_des(in);
  x->src = TensorRef_des(in);
  x->dtype = Option_Dtype_des(in);
  return x;
}

Ptr<Copy> Copy_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not find tag");
  if (t != 177 || c != 0 || l != 3)
    throw std::runtime_error("Invalid Tag");
  Ptr<Copy> x = ptr<Copy>();
  x->dst = TensorRef_des(in);
  x->src = TensorRef_des(in);
  x->opDim = Option_TensorSubDim_des(in);
  return x;
}

Ptr<TensorReduce> TensorReduce_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not find tag");
  if (t != 179 || c != 0 || l != 7)
    throw std::runtime_error("Invalid Tag");
  Ptr<TensorReduce> x = ptr<TensorReduce>();
  x->dst = TensorRef_des(in);
  x->src = TensorRef_des(in);
  x->op = AluOp_des(in);
  x->opDim = TensorSubDim_des(in);
  x->negated = Bool_des(in);
  x->dtype = Option_Dtype_des(in);
  x->keepdims = Bool_des(in);
  return x;
}

Ptr<TensorScalar> TensorScalar_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not find tag");
  if (t != 180 || c != 0 || l != 9)
    throw std::runtime_error("Invalid Tag");
  Ptr<TensorScalar> x = ptr<TensorScalar>();
  x->dst = TensorRef_des(in);
  x->src = TensorRef_des(in);
  x->imm0 = Operand_des(in);
  x->op0 = AluOp_des(in);
  x->imm1 = Option_Operand_des(in);
  x->op1 = Option_AluOp_des(in);
  x->reverse = TensorScalarReverseOps_des(in);
  x->engine = Engine_des(in);
  x->dtype = Option_Dtype_des(in);
  return x;
}

Ptr<TensorTensor> TensorTensor_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not find tag");
  if (t != 182 || c != 0 || l != 6)
    throw std::runtime_error("Invalid Tag");
  Ptr<TensorTensor> x = ptr<TensorTensor>();
  x->dst = TensorRef_des(in);
  x->src0 = TensorRef_des(in);
  x->src1 = TensorRef_des(in);
  x->op = AluOp_des(in);
  x->dtype = Option_Dtype_des(in);
  x->engine = Engine_des(in);
  return x;
}

Ptr<NcMatMul> NcMatMul_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not find tag");
  if (t != 183 || c != 0 || l != 8)
    throw std::runtime_error("Invalid Tag");
  Ptr<NcMatMul> x = ptr<NcMatMul>();
  x->dst = TensorRef_des(in);
  x->stationary = TensorRef_des(in);
  x->moving = TensorRef_des(in);
  x->isStationaryOneZero = Bool_des(in);
  x->isMovingZero = Bool_des(in);
  x->isTranspose = Bool_des(in);
  x->tilePosition = List_Nat_des(in);
  x->tileSize = List_Nat_des(in);
  return x;
}

Ptr<TensorScalarReduce> TensorScalarReduce_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not find tag");
  if (t != 181 || c != 0 || l != 8)
    throw std::runtime_error("Invalid Tag");
  Ptr<TensorScalarReduce> x = ptr<TensorScalarReduce>();
  x->dst = TensorRef_des(in);
  x->src = TensorRef_des(in);
  x->operand0 = Operand_des(in);
  x->op0 = AluOp_des(in);
  x->reverse0 = Bool_des(in);
  x->dtype = Option_Dtype_des(in);
  x->reduceOp = Option_AluOp_des(in);
  x->reduceRes = TensorRef_des(in);
  return x;
}

Ptr<TensorPartitionReduce> TensorPartitionReduce_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not find tag");
  if (t != 184 || c != 0 || l != 4)
    throw std::runtime_error("Invalid Tag");
  Ptr<TensorPartitionReduce> x = ptr<TensorPartitionReduce>();
  x->dst = TensorRef_des(in);
  x->op = AluOp_des(in);
  x->data = TensorRef_des(in);
  x->dtype = Option_Dtype_des(in);
  return x;
}

Ptr<NcActivate> NcActivate_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not find tag");
  if (t != 149 || c != 0 || l != 9)
    throw std::runtime_error("Invalid Tag");
  Ptr<NcActivate> x = ptr<NcActivate>();
  x->dst = TensorRef_des(in);
  x->src = TensorRef_des(in);
  x->accumulatorCmd = AccumCmd_des(in);
  x->activationFunc = ActivationFunc_des(in);
  x->scale = Immediate_des(in);
  x->bias = Immediate_des(in);
  x->reduceOp = Option_AluOp_des(in);
  x->reduceRes = Option_TensorRef_des(in);
  x->dtype = Option_Dtype_des(in);
  return x;
}

Ptr<NcAffineSelect> NcAffineSelect_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not find tag");
  if (t != 151 || c != 0 || l != 6)
    throw std::runtime_error("Invalid Tag");
  Ptr<NcAffineSelect> x = ptr<NcAffineSelect>();
  x->dst = TensorRef_des(in);
  x->pred = DataPattern_des(in);
  x->onTrueTile = TensorRef_des(in);
  x->onFalseValue = Immediate_des(in);
  x->dtype = Option_Dtype_des(in);
  x->cmpOp = AluOp_des(in);
  return x;
}

Ptr<NcDmaCopy> NcDmaCopy_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not find tag");
  if (t != 153 || c != 0 || l != 5)
    throw std::runtime_error("Invalid Tag");
  Ptr<NcDmaCopy> x = ptr<NcDmaCopy>();
  x->dst = TensorRef_des(in);
  x->src = TensorRef_des(in);
  x->compute_op = DgeComputeOp_des(in);
  x->oobMode = DmaBounds_des(in);
  x->dgeMode = Nat_des(in);
  return x;
}

Ptr<NcLocalGather> NcLocalGather_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not find tag");
  if (t != 163 || c != 0 || l != 5)
    throw std::runtime_error("Invalid Tag");
  Ptr<NcLocalGather> x = ptr<NcLocalGather>();
  x->dst = TensorRef_des(in);
  x->src = TensorRef_des(in);
  x->index = TensorRef_des(in);
  x->numElemPerIdx = Immediate_des(in);
  x->numValidIndicies = Option_Immediate_des(in);
  return x;
}

Ptr<NcRangeSelect> NcRangeSelect_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not find tag");
  if (t != 165 || c != 0 || l != 12)
    throw std::runtime_error("Invalid Tag");
  Ptr<NcRangeSelect> x = ptr<NcRangeSelect>();
  x->dst = TensorRef_des(in);
  x->reduceCommand = AccumCmd_des(in);
  x->reduceRes = Option_TensorRef_des(in);
  x->reduceOp = Option_AluOp_des(in);
  x->compOp0 = AluOp_des(in);
  x->compOp1 = AluOp_des(in);
  x->bound0 = TensorRef_des(in);
  x->bound1 = TensorRef_des(in);
  x->rangeStart = Immediate_des(in);
  x->onTrueTile = TensorRef_des(in);
  x->onFalseValue = Immediate_des(in);
  x->dtype = Option_Dtype_des(in);
  return x;
}

Ptr<NcScalarTensorTensor> NcScalarTensorTensor_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not find tag");
  if (t != 167 || c != 0 || l != 8)
    throw std::runtime_error("Invalid Tag");
  Ptr<NcScalarTensorTensor> x = ptr<NcScalarTensorTensor>();
  x->dst = TensorRef_des(in);
  x->data = TensorRef_des(in);
  x->src0 = Operand_des(in);
  x->src1 = Operand_des(in);
  x->op0 = AluOp_des(in);
  x->op1 = AluOp_des(in);
  x->reverseOperands = TensorScalarReverseOps_des(in);
  x->dtype = Option_Dtype_des(in);
  return x;
}

Ptr<NcCopy> NcCopy_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not find tag");
  if (t != 178 || c != 0 || l != 4)
    throw std::runtime_error("Invalid Tag");
  Ptr<NcCopy> x = ptr<NcCopy>();
  x->dst = TensorRef_des(in);
  x->src = TensorRef_des(in);
  x->dtype = Option_Dtype_des(in);
  x->engine = Engine_des(in);
  return x;
}

Ptr<SelectReduce> SelectReduce_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not find tag");
  if (t != 185 || c != 0 || l != 9)
    throw std::runtime_error("Invalid Tag");
  Ptr<SelectReduce> x = ptr<SelectReduce>();
  x->dst = TensorRef_des(in);
  x->predicate = TensorRef_des(in);
  x->onTrue = TensorRef_des(in);
  x->onFalse = Operand_des(in);
  x->reduceRes = Option_TensorRef_des(in);
  x->reduceCmd = AccumCmd_des(in);
  x->reduceOp = AluOp_des(in);
  x->reversePred = Bool_des(in);
  x->dtype = Option_Dtype_des(in);
  return x;
}

Ptr<SequenceBounds> SequenceBounds_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not find tag");
  if (t != 186 || c != 0 || l != 3)
    throw std::runtime_error("Invalid Tag");
  Ptr<SequenceBounds> x = ptr<SequenceBounds>();
  x->dst = TensorRef_des(in);
  x->segmentIds = TensorRef_des(in);
  x->dtype = Option_Dtype_des(in);
  return x;
}

Ptr<SendRecv> SendRecv_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not find tag");
  if (t != 187 || c != 0 || l != 6)
    throw std::runtime_error("Invalid Tag");
  Ptr<SendRecv> x = ptr<SendRecv>();
  x->dst = TensorRef_des(in);
  x->src = TensorRef_des(in);
  x->sendToRank = Immediate_des(in);
  x->recvFromRank = Immediate_des(in);
  x->pipeId = Immediate_des(in);
  x->useGpsimdDma = Bool_des(in);
  return x;
}

Ptr<SendRecvCCE> SendRecvCCE_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not find tag");
  if (t != 188 || c != 0 || l != 6)
    throw std::runtime_error("Invalid Tag");
  Ptr<SendRecvCCE> x = ptr<SendRecvCCE>();
  x->dst = TensorRef_des(in);
  x->src = List_TensorRef_des(in);
  x->sendToRank = Immediate_des(in);
  x->recvFromRanks = List_Immediate_des(in);
  x->pipeId = Immediate_des(in);
  x->op = AluOp_des(in);
  return x;
}

Ptr<Operator> Operator_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not read tag");
  if (t != 189)
    throw std::runtime_error("Unexpected type tag");
  switch (c) {
  case 0: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorActivateWrapper> x = ptr<OperatorActivateWrapper>();
    x->op = Activate_des(in);
    return x;
    break;
  }
  case 1: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorNcActivateWrapper> x = ptr<OperatorNcActivateWrapper>();
    x->op = NcActivate_des(in);
    return x;
    break;
  }
  case 2: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorActivationReduceWrapper> x =
        ptr<OperatorActivationReduceWrapper>();
    x->op = NcActivate_des(in);
    return x;
    break;
  }
  case 3: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorAffineSelectWrapper> x = ptr<OperatorAffineSelectWrapper>();
    x->op = AffineSelect_des(in);
    return x;
    break;
  }
  case 4: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorNcAffineSelectWrapper> x = ptr<OperatorNcAffineSelectWrapper>();
    x->op = NcAffineSelect_des(in);
    return x;
    break;
  }
  case 5: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorBatchNormAggregateWrapper> x =
        ptr<OperatorBatchNormAggregateWrapper>();
    x->op = BatchNormAggregate_des(in);
    return x;
    break;
  }
  case 6: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorBatchNormStatsWrapper> x = ptr<OperatorBatchNormStatsWrapper>();
    x->op = BatchNormStats_des(in);
    return x;
    break;
  }
  case 7: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorCopyWrapper> x = ptr<OperatorCopyWrapper>();
    x->op = Copy_des(in);
    return x;
    break;
  }
  case 8: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorNcCopyWrapper> x = ptr<OperatorNcCopyWrapper>();
    x->op = NcCopy_des(in);
    return x;
    break;
  }
  case 9: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorCopyPredicatedWrapper> x = ptr<OperatorCopyPredicatedWrapper>();
    x->op = CopyPredicated_des(in);
    return x;
    break;
  }
  case 10: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorDmaCopyWrapper> x = ptr<OperatorDmaCopyWrapper>();
    x->op = DmaCopy_des(in);
    return x;
    break;
  }
  case 11: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorNcDmaCopyWrapper> x = ptr<OperatorNcDmaCopyWrapper>();
    x->op = NcDmaCopy_des(in);
    return x;
    break;
  }
  case 12: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorDmaTransposeWrapper> x = ptr<OperatorDmaTransposeWrapper>();
    x->op = DmaTranspose_des(in);
    return x;
    break;
  }
  case 13: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorDropoutWrapper> x = ptr<OperatorDropoutWrapper>();
    x->op = Dropout_des(in);
    return x;
    break;
  }
  case 14: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorFindIndex8Wrapper> x = ptr<OperatorFindIndex8Wrapper>();
    x->op = FindIndex8_des(in);
    return x;
    break;
  }
  case 15: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorIotaWrapper> x = ptr<OperatorIotaWrapper>();
    x->op = Iota_des(in);
    return x;
    break;
  }
  case 16: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorLoadMaskRegisterWrapper> x =
        ptr<OperatorLoadMaskRegisterWrapper>();
    x->op = LoadMaskRegister_des(in);
    return x;
    break;
  }
  case 17: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorLoadStationaryWrapper> x = ptr<OperatorLoadStationaryWrapper>();
    x->op = LoadStationary_des(in);
    return x;
    break;
  }
  case 18: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorLocalGatherWrapper> x = ptr<OperatorLocalGatherWrapper>();
    x->op = LocalGather_des(in);
    return x;
    break;
  }
  case 19: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorNcLocalGatherWrapper> x = ptr<OperatorNcLocalGatherWrapper>();
    x->op = NcLocalGather_des(in);
    return x;
    break;
  }
  case 20: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorMatMulWrapper> x = ptr<OperatorMatMulWrapper>();
    x->op = MatMul_des(in);
    return x;
    break;
  }
  case 21: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorNcMatMulWrapper> x = ptr<OperatorNcMatMulWrapper>();
    x->op = NcMatMul_des(in);
    return x;
    break;
  }
  case 22: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorMatchReplace8Wrapper> x = ptr<OperatorMatchReplace8Wrapper>();
    x->op = MatchReplace8_des(in);
    return x;
    break;
  }
  case 23: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorMatchValueLoadWrapper> x = ptr<OperatorMatchValueLoadWrapper>();
    x->op = MatchValueLoad_des(in);
    return x;
    break;
  }
  case 24: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorMax8Wrapper> x = ptr<OperatorMax8Wrapper>();
    x->op = Max8_des(in);
    return x;
    break;
  }
  case 25: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorMemSetWrapper> x = ptr<OperatorMemSetWrapper>();
    x->op = MemSet_des(in);
    return x;
    break;
  }
  case 26: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorRangeSelectWrapper> x = ptr<OperatorRangeSelectWrapper>();
    x->op = RangeSelect_des(in);
    return x;
    break;
  }
  case 27: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorNcRangeSelectWrapper> x = ptr<OperatorNcRangeSelectWrapper>();
    x->op = NcRangeSelect_des(in);
    return x;
    break;
  }
  case 28: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorReciprocalWrapper> x = ptr<OperatorReciprocalWrapper>();
    x->op = Reciprocal_des(in);
    return x;
    break;
  }
  case 29: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorScalarTensorTensorWrapper> x =
        ptr<OperatorScalarTensorTensorWrapper>();
    x->op = ScalarTensorTensor_des(in);
    return x;
    break;
  }
  case 30: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorNcScalarTensorTensorWrapper> x =
        ptr<OperatorNcScalarTensorTensorWrapper>();
    x->op = NcScalarTensorTensor_des(in);
    return x;
    break;
  }
  case 31: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorShuffleWrapper> x = ptr<OperatorShuffleWrapper>();
    x->op = Shuffle_des(in);
    return x;
    break;
  }
  case 32: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorTensorReduceWrapper> x = ptr<OperatorTensorReduceWrapper>();
    x->op = TensorReduce_des(in);
    return x;
    break;
  }
  case 33: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorTensorScalarWrapper> x = ptr<OperatorTensorScalarWrapper>();
    x->op = TensorScalar_des(in);
    return x;
    break;
  }
  case 34: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorTensorTensorWrapper> x = ptr<OperatorTensorTensorWrapper>();
    x->op = TensorTensor_des(in);
    return x;
    break;
  }
  case 35: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorTensorTensorScanWrapper> x =
        ptr<OperatorTensorTensorScanWrapper>();
    x->op = TensorTensorScan_des(in);
    return x;
    break;
  }
  case 36: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorTensorPartitionReduceWrapper> x =
        ptr<OperatorTensorPartitionReduceWrapper>();
    x->op = TensorPartitionReduce_des(in);
    return x;
    break;
  }
  case 37: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorTensorScalarReduceWrapper> x =
        ptr<OperatorTensorScalarReduceWrapper>();
    x->op = TensorScalarReduce_des(in);
    return x;
    break;
  }
  case 38: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorTransposeWrapper> x = ptr<OperatorTransposeWrapper>();
    x->op = Transpose_des(in);
    return x;
    break;
  }
  case 39: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorSelectReduceWrapper> x = ptr<OperatorSelectReduceWrapper>();
    x->op = SelectReduce_des(in);
    return x;
    break;
  }
  case 40: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorSequenceBoundsWrapper> x = ptr<OperatorSequenceBoundsWrapper>();
    x->op = SequenceBounds_des(in);
    return x;
    break;
  }
  case 41: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorSendRecvWrapper> x = ptr<OperatorSendRecvWrapper>();
    x->op = SendRecv_des(in);
    return x;
    break;
  }
  case 42: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<OperatorSendRecvCCEWrapper> x = ptr<OperatorSendRecvCCEWrapper>();
    x->op = SendRecvCCE_des(in);
    return x;
    break;
  }
  default:
    throw std::runtime_error("Invalid value tag");
  }
}

Ptr<Value> Value_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not read tag");
  if (t != 101)
    throw std::runtime_error("Unexpected type tag");
  switch (c) {
  case 0: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<ValueVarWrapper> x = ptr<ValueVarWrapper>();
    x->x = String_des(in);
    return x;
    break;
  }
  case 1: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<ValueBoolWrapper> x = ptr<ValueBoolWrapper>();
    x->value = Bool_des(in);
    return x;
    break;
  }
  case 2: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<ValueIntWrapper> x = ptr<ValueIntWrapper>();
    x->value = Int_des(in);
    return x;
    break;
  }
  case 3: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<ValueFloatWrapper> x = ptr<ValueFloatWrapper>();
    x->value = Float_des(in);
    return x;
    break;
  }
  case 4: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<ValueAccessWrapper> x = ptr<ValueAccessWrapper>();
    x->a = Access_des(in);
    return x;
    break;
  }
  default:
    throw std::runtime_error("Invalid value tag");
  }
}

Ptr<Keyword> Keyword_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not find tag");
  if (t != 102 || c != 0 || l != 2)
    throw std::runtime_error("Invalid Tag");
  Ptr<Keyword> x = ptr<Keyword>();
  x->name = String_des(in);
  x->value = Value_des(in);
  return x;
}

Ptr<Expr> Expr_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not read tag");
  if (t != 103)
    throw std::runtime_error("Unexpected type tag");
  switch (c) {
  case 0: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<ExprValueWrapper> x = ptr<ExprValueWrapper>();
    x->v = Value_des(in);
    return x;
    break;
  }
  case 1: {
    if (l != 3)
      throw std::runtime_error("Wrong number of elements");
    Ptr<ExprCallWrapper> x = ptr<ExprCallWrapper>();
    x->f = String_des(in);
    x->args = List_Value_des(in);
    x->kwargs = List_Keyword_des(in);
    return x;
    break;
  }
  default:
    throw std::runtime_error("Invalid value tag");
  }
}

Ptr<Stmt> Stmt_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not read tag");
  if (t != 104)
    throw std::runtime_error("Unexpected type tag");
  switch (c) {
  case 0: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<StmtRetWrapper> x = ptr<StmtRetWrapper>();
    x->v = Value_des(in);
    return x;
    break;
  }
  case 1: {
    if (l != 2)
      throw std::runtime_error("Wrong number of elements");
    Ptr<StmtAssignWrapper> x = ptr<StmtAssignWrapper>();
    x->x = String_des(in);
    x->e = Expr_des(in);
    return x;
    break;
  }
  case 2: {
    if (l != 3)
      throw std::runtime_error("Wrong number of elements");
    Ptr<StmtOperWrapper> x = ptr<StmtOperWrapper>();
    x->op = Operator_des(in);
    x->name = Option_String_des(in);
    x->pos = Pos_des(in);
    return x;
    break;
  }
  default:
    throw std::runtime_error("Invalid value tag");
  }
}

Ptr<Kernel> Kernel_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not find tag");
  if (t != 105 || c != 0 || l != 4)
    throw std::runtime_error("Invalid Tag");
  Ptr<Kernel> x = ptr<Kernel>();
  x->name = String_des(in);
  x->inputs = List_TensorName_des(in);
  x->outputs = List_TensorName_des(in);
  x->body = List_Stmt_des(in);
  return x;
}

Ptr<SharedConstantFile> SharedConstantFile_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not find tag");
  if (t != 106 || c != 0 || l != 2)
    throw std::runtime_error("Invalid Tag");
  Ptr<SharedConstantFile> x = ptr<SharedConstantFile>();
  x->name = String_des(in);
  x->fileName = String_des(in);
  return x;
}

Ptr<LncKernel> LncKernel_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not find tag");
  if (t != 107 || c != 0 || l != 5)
    throw std::runtime_error("Invalid Tag");
  Ptr<LncKernel> x = ptr<LncKernel>();
  x->name = String_des(in);
  x->inputs = List_TensorName_des(in);
  x->outputs = List_TensorName_des(in);
  x->bodies = List_List_des(in);
  x->sharedConstants = List_SharedConstantFile_des(in);
  return x;
}

List<Ptr<Index>> List_Index_des(FILE *in) {
  u64 size = 0;
  if (!deserialize_array_start(in, &size))
    throw std::runtime_error("expecting List");

  List<Ptr<Index>> l;
  while (size-- > 0) {
    Ptr<Index> b = Index_des(in);
    l.push_back(b);
  }
  return l;
}

List<Ptr<APPair>> List_APPair_des(FILE *in) {
  u64 size = 0;
  if (!deserialize_array_start(in, &size))
    throw std::runtime_error("expecting List");

  List<Ptr<APPair>> l;
  while (size-- > 0) {
    Ptr<APPair> b = APPair_des(in);
    l.push_back(b);
  }
  return l;
}

Option<Dtype> Option_Dtype_des(FILE *in) {
  bool isSome;
  if (!deserialize_option(in, &isSome))
    throw std::runtime_error("expecting Bool");

  Option<Dtype> x;
  if (isSome)
    x = Dtype_des(in);
  return x;
}

List<Ptr<Immediate>> List_Immediate_des(FILE *in) {
  u64 size = 0;
  if (!deserialize_array_start(in, &size))
    throw std::runtime_error("expecting List");

  List<Ptr<Immediate>> l;
  while (size-- > 0) {
    Ptr<Immediate> b = Immediate_des(in);
    l.push_back(b);
  }
  return l;
}

Option<Ptr<TensorRef>> Option_TensorRef_des(FILE *in) {
  bool isSome;
  if (!deserialize_option(in, &isSome))
    throw std::runtime_error("expecting Bool");

  Option<Ptr<TensorRef>> x;
  if (isSome)
    x = TensorRef_des(in);
  return x;
}

Option<TensorSubDim> Option_TensorSubDim_des(FILE *in) {
  bool isSome;
  if (!deserialize_option(in, &isSome))
    throw std::runtime_error("expecting Bool");

  Option<TensorSubDim> x;
  if (isSome)
    x = TensorSubDim_des(in);
  return x;
}

Option<Ptr<Operand>> Option_Operand_des(FILE *in) {
  bool isSome;
  if (!deserialize_option(in, &isSome))
    throw std::runtime_error("expecting Bool");

  Option<Ptr<Operand>> x;
  if (isSome)
    x = Operand_des(in);
  return x;
}

Option<AluOp> Option_AluOp_des(FILE *in) {
  bool isSome;
  if (!deserialize_option(in, &isSome))
    throw std::runtime_error("expecting Bool");

  Option<AluOp> x;
  if (isSome)
    x = AluOp_des(in);
  return x;
}

Option<Ptr<Immediate>> Option_Immediate_des(FILE *in) {
  bool isSome;
  if (!deserialize_option(in, &isSome))
    throw std::runtime_error("expecting Bool");

  Option<Ptr<Immediate>> x;
  if (isSome)
    x = Immediate_des(in);
  return x;
}

List<Ptr<TensorRef>> List_TensorRef_des(FILE *in) {
  u64 size = 0;
  if (!deserialize_array_start(in, &size))
    throw std::runtime_error("expecting List");

  List<Ptr<TensorRef>> l;
  while (size-- > 0) {
    Ptr<TensorRef> b = TensorRef_des(in);
    l.push_back(b);
  }
  return l;
}

List<Ptr<Value>> List_Value_des(FILE *in) {
  u64 size = 0;
  if (!deserialize_array_start(in, &size))
    throw std::runtime_error("expecting List");

  List<Ptr<Value>> l;
  while (size-- > 0) {
    Ptr<Value> b = Value_des(in);
    l.push_back(b);
  }
  return l;
}

List<Ptr<Keyword>> List_Keyword_des(FILE *in) {
  u64 size = 0;
  if (!deserialize_array_start(in, &size))
    throw std::runtime_error("expecting List");

  List<Ptr<Keyword>> l;
  while (size-- > 0) {
    Ptr<Keyword> b = Keyword_des(in);
    l.push_back(b);
  }
  return l;
}

List<Ptr<TensorName>> List_TensorName_des(FILE *in) {
  u64 size = 0;
  if (!deserialize_array_start(in, &size))
    throw std::runtime_error("expecting List");

  List<Ptr<TensorName>> l;
  while (size-- > 0) {
    Ptr<TensorName> b = TensorName_des(in);
    l.push_back(b);
  }
  return l;
}

List<Ptr<Stmt>> List_Stmt_des(FILE *in) {
  u64 size = 0;
  if (!deserialize_array_start(in, &size))
    throw std::runtime_error("expecting List");

  List<Ptr<Stmt>> l;
  while (size-- > 0) {
    Ptr<Stmt> b = Stmt_des(in);
    l.push_back(b);
  }
  return l;
}

List<List<Ptr<Stmt>>> List_List_des(FILE *in) {
  u64 size = 0;
  if (!deserialize_array_start(in, &size))
    throw std::runtime_error("expecting List");

  List<List<Ptr<Stmt>>> l;
  while (size-- > 0) {
    List<Ptr<Stmt>> b = List_Stmt_des(in);
    l.push_back(b);
  }
  return l;
}

List<Ptr<SharedConstantFile>> List_SharedConstantFile_des(FILE *in) {
  u64 size = 0;
  if (!deserialize_array_start(in, &size))
    throw std::runtime_error("expecting List");

  List<Ptr<SharedConstantFile>> l;
  while (size-- > 0) {
    Ptr<SharedConstantFile> b = SharedConstantFile_des(in);
    l.push_back(b);
  }
  return l;
}

Ptr<KLRFile> KLRFile_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not find tag");
  if (t != 217 || c != 247 || l != 3)
    throw std::runtime_error("Invalid Tag");
  Ptr<KLRFile> x = ptr<KLRFile>();
  x->major = Nat_des(in);
  x->minor = Nat_des(in);
  x->patch = Nat_des(in);
  return x;
}

Ptr<KLRMetaData> KLRMetaData_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not find tag");
  if (t != 235 || c != 0 || l != 1)
    throw std::runtime_error("Invalid Tag");
  Ptr<KLRMetaData> x = ptr<KLRMetaData>();
  x->format = String_des(in);
  return x;
}

Ptr<Contents> Contents_des(FILE *in) {
  u8 t, c, l;
  if (!deserialize_tag(in, &t, &c, &l))
    throw std::runtime_error("Could not read tag");
  if (t != 236)
    throw std::runtime_error("Unexpected type tag");
  switch (c) {
  case 0: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<ContentsPythonWrapper> x = ptr<ContentsPythonWrapper>();
    x->kernel = Kernel_des(in);
    return x;
    break;
  }
  case 1: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<ContentsNkiWrapper> x = ptr<ContentsNkiWrapper>();
    x->kernel = Kernel_des(in);
    return x;
    break;
  }
  case 2: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<ContentsKernelWrapper> x = ptr<ContentsKernelWrapper>();
    x->kernel = Kernel_des(in);
    return x;
    break;
  }
  case 3: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<ContentsLncWrapper> x = ptr<ContentsLncWrapper>();
    x->kernel = LncKernel_des(in);
    return x;
    break;
  }
  case 4: {
    if (l != 1)
      throw std::runtime_error("Wrong number of elements");
    Ptr<ContentsHloWrapper> x = ptr<ContentsHloWrapper>();
    x->name = String_des(in);
    return x;
    break;
  }
  default:
    throw std::runtime_error("Invalid value tag");
  }
}
} // namespace klr
