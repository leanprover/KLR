/-
Copyright (c) 2025 Amazon.com, Inc. or its affiliates. All Rights Reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Paul Govereau, Sean McLaughlin
-/
import Lean
import KLR.Util
import KLR.BIR.Instruction
import KLR.BIR.Instructions

/-
Definitions of container and function types.

This file contains type definitions not generated automatically.

Note: the naming of fields is carefully designed so that the derived
instances of to- and from-json are compatible with the compiler.
-/
namespace KLR.BIR

/-
The Instruction contains an `Inst` from the automatically generated
code. The generated code will create the json object with the "opcode"
field, so we just need to insert the common fields into the json object
generated by the `Inst`.
-/
structure Instruction where
  name : String
  engine : Engine := .unassigned
  ins : List Argument := []
  outs : List Argument := []
  inst : Inst
  -- TODO: not using these right now...
  --dependencies : Option (List String) := none
  --unroll_dependencies : Option (List String) := none
  --loop_carried_dependencies : Option (List String) := none
  deriving BEq, Repr, Lean.FromJson, Lean.ToJson

instance : Lean.ToJson Instruction where
  toJson i :=
    let obj := Lean.toJson i.inst
    let obj := obj.setObjVal! "name" (Lean.toJson i.name)
    let obj := obj.setObjVal! "engine" (Lean.toJson i.engine)
    let obj := obj.setObjVal! "ins" (Lean.toJson i.ins)
    let obj := obj.setObjVal! "outs" (Lean.toJson i.outs)
    obj

instance : Lean.FromJson Instruction where
  fromJson? j := do
    return {
       name := <- j.getObjValAs? String "name"
       engine := <- j.getObjValAs? Engine "engine"
       ins := <- j.getObjValAs? (List Argument) "ins"
       outs := <- j.getObjValAs? (List Argument) "outs"
       inst := <- Lean.fromJson? j
    }

inductive StorageKind where
  | memory_location_set
  | memory_location
  | register
  deriving BEq, Repr, Lean.FromJson, Lean.ToJson

inductive TensorKind where
  | ExternalInput
  | ExternalInputParameter
  | Input
  | ExternalOutput
  | ExternalOutputParameter
  | Output
  | Const
  | Internal
  | Pointer
  | InternalInterface
  deriving BEq, Repr, Lean.FromJson, Lean.ToJson

inductive TensorClass where
  | Tensor
  | LoopTensor
  | SingleValueTensor
  | NeuronTensor
  | NeuronWeightTensor
  | IdentityWeightTensor
  | NeuronBlockTensor
  | DRAM2DBlockTensor
  | Neuron3DBlockTensor
  | DRAM3DBlockTensor
  | NeuronLocalTensor
  | NeuronSBTensor
  | NeuronPSUMTensor
  deriving BEq, Repr, Lean.FromJson, Lean.ToJson

inductive AddrSpace where
  | Local | Shared
  deriving BEq, Repr, Lean.FromJson, Lean.ToJson

inductive MemoryType where
  | Unallocated
  | Input
  | Output
  | DRAM
  | SB
  | PSUM
  | RNGSTATE
  | REG
  deriving BEq, Repr, Lean.FromJson, Lean.ToJson

structure MemoryLocation where
  Skind : StorageKind := .memory_location
  name : String
  type : MemoryType
  addr : Nat := 0   -- per-partition offset
  dims : List Nat   -- num partitions, bytes per partition
  bank : Nat := 0   -- bank id
  base : Nat := 0   -- base partition (0, 32, 64)
  allocated : Bool := false
  pinned : Bool := false
  tensor_id : Option Nat := some 0
  deriving BEq, Repr, Lean.FromJson, Lean.ToJson

structure Allocation where
  Skind : StorageKind := .memory_location_set
  addr_space : Option AddrSpace
  dtype : Option Dtype
  partition_dim : Option Nat
  tensor_shape : List Nat
  name : String
  file : String := ""
  no_spill : Bool := false  -- should be do_not_spill?
  volatile : Bool := false        -- unused by walrus?
  virtual : Bool := false
  kind : TensorKind
  tensor_class : TensorClass := match kind with | .Internal => .NeuronSBTensor | _ => .Tensor
  memorylocations : List MemoryLocation
  tensorId2MemLocSize : Nat := memorylocations.length
  deriving BEq, Repr, Lean.FromJson, Lean.ToJson

structure Axis where
  name : String
  lb : Nat := 0
  ub : Nat := 0
  stride : Nat := 0
  deriving BEq, Repr, Lean.FromJson, Lean.ToJson

/-
Loops contains blocks which contain instructions or loops.

In BIR, a loop is an Instruction with opcode=Loop. In addition, a loop must
contain a list of blocks (not instructions or loops).

  Block name [Loop axis [Block name [Inst .., Loop axis [Block name2 [....

The inductive type below does not capture this constraint, but it is easier to
work with than the "correct" type.
-/

inductive Block where
  | block (name : String) (insts : List Block)
  | loop (axis : Axis) (insts : List Block)
  | inst (i : Instruction)
  deriving BEq, Repr

partial def Block.toJson (b : Block) : Lean.Json :=
  let blocks (l : List Block) : Lean.Json := .arr (l.map toJson).toArray
  match b with
  | .block n l => .mkObj [ ("name", n), ("instructions", blocks l)]
  | .loop a l => .mkObj [ ("opcode", .str "Loop"),
                          ("LoopAxis", Lean.toJson a),
                          ("blocks", blocks l) ]
  | .inst i => Lean.toJson i

partial def Block.fromJson (j : Lean.Json) : Err Block := do
  let blocks (j : Lean.Json) : Err (List Block) := do
    match j with
    | .arr a => a.toList.mapM Block.fromJson
    | _ => throw "list of blocks, instructions or loops"

  -- check if we have a block.
  match j.getObjVal? "instructions" with
  | .ok l => return .block (<- j.getObjValAs? String "name") (<- blocks l)
  | .error _ => pure ()

  -- check if we have a loop or instruction
  match <- j.getObjValAs? String "opcode" with
  | "Loop" => do
      let axis <- j.getObjValAs? Axis "LoopAxis"
      let blk <- j.getObjVal? "blocks"
      return .loop axis (<- blocks blk)
  | _ => return .inst (<- Lean.fromJson? j)

instance : Lean.ToJson Block := ⟨ Block.toJson ⟩
instance : Lean.FromJson Block := ⟨ Block.fromJson ⟩

inductive FunAttributes where
  | need_dce
  | need_unroll
  deriving BEq, Repr, Lean.FromJson, Lean.ToJson

structure Function where
  name : String
  attributes : List FunAttributes := []
  allocations : List Allocation
  blocks : List Block
  deriving BEq, Repr, Lean.FromJson, Lean.ToJson

structure Attributes where
  neuron_core_id : Option Nat := some 0
  deriving BEq, Repr, Lean.FromJson, Lean.ToJson

structure BIR where
  attributes : Attributes := { }
  functions: List Function
  arch : String := "gen3"
  version : Nat := 2
  deriving BEq, Repr, Lean.FromJson, Lean.ToJson
