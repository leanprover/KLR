/-
# NKI Dataflow

This file uses the Dataflow solver (`InnerMapImpl.Solution`) from `Dataflow.lean`
to analyize NKI functions.

For example, see `test_kernel` below, serialized NKI ASTs can be generated from `klr compile`,
converted to CFGs by the `NKIWalker` class below,
paired with definitions of variable well-definition corresponding to syntactic defs and uses,
and analyzed to get `ùïèopt : Option SolutionT`, which can be printed to view the liveness of
all variables at all program points `#eval ùïèopt`
-/

import KLR.NKI.Basic
import KLR.Compile.Dataflow

open KLR.NKI

section DefVarAction

  inductive VarAction where
    | Read (name : String)
    | Write (name : String) (ty : Option Expr)
    | None

  instance VarAction.toString : ToString VarAction where
    toString := fun
      | Read name => s!"Read({name})"
      | Write name _ => s!"Write({name})"
      | None => "None"

  def VarAction.var := fun
    | Read name => some name
    | Write name _ => some name
    | None => none

end DefVarAction

section DefNKIWalker

  structure NKIWalker where
    num_nodes : ‚Ñï
    num_nodes_nonzero : num_nodes > 0
    last_node : ‚Ñï
    actions : ‚Ñï ‚Üí VarAction
    edges : ‚Ñï ‚Üí ‚Ñï ‚Üí Bool
    breaks : List ‚Ñï
    conts : List ‚Ñï
    rets : List ‚Ñï
    vars : List String --list of varnames seen

  instance NKIWalker.toString : ToString NKIWalker where
    toString walker :=
      let row n :=
        let tgts := (List.range walker.num_nodes).filter (walker.edges n)
        let num := if n = walker.last_node then s!"[{n} (exit)]" else s!"[{n}]"
        s!"Node {num} : {walker.actions n} ‚Ü¶ Nodes {tgts}\n"
      String.intercalate "\n" ((List.range walker.num_nodes).map row ++ ["vars: ", walker.vars.toString])

  def NKIWalker.init : NKIWalker := {
    num_nodes := 1
    num_nodes_nonzero := by trivial
    last_node := 0
    actions _ := VarAction.None
    edges _ _ := false
    breaks := []
    conts := []
    rets := []
    vars := []
  }

  def NKIWalker.Node (walker : NKIWalker) : Type := Fin (walker.num_nodes)
  def NKIWalker.Var (walker : NKIWalker) : Type := Fin (walker.vars.length)

  def NKIWalker.reads (walker : NKIWalker) (n : walker.Node) (v : walker.Var) : Bool :=
    match walker.actions n.val with
    | VarAction.Read name => name = walker.vars.get v
    | _ => false

  def NKIWalker.writes (walker : NKIWalker) (n : walker.Node) (v : walker.Var) : Bool :=
    match walker.actions n.val with
    | VarAction.Write name _ => name = walker.vars.get v
    | _ => false

  def NKIWalker.isPath (walker : NKIWalker) : List walker.Node ‚Üí Bool := fun
    | [] => True
    | [n] => walker.edges 0 n.val
    | n‚ÇÅ :: n‚ÇÄ :: tl => walker.isPath (n‚ÇÄ :: tl) ‚àß (walker.edges n‚ÇÄ.val n‚ÇÅ.val)

  structure NKIWalker.Path (walker : NKIWalker) where
    nodes : List walker.Node
    nodes_sound : walker.isPath nodes

  def NKIWalker.Path.unroll (walker : NKIWalker) (ùï° : walker.Path)
    : ùï°.nodes.length ‚â• 2 ‚Üí
      ‚àÉ (n‚ÇÅ n‚ÇÄ : walker.Node) (tl : List walker.Node),
        (walker.edges n‚ÇÄ.val n‚ÇÅ.val) ‚àß (n‚ÇÅ :: n‚ÇÄ :: tl = ùï°.nodes) ‚àß (walker.isPath (n‚ÇÄ :: tl)) := by {
            sorry
    }

  def NKIWalker.Path.writes_somewhere (walker : NKIWalker) (ùï° : walker.Path) (v : walker.Var) : Bool :=
    ùï°.nodes.tail.any (walker.writes . v)

  -- easier to rewrite this than find it in the library lol
  abbrev mem_lifts {Œ±} (a : Œ±) (‚Ñì : List Œ±) : a ‚àà ‚Ñì.tail ‚Üí a ‚àà ‚Ñì := by {
    intro h
    cases ‚Ñì
    contradiction
    simp_all
  }

  def NKIWalker.Path.writes_somewhere_lifts (walker : NKIWalker) (ùï°‚ÇÄ ùï°‚ÇÅ : walker.Path) (v : walker.Var)
    : ùï°‚ÇÅ.nodes.tail = ùï°‚ÇÄ.nodes ‚Üí ùï°‚ÇÄ.writes_somewhere walker v ‚Üí ùï°‚ÇÅ.writes_somewhere walker v := by {
      simp [writes_somewhere]
      intro unroll n‚ÇÄ n‚ÇÄ_in n‚ÇÄ_writes
      exists n‚ÇÄ
      apply And.intro
      simp [unroll]
      apply mem_lifts
      assumption
      assumption
    }

  def NKIWalker.Path.true_at_terminus (walker : NKIWalker) (ùï° : walker.Path) (motive : walker.Node ‚Üí Bool) : Bool :=
    match ùï°.nodes with
    | n :: _ => motive n
    | _ => false

  def NKIWalker.Path.reads_at_terminus (walker : NKIWalker) (ùï° : walker.Path) (v : walker.Var) : Bool :=
    ùï°.true_at_terminus walker (walker.reads . v)

  -- proving (or failing to prove) this is the goal!!
  def NKIWalker.sound (walker : NKIWalker) : Prop :=
    ‚àÄ (ùï° : walker.Path) v, (ùï°.reads_at_terminus walker v) ‚Üí (ùï°.writes_somewhere walker v)

  def NKIWalker.processAction (walker : NKIWalker) (action : VarAction) : NKIWalker :=
    let N := walker.num_nodes
    {walker with
      num_nodes := N + 1
      num_nodes_nonzero := by simp
      last_node := N
      actions n := if n = N then action else walker.actions n
      edges A B := (A, B) = (walker.last_node, N)
                  ‚à® (walker.edges A B)
      vars := match action.var with
              | some var => if var ‚àà walker.vars then walker.vars else walker.vars.concat var
              | none => walker.vars
    }


  def NKIWalker.setLast (walker : NKIWalker) (last_node : ‚Ñï) : NKIWalker := {walker with
    last_node := last_node
  }


  def NKIWalker.addEdge (walker : NKIWalker) (a b : ‚Ñï) : NKIWalker := {walker with
    edges A B := (A, B) = (a, b) ‚à® walker.edges A B
  }


  def NKIWalker.addBreak (walker : NKIWalker) : NKIWalker := {walker with
    breaks := walker.breaks ++ [walker.last_node]
  }


  def NKIWalker.clearBreaks (walker : NKIWalker) : NKIWalker := {walker with
    breaks := []
  }

  def NKIWalker.addContinue (walker : NKIWalker): NKIWalker := {walker with
    conts := walker.conts ++ [walker.last_node]
  }


  def NKIWalker.clearConts (walker : NKIWalker) : NKIWalker := {walker with
    conts := []
  }


  def NKIWalker.addReturn (walker : NKIWalker) : NKIWalker := {walker with
    rets := walker.rets ++ [walker.last_node]
  }

  /-mutual
  def NKIWalker.processExpr (walker : NKIWalker) (expr : Expr) : Nat :=
    match h : expr.expr with
    | Expr'.tuple x => (walker.processExprList x).sum
    | _ => 0
    termination_by sizeOf expr
    decreasing_by cases expr; simp at h; rw [h]; simp; omega
  def NKIWalker.processExprList (walker : NKIWalker) (exprs : List Expr) : List Nat :=
    exprs.map walker.processExpr
    termination_by sizeOf exprs
  end-/

  mutual

  def NKIWalker.processExpr (walker : NKIWalker) (expr : Expr) : NKIWalker :=
    let ‚ü®expr, _‚ü© := expr
    match _ : expr with
    | Expr'.value _ => walker
    | Expr'.var (name : String) => walker.processAction (VarAction.Read name)
    | Expr'.proj (expr : Expr) _ => walker.processExpr expr
    | Expr'.tuple (elements : List Expr) => walker.processExprList elements
    | Expr'.access (expr : Expr) _ => walker.processExpr expr
    | Expr'.binOp _ left right => (walker.processExpr left).processExpr right
    | Expr'.ifExp test body orelse =>
      let body_walker := ((walker.processExpr test).processExpr body)
      let orelse_walker := ((body_walker.setLast walker.last_node).processExpr orelse)
      let complete_walker := (orelse_walker.processAction VarAction.None)
      complete_walker.addEdge body_walker.last_node complete_walker.last_node
    | Expr'.call (f: Expr) (args: List Expr) (_ : List Keyword) =>
      (walker.processExpr f).processExprList args
    termination_by sizeOf expr
    decreasing_by
      all_goals {
        try {rename_i expr' _<;> rcases h' : (expr, expr') with ‚ü®‚ü®‚ü®‚ü©, ‚ü®‚ü©‚ü©, ‚ü®‚ü®‚ü©, ‚ü®‚ü©‚ü©‚ü© <;> simp_all <;> omega}
        try {rcases h' : expr with ‚ü®‚ü®‚ü©, ‚ü®‚ü©‚ü© <;> simp_all <;> omega}
      }


  def NKIWalker.processExprList (walker : NKIWalker) (exprs : List Expr) : NKIWalker :=
    exprs.foldl NKIWalker.processExpr walker
    termination_by sizeOf exprs
  end

  mutual

  def NKIWalker.processStmt (walker : NKIWalker) (stmt : Stmt) : NKIWalker :=
    let ‚ü®stmt, _‚ü© := stmt
    match _ : stmt with
    | Stmt'.expr (e : Expr) => walker.processExpr e
    | Stmt'.assert (e : Expr) => walker.processExpr e
    | Stmt'.ret (e : Expr) => (walker.processExpr e).addReturn
    | Stmt'.assign ‚ü®Expr'.var name, _‚ü© (ty : Option Expr) (e : Option Expr) =>
      let withty := (match ty with | some ty => walker.processExpr ty | none => walker)
      let withe := (match e with | some e => withty.processExpr e | none => withty)
      withe.processAction (VarAction.Write name ty)
    | Stmt'.assign _ (ty : Option Expr) (e : Option Expr) =>
      let withty := (match ty with | some ty => walker.processExpr ty | none => walker)
      let withe := (match e with | some e => withty.processExpr e | none => withty)
      withe.processAction (VarAction.Write "NONVAR" ty)
    | Stmt'.ifStm (e : Expr) (thn : List Stmt) (els : List Stmt) =>
      let then_walker := (walker.processExpr e).processStmtList thn
      let else_walker := (then_walker.setLast walker.last_node).processStmtList els
      let complete := else_walker.processAction VarAction.None
      complete.addEdge then_walker.last_node complete.last_node
    | Stmt'.forLoop (x : Expr) (iter: Expr) (body: List Stmt) =>
      let intro_walker := (walker.processExpr x).processExpr iter
      let outer_breaks := intro_walker.breaks
      let outer_conts := intro_walker.conts
      let inner_walker := ((intro_walker.clearBreaks).clearConts).processAction VarAction.None
      let enter_node := inner_walker.last_node
      let inner_walked := inner_walker.processStmtList body
      let nearly_complete := (inner_walked.addEdge inner_walked.last_node enter_node).setLast enter_node
      let complete := nearly_complete.processAction VarAction.None
      let exit_node := complete.last_node
      let with_conts := complete.conts.foldl (fun walker cont ‚Ü¶ walker.addEdge cont enter_node) complete
      let with_breaks := complete.breaks.foldl (fun walker brk ‚Ü¶ walker.addEdge brk exit_node) with_conts
      {with_breaks with
        conts := outer_conts
        breaks := outer_breaks
      }
    | Stmt'.breakLoop => (walker.processAction VarAction.None).addBreak
    | Stmt'.continueLoop => (walker.processAction VarAction.None).addContinue
    termination_by sizeOf stmt
    decreasing_by
      try rcases h : (thn, stmt) with ‚ü®‚ü®‚ü®‚ü©, ‚ü®‚ü©‚ü©, ‚ü®‚ü®‚ü©, ‚ü®‚ü©‚ü©‚ü© <;> simp_all <;> omega
      try rcases h : (els, stmt) with ‚ü®‚ü®‚ü®‚ü©, ‚ü®‚ü©‚ü©, ‚ü®‚ü®‚ü©, ‚ü®‚ü©‚ü©‚ü© <;> simp_all <;> omega
      try rcases h : (body, stmt) with ‚ü®‚ü®‚ü®‚ü©, ‚ü®‚ü©‚ü©, ‚ü®‚ü®‚ü©, ‚ü®‚ü©‚ü©‚ü© <;> simp_all <;> omega


  def NKIWalker.processStmtList (walker : NKIWalker) (stmts : List Stmt) : NKIWalker :=
    stmts.foldl NKIWalker.processStmt walker
    termination_by sizeOf stmts
  end


  def NKIWalker.processFun (f : Fun) : NKIWalker :=
    let body_walker := (NKIWalker.init.processStmtList f.body).processAction VarAction.None
    body_walker.rets.foldl (fun walker ret ‚Ü¶ walker.addEdge ret body_walker.last_node) body_walker


  def NKIWalker.isClosed (walker : NKIWalker) := walker.breaks.isEmpty ‚àß walker.conts.isEmpty

end DefNKIWalker

section Test

  /-
  file test.py:
  def test():
    x = 0
    if cond0:
      print(x)
    else:
      y = 0
      print(y)
    print(y)

  bash: `klr compile test.py` yields the following serialization of a NKI Kernel
  -/

  def test_kernel : Kernel := {
    entry := "test.test",
    funs := [{name := "test.test",
              file := "unknown",
              line := 1,
              body := [{ stmt := KLR.NKI.Stmt'.assign
                                    { expr := KLR.NKI.Expr'.var "x",
                                      pos := { line := 2, column := 1, lineEnd := some 2, columnEnd := some 2 } }
                                    none
                                    (some { expr := KLR.NKI.Expr'.value (KLR.NKI.Value.int 0),
                                            pos := { line := 2, column := 5, lineEnd := some 2, columnEnd := some 6 } }),
                          pos := { line := 2, column := 1, lineEnd := some 2, columnEnd := some 6 } },
                        { stmt := KLR.NKI.Stmt'.ifStm
                                    { expr := KLR.NKI.Expr'.var "cond0",
                                      pos := { line := 3, column := 4, lineEnd := some 3, columnEnd := some 9 } }
                                    [{stmt := KLR.NKI.Stmt'.expr
                                                { expr := KLR.NKI.Expr'.call
                                                            { expr := KLR.NKI.Expr'.var "print",
                                                              pos := { line := 4,
                                                                        column := 2,
                                                                        lineEnd := some 4,
                                                                        columnEnd := some 7 } }
                                                            [{ expr := KLR.NKI.Expr'.var "x",
                                                                pos := {line := 4,
                                                                        column := 8,
                                                                        lineEnd := some 4,
                                                                        columnEnd := some 9 } }]
                                                            [],
                                                  pos := { line := 4,
                                                            column := 2,
                                                            lineEnd := some 4,
                                                            columnEnd := some 10 } },
                                      pos := {line := 4, column := 2, lineEnd := some 4, columnEnd := some 10 } }]
                                    [{stmt := KLR.NKI.Stmt'.assign
                                                { expr := KLR.NKI.Expr'.var "y",
                                                  pos := { line := 6,
                                                            column := 2,
                                                            lineEnd := some 6,
                                                            columnEnd := some 3 } }
                                                none
                                                (some { expr := KLR.NKI.Expr'.value (KLR.NKI.Value.int 0),
                                                        pos := { line := 6,
                                                                  column := 6,
                                                                  lineEnd := some 6,
                                                                  columnEnd := some 7 } }),
                                      pos := { line := 6, column := 2, lineEnd := some 6, columnEnd := some 7 } },
                                    { stmt := KLR.NKI.Stmt'.expr
                                                { expr := KLR.NKI.Expr'.call
                                                            { expr := KLR.NKI.Expr'.var "print",
                                                              pos := { line := 7,
                                                                        column := 2,
                                                                        lineEnd := some 7,
                                                                        columnEnd := some 7 } }
                                                            [{ expr := KLR.NKI.Expr'.var "y",
                                                                pos := {line := 7,
                                                                        column := 8,
                                                                        lineEnd := some 7,
                                                                        columnEnd := some 9 } }]
                                                            [],
                                                  pos := { line := 7,
                                                            column := 2,
                                                            lineEnd := some 7,
                                                            columnEnd := some 10 } },
                                      pos := { line := 7, column := 2, lineEnd := some 7, columnEnd := some 10 } }],
                          pos := { line := 3, column := 1, lineEnd := some 7, columnEnd := some 10 } },
                        { stmt := KLR.NKI.Stmt'.expr
                                    { expr := KLR.NKI.Expr'.call
                                                { expr := KLR.NKI.Expr'.var "print",
                                                  pos := {line := 8,
                                                          column := 1,
                                                          lineEnd := some 8,
                                                          columnEnd := some 6 } }
                                                [{expr := KLR.NKI.Expr'.var "y",
                                                  pos := {line := 8,
                                                            column := 7,
                                                            lineEnd := some 8,
                                                            columnEnd := some 8 } }]
                                                [],
                                      pos := { line := 8, column := 1, lineEnd := some 8, columnEnd := some 9 } },
                          pos := { line := 8, column := 1, lineEnd := some 8, columnEnd := some 9 } }],
              args := [] }],
    args := [],
    globals := [] }

  /-
    Perform the walk of the AST, converting it into a CFG
  -/
  def walker := NKIWalker.processFun test_kernel.funs[0]
  #eval walker

  /-
    extract the transitions from the walker
  -/
  def transitions (n k : ‚Ñï) (pre : Bool) : Bool :=
    (n = 0) ‚à®
    if _ : k < walker.vars.length then
      match walker.actions n with
        | VarAction.Write name _ => ¬¨ (name = walker.vars[k]) ‚àß pre
        | _ => pre
    else
      pre

  instance : Preorder Bool where
    le_refl := by trivial
    le_trans := by trivial

  instance : HasBot Bool where
    bot := false

  instance : ToString Bool where
    toString := fun
      | true => "‚ùå"
      | false => "‚úÖ"


  /-
    perform dataflow analysis
  -/
  def ùïèopt := (Solution
        (œÅ:=Bool)
        (le_supl:=by trivial)
        (le_supr:=by trivial)
        (num_nodes:=walker.num_nodes)
        (num_keys:=walker.vars.length)
        (edges:=walker.edges)
        (transitions:=transitions)).map (fun a ‚Ü¶ {a with
          key_labels k := walker.vars[k]?
        })

  #eval ùïèopt
  /-
  Node 0: x:‚úÖ cond0:‚úÖ print:‚úÖ y:‚úÖ
  Node 1: x:‚ùå cond0:‚ùå print:‚ùå y:‚ùå
  Node 2: x:‚úÖ cond0:‚ùå print:‚ùå y:‚ùå
  Node 3: x:‚úÖ cond0:‚ùå print:‚ùå y:‚ùå
  Node 4: x:‚úÖ cond0:‚ùå print:‚ùå y:‚ùå
  Node 5: x:‚úÖ cond0:‚ùå print:‚ùå y:‚ùå
  Node 6: x:‚úÖ cond0:‚ùå print:‚ùå y:‚úÖ
  Node 7: x:‚úÖ cond0:‚ùå print:‚ùå y:‚úÖ
  Node 8: x:‚úÖ cond0:‚ùå print:‚ùå y:‚ùå
  Node 9: x:‚úÖ cond0:‚ùå print:‚ùå y:‚ùå
  Node 10: x:‚úÖ cond0:‚ùå print:‚ùå y:‚ùå
  Node 11: x:‚úÖ cond0:‚ùå print:‚ùå y:‚ùå
  -/

  variable (hùïè : ùïèopt.isSome)

  abbrev ùïè := ùïèopt.get hùïè
  abbrev ‚Ñô := walker.Path
  abbrev ùïü := walker.Node
  abbrev ùïç := walker.Var
  abbrev ùîº (n‚ÇÄ n‚ÇÅ : walker.Node) := walker.edges n‚ÇÄ.val n‚ÇÅ.val

  abbrev ŒΩ (n : ùïü) (v : ùïç) := (ùïè hùïè).vals n.val v.val n.isLt v.isLt

  abbrev œÉ (n‚ÇÄ n‚ÇÅ : ùïü) (v : ùïç) (ùîºn:ùîº n‚ÇÄ n‚ÇÅ): transitions n‚ÇÄ.val v.val (ŒΩ hùïè n‚ÇÄ v) ‚â§ ŒΩ hùïè n‚ÇÅ v := by {
    apply (ùïè hùïè).props n‚ÇÄ.val n‚ÇÅ.val v.val n‚ÇÄ.isLt n‚ÇÅ.isLt v.isLt ùîºn
  }

  #check ùïè
  #check ŒΩ
  #check œÉ
  #check ‚Ñô


  def NKIWalker.Path.var_def_at_terminus (ùï° : ‚Ñô) (v : ùïç) : Bool := ùï°.true_at_terminus walker (¬¨ŒΩ hùïè . v)

  def NKIWalker.Path.not_def_at_entry (ùï° : ‚Ñô) (v : walker.Var) : ùï°.nodes.length = 1 ‚Üí ¬¨ ùï°.var_def_at_terminus hùïè v :=
    match h : ùï°.nodes with
    | [n] => by {
        intro
        cases v
        rename_i k hk
        simp [NKIWalker.Path.var_def_at_terminus, NKIWalker.Path.true_at_terminus]
        rw [h]
        simp
        have h_edge: walker.edges 0 n.val := by {
          have hùï° := ùï°.nodes_sound
          unfold NKIWalker.isPath at hùï°
          rw [h] at hùï°
          simp at hùï°
          assumption
        }
        apply œÉ hùïè ‚ü®0,  walker.num_nodes_nonzero‚ü© n ‚ü®k, hk‚ü© h_edge
        simp [transitions, LE.le, instLEOfPreorder, Preorder.toLE, instPreorderBool_compile, Bool.instLE]
      }
    | [] | _ :: _ :: _ => by simp

  @[simp]
  abbrev NKIWalker.Path.motive (ùï° : ‚Ñô) (v : walker.Var) : Prop
    := ùï°.var_def_at_terminus hùïè v ‚Üí ùï°.writes_somewhere walker v

  @[simp]
  abbrev length_motive n := ‚àÄ (ùï° : ‚Ñô) v, ùï°.nodes.length = n ‚Üí (ùï°.motive hùïè v)

  abbrev sound_at_zero : length_motive hùïè 0 := by {
    simp [NKIWalker.Path.var_def_at_terminus, NKIWalker.Path.true_at_terminus,  NKIWalker.Path.writes_somewhere]
    intro _ _ is_zero
    simp [is_zero]
  }

  abbrev sound_at_one : length_motive hùïè 1 := by {
    simp
    intro ùï° v _ _
    exfalso
    apply (ùï°.not_def_at_entry hùïè v)
    assumption
    assumption
  }

  abbrev sound_ind : ‚àÄ len, len ‚â• 1 ‚Üí length_motive hùïè len ‚Üí length_motive hùïè (len + 1) := by {
    unfold length_motive
    intro len len_nonzero IndHyp ùï°‚ÇÅ v ùï°‚ÇÅ_len ŒΩ‚ÇÅ
    cases ùï°‚ÇÅ_def : ùï°‚ÇÅ
    rename_i nodes‚ÇÅ is_path‚ÇÅ
    let ‚ü®n‚ÇÅ, n‚ÇÄ, tl‚ÇÄ, Œµ, unroll, is_path‚ÇÄ‚ü© := ùï°‚ÇÅ.unroll walker (by omega)
    simp [NKIWalker.Path.var_def_at_terminus, NKIWalker.Path.true_at_terminus, ‚Üêunroll] at ŒΩ‚ÇÅ
    let ùï°‚ÇÄ : ‚Ñô := ‚ü®n‚ÇÄ :: tl‚ÇÄ, is_path‚ÇÄ‚ü©
    cases ŒΩ‚ÇÄ : ŒΩ hùïè n‚ÇÄ v
    {
      -- v is defined at n‚ÇÄ - the terminus of ùï°‚ÇÄ, so writes somewhere by ind hypo, then lift
      rw [‚Üêùï°‚ÇÅ_def]
      apply (NKIWalker.Path.writes_somewhere_lifts walker ùï°‚ÇÄ ùï°‚ÇÅ v); simp [‚Üêunroll, ùï°‚ÇÄ]
      apply IndHyp
      simp [‚Üêunroll] at ùï°‚ÇÅ_len
      simp [ùï°‚ÇÄ]
      assumption
      simp [NKIWalker.Path.var_def_at_terminus, NKIWalker.Path.true_at_terminus, ùï°‚ÇÄ]
      assumption
    }
    {
      -- is not defined at n‚ÇÄ -- the terminus of ùï°‚ÇÄ, but is at n‚ÇÅ, the terminus of ùï°‚ÇÅ
      -- since we have Œµ : edge from n‚ÇÄ to n‚ÇÅ, œÉ n‚ÇÄ n‚ÇÄ
      let œÉ' := œÉ hùïè n‚ÇÄ n‚ÇÅ v Œµ
      simp [transitions, LE.le, instLEOfPreorder, Preorder.toLE, instPreorderBool_compile, Bool.instLE, ŒΩ‚ÇÄ, ŒΩ‚ÇÅ] at œÉ'
      let ‚ü®_, œÉ''‚ü© := œÉ'
      cases action_def : walker.actions n‚ÇÄ.val <;> rw [action_def] at œÉ'' <;> try simp at œÉ''
      rename_i _ name _
      simp [NKIWalker.Path.writes_somewhere]
      simp [ùï°‚ÇÅ_def] at unroll
      simp [‚Üêunroll, action_def, NKIWalker.writes]
      apply Or.inl
      assumption
    }
  }

  abbrev sound_everywhere : ‚àÄ n, length_motive hùïè n := fun
    | 0 => sound_at_zero hùïè
    | 1 => sound_at_one hùïè
    | n + 2 => sound_ind hùïè (n + 1) (by omega) (sound_everywhere (n + 1))

  --no def without a write
  def ‚Ñç : ‚àÄ (ùï° : ‚Ñô) v, (ùï°.var_def_at_terminus hùïè v) ‚Üí (ùï°.writes_somewhere walker v) := by {
    intro ùï° v
    apply sound_everywhere
    rfl
  }

  --no read without a def
  def ùïÄ : ‚àÄ (ùï° : ‚Ñô) v, (ùï°.reads_at_terminus walker v) ‚Üí (ùï°.var_def_at_terminus hùïè v)
        := by {
          sorry -- proof by relying an an easily computable hypothesis (abstracted as a var to prove this goal)
        }

  -- no read without a write :)
  def ùïÅ : walker.sound := by {
    unfold NKIWalker.sound
    intro ùï° name reads
    apply ‚Ñç
    apply ùïÄ
    assumption
    assumption
  }

end Test
