/-
# NKI Dataflow

This file uses the Dataflow solver (`InnerMapImpl.Solution`) from `Dataflow.lean`
to analyize NKI functions.

For example, see `test_kernel` below, serialized NKI ASTs can be generated from `klr compile`,
converted to CFGs by the `NKIWalker` class below,
paired with definitions of variable well-definition corresponding to syntactic defs and uses,
and analyzed to get `ùïèopt : Option SolutionT`, which can be printed to view the liveness of
all variables at all program points `#eval ùïèopt`
-/

import KLR.NKI.Basic
import KLR.Compile.Dataflow
import KLR.Compile.DataflowTestKernels

open KLR.NKI

section DefVarAction

  inductive VarAction where
    | Read (name : String) (pos : Pos)
    | Write (name : String) (ty : Option Expr) (pos : Pos)
    | None

  instance VarAction.toString : ToString VarAction where
    toString := fun
      | Read name pos => s!"Read({name} @ {pos.line}, {pos.column})"
      | Write name _ pos => s!"Write({name} @ {pos.line}, {pos.column})"
      | _ => "None"

  def VarAction.var := fun
    | Read name _ => some name
    | Write name _ _ => some name
    | _ => none

end DefVarAction

section DefNKIWalker

  structure NKIWalker where
    num_nodes : ‚Ñï
    num_nodes_nonzero : num_nodes > 0
    last_node : ‚Ñï
    actions : ‚Ñï ‚Üí VarAction
    edges : ‚Ñï ‚Üí ‚Ñï ‚Üí Bool
    breaks : List ‚Ñï
    conts : List ‚Ñï
    rets : List ‚Ñï
    vars : List String --list of varnames seen

  instance NKIWalker.toString : ToString NKIWalker where
    toString walker :=
      let row n :=
        let tgts := (List.range walker.num_nodes).filter (walker.edges n)
        let num := if n = walker.last_node then s!"[{n} (exit)]" else s!"[{n}]"
        s!"Node {num} : {walker.actions n} ‚Ü¶ Nodes {tgts}\n"
      String.intercalate "\n" ((List.range walker.num_nodes).map row ++ ["vars: ", walker.vars.toString])

  def NKIWalker.init : NKIWalker := {
    num_nodes := 1
    num_nodes_nonzero := by trivial
    last_node := 0
    actions _ := VarAction.None
    edges _ _ := false
    breaks := []
    conts := []
    rets := []
    vars := []
  }

  def NKIWalker.Node (walker : NKIWalker) : Type := Fin (walker.num_nodes)
  def NKIWalker.Var (walker : NKIWalker) : Type := Fin (walker.vars.length)

  def NKIWalker.reads (walker : NKIWalker) (n : walker.Node) (v : walker.Var) : Bool :=
    match walker.actions n.val with
    | VarAction.Read name _ => name = walker.vars.get v
    | _ => false

  def NKIWalker.writes (walker : NKIWalker) (n : walker.Node) (v : walker.Var) : Bool :=
    match walker.actions n.val with
    | VarAction.Write name _ _ => name = walker.vars.get v
    | _ => false

  def NKIWalker.is_path (walker : NKIWalker) : List walker.Node ‚Üí Bool := fun
    | [] => True
    | [n] => walker.edges 0 n.val
    | n‚ÇÅ :: n‚ÇÄ :: tl => walker.is_path (n‚ÇÄ :: tl) ‚àß (walker.edges n‚ÇÄ.val n‚ÇÅ.val)

  def NKIWalker.is_path_lowers (walker : NKIWalker) :
    ‚àÄ n ‚Ñì, walker.is_path (n::‚Ñì) ‚Üí walker.is_path ‚Ñì := by {
      intro n‚ÇÅ ‚Ñì‚ÇÅ h
      cases ‚Ñì‚ÇÅ with | nil => simp [is_path] | cons n‚ÇÄ ‚Ñì‚ÇÄ
      simp_all [is_path]
    }

  structure NKIWalker.Path (walker : NKIWalker) where
    nodes : List walker.Node
    nodes_sound : walker.is_path nodes


  -- a path can always be unrolled into a shorter valid one, with proof of an edge across the unrolling
  def NKIWalker.Path.unroll (walker : NKIWalker) (ùï° : walker.Path)
    : ùï°.nodes.length ‚â• 2 ‚Üí
      ‚àÉ (n‚ÇÅ n‚ÇÄ : walker.Node) (tl : List walker.Node),
        (walker.edges n‚ÇÄ.val n‚ÇÅ.val) ‚àß (n‚ÇÅ :: n‚ÇÄ :: tl = ùï°.nodes) ‚àß (walker.is_path (n‚ÇÄ :: tl)) := by {
          intro not_tiny
          rcases ùï°_def : ùï°.nodes
          simp [ùï°_def] at not_tiny
          rename_i n‚ÇÅ tl‚ÇÅ
          rcases tl‚ÇÅ_def : tl‚ÇÅ
          simp [ùï°_def, tl‚ÇÅ_def] at not_tiny
          rename_i n‚ÇÄ tl‚ÇÄ
          exists n‚ÇÅ, n‚ÇÄ, tl‚ÇÄ
          apply And.intro
          {
            let sound := ùï°.nodes_sound
            simp [ùï°_def, tl‚ÇÅ_def, is_path] at sound
            exact sound.right
          }
          {
            simp [‚Üêtl‚ÇÅ_def]
            apply walker.is_path_lowers n‚ÇÅ tl‚ÇÅ
            rw [‚Üêùï°_def]
            apply ùï°.nodes_sound
          }
        }

  def NKIWalker.Path.writes_somewhere (walker : NKIWalker) (ùï° : walker.Path) (v : walker.Var) : Bool :=
    ùï°.nodes.tail.any (walker.writes . v)

  -- easier to rewrite this than find it in the library lol
  abbrev mem_lifts {Œ±} (a : Œ±) (‚Ñì : List Œ±) : a ‚àà ‚Ñì.tail ‚Üí a ‚àà ‚Ñì := by {
    intro h
    cases ‚Ñì
    contradiction
    simp_all
  }

  def NKIWalker.Path.writes_somewhere_lifts (walker : NKIWalker) (ùï°‚ÇÄ ùï°‚ÇÅ : walker.Path) (v : walker.Var)
    : ùï°‚ÇÅ.nodes.tail = ùï°‚ÇÄ.nodes ‚Üí ùï°‚ÇÄ.writes_somewhere walker v ‚Üí ùï°‚ÇÅ.writes_somewhere walker v := by {
      simp [writes_somewhere]
      intro unroll n‚ÇÄ n‚ÇÄ_in n‚ÇÄ_writes
      exists n‚ÇÄ
      apply And.intro
      simp [unroll]
      apply mem_lifts
      assumption
      assumption
    }

  def NKIWalker.Path.true_at_terminus (walker : NKIWalker) (ùï° : walker.Path) (motive : walker.Node ‚Üí Bool) : Bool :=
    match ùï°.nodes with
    | n :: _ => motive n
    | _ => false

  def NKIWalker.Path.reads_at_terminus (walker : NKIWalker) (ùï° : walker.Path) (v : walker.Var) : Bool :=
    ùï°.true_at_terminus walker (walker.reads . v)

  -- proving (or failing to prove) this is the goal!!
  def NKIWalker.sound (walker : NKIWalker) : Prop :=
    ‚àÄ (ùï° : walker.Path) v, (ùï°.reads_at_terminus walker v) ‚Üí (ùï°.writes_somewhere walker v)

  def NKIWalker.processAction (walker : NKIWalker) (action : VarAction) : NKIWalker :=
    let N := walker.num_nodes
    {walker with
      num_nodes := N + 1
      num_nodes_nonzero := by simp
      last_node := N
      actions n := if n = N then action else walker.actions n
      edges A B := (A, B) = (walker.last_node, N)
                  ‚à® (walker.edges A B)
      vars := match action.var with
              | some var => if var ‚àà walker.vars then walker.vars else walker.vars.concat var
              | none => walker.vars
    }


  def NKIWalker.setLast (walker : NKIWalker) (last_node : ‚Ñï) : NKIWalker := {walker with
    last_node := last_node
  }


  def NKIWalker.addEdge (walker : NKIWalker) (a b : ‚Ñï) : NKIWalker := {walker with
    edges A B := (A, B) = (a, b) ‚à® walker.edges A B
  }


  def NKIWalker.addBreak (walker : NKIWalker) : NKIWalker := {walker with
    breaks := walker.breaks ++ [walker.last_node]
  }


  def NKIWalker.clearBreaks (walker : NKIWalker) : NKIWalker := {walker with
    breaks := []
  }

  def NKIWalker.addContinue (walker : NKIWalker): NKIWalker := {walker with
    conts := walker.conts ++ [walker.last_node]
  }


  def NKIWalker.clearConts (walker : NKIWalker) : NKIWalker := {walker with
    conts := []
  }


  def NKIWalker.addReturn (walker : NKIWalker) : NKIWalker := {walker with
    rets := walker.rets ++ [walker.last_node]
  }

  /-mutual
  def NKIWalker.processExpr (walker : NKIWalker) (expr : Expr) : Nat :=
    match h : expr.expr with
    | Expr'.tuple x => (walker.processExprList x).sum
    | _ => 0
    termination_by sizeOf expr
    decreasing_by cases expr; simp at h; rw [h]; simp; omega
  def NKIWalker.processExprList (walker : NKIWalker) (exprs : List Expr) : List Nat :=
    exprs.map walker.processExpr
    termination_by sizeOf exprs
  end-/

  mutual

  def NKIWalker.processExpr (walker : NKIWalker) (expr : Expr) : NKIWalker :=
    let ‚ü®expr, pos‚ü© := expr
    match _ : expr with
    | Expr'.value _ => walker
    | Expr'.var (name : String) => walker.processAction (VarAction.Read name pos)
    | Expr'.proj (expr : Expr) _ => walker.processExpr expr
    | Expr'.tuple (elements : List Expr) => walker.processExprList elements
    | Expr'.access (expr : Expr) _ => walker.processExpr expr
    | Expr'.binOp _ left right => (walker.processExpr left).processExpr right
    | Expr'.ifExp test body orelse =>
      let body_walker := ((walker.processExpr test).processExpr body)
      let orelse_walker := ((body_walker.setLast walker.last_node).processExpr orelse)
      let complete_walker := (orelse_walker.processAction VarAction.None)
      complete_walker.addEdge body_walker.last_node complete_walker.last_node
    | Expr'.call (f: Expr) (args: List Expr) (_ : List Keyword) =>
      (walker.processExpr f).processExprList args
    termination_by sizeOf expr
    decreasing_by
      all_goals {
        try {rename_i expr' _<;> rcases h' : (expr, expr') with ‚ü®‚ü®‚ü®‚ü©, ‚ü®‚ü©‚ü©, ‚ü®‚ü®‚ü©, ‚ü®‚ü©‚ü©‚ü© <;> simp_all <;> omega}
        try {rcases h' : expr with ‚ü®‚ü®‚ü©, ‚ü®‚ü©‚ü© <;> simp_all <;> omega}
      }


  def NKIWalker.processExprList (walker : NKIWalker) (exprs : List Expr) : NKIWalker :=
    exprs.foldl NKIWalker.processExpr walker
    termination_by sizeOf exprs
  end

  mutual

  def NKIWalker.processStmt (walker : NKIWalker) (stmt : Stmt) : NKIWalker :=
    let ‚ü®stmt, pos‚ü© := stmt
    match _ : stmt with
    | Stmt'.expr (e : Expr) => walker.processExpr e
    | Stmt'.assert (e : Expr) => walker.processExpr e
    | Stmt'.ret (e : Expr) => (walker.processExpr e).addReturn
    | Stmt'.assign ‚ü®Expr'.var name, _‚ü© (ty : Option Expr) (e : Option Expr) =>
      let withty := (match ty with | some ty => walker.processExpr ty | none => walker)
      let withe := (match e with | some e => withty.processExpr e | none => withty)
      withe.processAction (VarAction.Write name ty pos)
    | Stmt'.assign _ (ty : Option Expr) (e : Option Expr) =>
      let withty := (match ty with | some ty => walker.processExpr ty | none => walker)
      let withe := (match e with | some e => withty.processExpr e | none => withty)
      withe.processAction (VarAction.Write "<unhandled: writes_to_non_identifier>" ty pos)
    | Stmt'.ifStm (e : Expr) (thn : List Stmt) (els : List Stmt) =>
      let then_walker := (walker.processExpr e).processStmtList thn
      let else_walker := (then_walker.setLast walker.last_node).processStmtList els
      let complete := else_walker.processAction VarAction.None
      complete.addEdge then_walker.last_node complete.last_node
    | Stmt'.forLoop (x : Expr) (iter: Expr) (body: List Stmt) =>
      let intro_walker := (walker.processExpr x).processExpr iter
      let outer_breaks := intro_walker.breaks
      let outer_conts := intro_walker.conts
      let inner_walker := ((intro_walker.clearBreaks).clearConts).processAction VarAction.None
      let enter_node := inner_walker.last_node
      let inner_walked := inner_walker.processStmtList body
      let nearly_complete := (inner_walked.addEdge inner_walked.last_node enter_node).setLast enter_node
      let complete := nearly_complete.processAction VarAction.None
      let exit_node := complete.last_node
      let with_conts := complete.conts.foldl (fun walker cont ‚Ü¶ walker.addEdge cont enter_node) complete
      let with_breaks := complete.breaks.foldl (fun walker brk ‚Ü¶ walker.addEdge brk exit_node) with_conts
      {with_breaks with
        conts := outer_conts
        breaks := outer_breaks
      }
    | Stmt'.breakLoop => (walker.processAction VarAction.None).addBreak
    | Stmt'.continueLoop => (walker.processAction VarAction.None).addContinue
    termination_by sizeOf stmt
    decreasing_by
      try rcases h : (thn, stmt) with ‚ü®‚ü®‚ü®‚ü©, ‚ü®‚ü©‚ü©, ‚ü®‚ü®‚ü©, ‚ü®‚ü©‚ü©‚ü© <;> simp_all <;> omega
      try rcases h : (els, stmt) with ‚ü®‚ü®‚ü®‚ü©, ‚ü®‚ü©‚ü©, ‚ü®‚ü®‚ü©, ‚ü®‚ü©‚ü©‚ü© <;> simp_all <;> omega
      try rcases h : (body, stmt) with ‚ü®‚ü®‚ü®‚ü©, ‚ü®‚ü©‚ü©, ‚ü®‚ü®‚ü©, ‚ü®‚ü©‚ü©‚ü© <;> simp_all <;> omega


  def NKIWalker.processStmtList (walker : NKIWalker) (stmts : List Stmt) : NKIWalker :=
    stmts.foldl NKIWalker.processStmt walker
    termination_by sizeOf stmts
  end


  def NKIWalker.processFun (f : Fun) : NKIWalker :=
    let body_walker := (NKIWalker.init.processStmtList f.body).processAction VarAction.None
    body_walker.rets.foldl (fun walker ret ‚Ü¶ walker.addEdge ret body_walker.last_node) body_walker


  def NKIWalker.isClosed (walker : NKIWalker) := walker.breaks.isEmpty ‚àß walker.conts.isEmpty

end DefNKIWalker

section WithKernel
  variable [HasKernel]

  abbrev ùïÇ := HasKernel.kernel

  /-
    Perform the walk of the AST, converting it into a CFG
  -/
  def walker [HasKernel] : NKIWalker := NKIWalker.processFun ùïÇ

  /-
    extract the transitions from the walker
  -/
  def transitions (n k : ‚Ñï) (pre : Bool) : Bool :=
    (n = 0) ‚à®
    if _ : k < walker.vars.length then
      match walker.actions n with
        | VarAction.Write name _ _ => ¬¨ (name = walker.vars[k]) ‚àß pre
        | _ => pre
    else
      pre

  instance : Preorder Bool where
    le_refl := by trivial
    le_trans := by trivial

  instance : HasBot Bool where
    bot := false

  instance : ToString Bool where
    toString := fun
      | true => "‚ùå"
      | false => "‚úÖ"


  /-
    perform dataflow analysis
  -/
  def ùïèopt := (Solution
        (œÅ:=Bool)
        (le_supl:=by trivial)
        (le_supr:=by trivial)
        (num_nodes:=walker.num_nodes)
        (num_keys:=walker.vars.length)
        (edges:=walker.edges)
        (transitions:=transitions)).map (fun a ‚Ü¶ {a with
          key_labels k := walker.vars[k]?
        })

  variable (hùïè : ùïèopt.isSome)

  abbrev ùïè := ùïèopt.get hùïè
  abbrev ‚Ñô := walker.Path
  abbrev ùïü := walker.Node
  abbrev ùïç := walker.Var
  abbrev ùîº (n‚ÇÄ n‚ÇÅ : walker.Node) := walker.edges n‚ÇÄ.val n‚ÇÅ.val

  abbrev ŒΩ (n : ùïü) (v : ùïç) := (ùïè hùïè).vals n.val v.val n.isLt v.isLt

  abbrev œÉ (n‚ÇÄ n‚ÇÅ : ùïü) (v : ùïç) (ùîºn:ùîº n‚ÇÄ n‚ÇÅ): transitions n‚ÇÄ.val v.val (ŒΩ hùïè n‚ÇÄ v) ‚â§ ŒΩ hùïè n‚ÇÅ v := by {
    apply (ùïè hùïè).props n‚ÇÄ.val n‚ÇÅ.val v.val n‚ÇÄ.isLt n‚ÇÅ.isLt v.isLt ùîºn
  }

  --#check ùïè
  --#check ŒΩ
  --#check œÉ
  --#check ‚Ñô

  abbrev var_def (n : ùïü) (v : ùïç) : Bool := ¬¨ŒΩ hùïè n v
  def NKIWalker.Path.var_def_at_terminus (ùï° : ‚Ñô) (v : ùïç) : Bool := ùï°.true_at_terminus walker (var_def hùïè . v)

  def NKIWalker.Path.not_def_at_entry (ùï° : ‚Ñô) (v : ùïç) : ùï°.nodes.length = 1 ‚Üí ¬¨ ùï°.var_def_at_terminus hùïè v :=
    match h : ùï°.nodes with
    | [n] => by {
        intro
        cases v
        rename_i k hk
        simp [NKIWalker.Path.var_def_at_terminus, NKIWalker.Path.true_at_terminus]
        rw [h]
        simp
        have h_edge: walker.edges 0 n.val := by {
          have hùï° := ùï°.nodes_sound
          unfold NKIWalker.is_path at hùï°
          rw [h] at hùï°
          simp at hùï°
          assumption
        }
        apply œÉ hùïè ‚ü®0,  walker.num_nodes_nonzero‚ü© n ‚ü®k, hk‚ü© h_edge
        simp [transitions, LE.le, instLEOfPreorder, Preorder.toLE, instPreorderBool_compile, Bool.instLE]
      }
    | [] | _ :: _ :: _ => by simp

  @[simp]
  abbrev NKIWalker.Path.motive (ùï° : ‚Ñô) (v : ùïç) : Prop
    := ùï°.var_def_at_terminus hùïè v ‚Üí ùï°.writes_somewhere walker v

  @[simp]
  abbrev length_motive n := ‚àÄ (ùï° : ‚Ñô) v, ùï°.nodes.length = n ‚Üí (ùï°.motive hùïè v)

  abbrev sound_at_zero : length_motive hùïè 0 := by {
    simp [NKIWalker.Path.var_def_at_terminus, NKIWalker.Path.true_at_terminus,  NKIWalker.Path.writes_somewhere]
    intro _ _ is_zero
    simp [is_zero]
  }

  abbrev sound_at_one : length_motive hùïè 1 := by {
    simp
    intro ùï° v _ _
    exfalso
    apply (ùï°.not_def_at_entry hùïè v)
    assumption
    assumption
  }

  abbrev sound_ind : ‚àÄ len, len ‚â• 1 ‚Üí length_motive hùïè len ‚Üí length_motive hùïè (len + 1) := by {
    unfold length_motive
    intro len len_nonzero IndHyp ùï°‚ÇÅ v ùï°‚ÇÅ_len ŒΩ‚ÇÅ
    cases ùï°‚ÇÅ_def : ùï°‚ÇÅ
    rename_i nodes‚ÇÅ is_path‚ÇÅ
    let ‚ü®n‚ÇÅ, n‚ÇÄ, tl‚ÇÄ, Œµ, unroll, is_path‚ÇÄ‚ü© := ùï°‚ÇÅ.unroll walker (by omega)
    simp [NKIWalker.Path.var_def_at_terminus, NKIWalker.Path.true_at_terminus, ‚Üêunroll] at ŒΩ‚ÇÅ
    let ùï°‚ÇÄ : ‚Ñô := ‚ü®n‚ÇÄ :: tl‚ÇÄ, is_path‚ÇÄ‚ü©
    cases ŒΩ‚ÇÄ : ŒΩ hùïè n‚ÇÄ v
    {
      -- v is defined at n‚ÇÄ - the terminus of ùï°‚ÇÄ, so writes somewhere by ind hypo, then lift
      rw [‚Üêùï°‚ÇÅ_def]
      apply (NKIWalker.Path.writes_somewhere_lifts walker ùï°‚ÇÄ ùï°‚ÇÅ v); simp [‚Üêunroll, ùï°‚ÇÄ]
      apply IndHyp
      simp [‚Üêunroll] at ùï°‚ÇÅ_len
      simp [ùï°‚ÇÄ]
      assumption
      simp [NKIWalker.Path.var_def_at_terminus, NKIWalker.Path.true_at_terminus, ùï°‚ÇÄ]
      assumption
    }
    {
      -- is not defined at n‚ÇÄ -- the terminus of ùï°‚ÇÄ, but is at n‚ÇÅ, the terminus of ùï°‚ÇÅ
      -- since we have Œµ : edge from n‚ÇÄ to n‚ÇÅ, œÉ n‚ÇÄ n‚ÇÄ
      let œÉ' := œÉ hùïè n‚ÇÄ n‚ÇÅ v Œµ
      simp [transitions, LE.le, instLEOfPreorder, Preorder.toLE, instPreorderBool_compile, Bool.instLE, ŒΩ‚ÇÄ, ŒΩ‚ÇÅ] at œÉ'
      let ‚ü®_, œÉ''‚ü© := œÉ'
      cases action_def : walker.actions n‚ÇÄ.val <;> rw [action_def] at œÉ'' <;> try simp at œÉ''
      rename_i _ name _
      simp [NKIWalker.Path.writes_somewhere]
      simp [ùï°‚ÇÅ_def] at unroll
      simp [‚Üêunroll, action_def, NKIWalker.writes]
      apply Or.inl
      assumption
    }
  }

  abbrev sound_everywhere : ‚àÄ n, length_motive hùïè n := fun
    | 0 => sound_at_zero hùïè
    | 1 => sound_at_one hùïè
    | n + 2 => sound_ind hùïè (n + 1) (by omega) (sound_everywhere (n + 1))

  def no_def_without_a_write : ‚àÄ (ùï° : ‚Ñô) v, (ùï°.var_def_at_terminus hùïè v) ‚Üí (ùï°.writes_somewhere walker v) := by {
    intro ùï° v
    apply sound_everywhere
    rfl
  }

  abbrev is_safe_at (n : ùïü) (v : ùïç) : Prop := walker.reads n v ‚Üí var_def hùïè n v

  abbrev is_safe : Prop := ‚àÄ (n : ùïü) (v : ùïç), is_safe_at hùïè n v

  abbrev local_safety_decidable : ‚àÄ n v, Decidable (is_safe_at hùïè n v) := by {
    intro n v
    unfold is_safe_at
    cases reads? : walker.reads n v <;>
    cases defs? : var_def hùïè n v <;>
    simp [is_safe_at] <;> try {apply isTrue; trivial}
    apply isFalse; trivial
  }

  inductive Maybe (P : Prop) -- option type plus message option
  | Yes : P ‚Üí Maybe P
  | No : Maybe P
  | NoBC : String ‚Üí Maybe P  --no because of message

  instance Maybe.toString : ToString (Maybe P) where
    toString := fun
    | Yes _ => s!"YES [SAFETY PROVEN]"
    | No => "NO [SAFETY NOT PROVEN]"
    | NoBC s => s!"NO [SAFETY NOT PROVEN] BECAUSE: {s}"

  def Maybe.well? (s : Maybe P) := match s with
  | No => false
  | _ => true

  def decide_success : Maybe (ùïèopt.isSome) := by {
   cases h : ùïèopt with | none => apply Maybe.No | some => {
    apply Maybe.Yes; simp
   }
  }

  abbrev forall_fin {n} (f : Fin n ‚Üí Bool) : Bool := (Vector.ofFn f).all (.)

  abbrev forall_fin_sound (f : Fin n ‚Üí Bool) : forall_fin f ‚Üí (m : Fin n) ‚Üí (f m) := by {
    simp [forall_fin]
    intro h m
    apply h
  }

  abbrev ùïÄ (Œ±) (a : Œ±) := a

  def get_unsafe_reads : List VarAction :=
    (List.ofFn (fun n : ùïü ‚Ü¶ (n, List.ofFn (ùïÄ ùïç)))).flatMap (fun (n, vs) ‚Ü¶
      if vs.any (fun v ‚Ü¶ ¬¨ decide (is_safe_at hùïè n v)) then [walker.actions n.val] else [])

  def get_unsafe_pos : List Pos :=
    (get_unsafe_reads hùïè).flatMap (fun | VarAction.Read _ pos => [pos] | _ => [])

  --def print_unsafe_reads : String :=
    --(get_unsafe_reads hùïè).foldl

  def decide_safety : Maybe (is_safe hùïè) := by {
    let safe := forall_fin (fun n ‚Ü¶ forall_fin (fun v ‚Ü¶ decide (is_safe_at hùïè n v)))
    by_cases safety : safe
    swap;
    -- if any reads occur where a var isnt def this will hit and fail
    apply Maybe.NoBC; apply kernel_highlighted_repr; apply get_unsafe_pos hùïè
    apply Maybe.Yes
    unfold is_safe
    intro n v
    have safety_at_n := forall_fin_sound _ safety n
    have safety := (forall_fin_sound _ safety_at_n v)
    apply of_decide_eq_true
    assumption
  }

  section IfSafe
    variable (safety : ‚àÄ (n : ùïü) (v : ùïç), walker.reads n v ‚Üí ¬¨ŒΩ hùïè n v)

    def no_read_without_a_def : ‚àÄ (ùï° : ‚Ñô) v, (ùï°.reads_at_terminus walker v) ‚Üí (ùï°.var_def_at_terminus hùïè v)
          := by {
            simp [NKIWalker.Path.var_def_at_terminus, NKIWalker.Path.reads_at_terminus, NKIWalker.Path.true_at_terminus]
            intro ùï° v h
            cases nodes_def : ùï°.nodes with | nil | cons n ‚Ñì <;> simp_all [nodes_def]
          }

    def no_read_without_a_write : walker.sound := by {
      unfold NKIWalker.sound
      intro ùï° name reads
      apply no_def_without_a_write
      apply no_read_without_a_def
      assumption
      assumption
    }
  end IfSafe

  def decide_sound : Maybe (walker.sound) := by {
    clear hùïè
    cases decide_success with
      | No | NoBC _ => apply Maybe.No
      | Yes success
    cases (decide_safety success) with
      | No => apply Maybe.No
      | NoBC s => apply Maybe.NoBC s
      | Yes safety
    apply Maybe.Yes
    apply no_read_without_a_write success
    intro n v h
    have specific_safety := safety n v h
    simp [is_safe_at, var_def] at specific_safety
    rw [specific_safety]
    trivial
  }
end WithKernel

instance : HasKernel := safe_kernel_1

#eval decide_sound

instance : HasKernel := unsafe_kernel_2

#eval decide_sound

instance : HasKernel := unsafe_kernel_3

#eval decide_sound
