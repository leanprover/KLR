/-
Copyright KLR Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

     https://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-/

import KLR.Core
import KLR.Trace.Types
import KLR.Util

/-
Typeclass for conversion from NKI representation.

Note the errors generated by these instance are user-facing errors.
-/

namespace KLR.Trace
open KLR.Core

class FromNKI (a : Type) where
  fromNKI? : Term -> Err a

export FromNKI (fromNKI?)

def fromNKI [FromNKI a] (dflt : a) (t : Term) : a :=
  match fromNKI? t with
  | .ok x => x
  | .error _ => dflt

instance [FromNKI a] : FromNKI (List a) where
  fromNKI?
  | .tuple l => l.mapM fromNKI?
  | .list a => a.toList.mapM fromNKI?
  | t => throw s!"expecting sequence ('list' or 'tuple'), got '{Term.kindStr t}'"

instance [FromNKI a] : FromNKI (Option a) where
  fromNKI?
    | .none => return none
    | e => return some (<- fromNKI? e)

instance [FromNKI a] [FromNKI b] : FromNKI (Sum a b) where
  fromNKI? t := do
    match fromNKI? t with
    | .ok a => return .inl a
    | .error _ =>
      match fromNKI? t with
      | .ok b => return .inr b
      | .error e => throw s!"cannot convert to either type in sum: {e}"

instance [FromNKI a] [FromNKI b] : FromNKI (a × b) where
  fromNKI?
  | .tuple [x, y]
  | .list #[x, y] => do return (<- fromNKI? x, <- fromNKI? y)
  | t => throw s!"expecting 'pair', got '{Term.kindStr t}'"

instance : FromNKI Term := ⟨ .ok ⟩

instance : FromNKI Address where
  fromNKI?
  | .pointer addr => return addr
  | t => throw s!"expecting 'pointer', got '{Term.kindStr t}'"

instance : FromNKI Bool where
  fromNKI?
    | .bool b => return b
    | t => throw s!"expecting 'boolean', got '{Term.kindStr t}'"

-- Avoid lean limitation of partial instances. Seems like the language
-- doesn't understand well when we just call to FromNKI? from FromNKI?
-- instance itself, but has no problem with defs
partial def fromNKIInt : Term -> Err Int
  | .bool true => return 1
  | .bool false => return 0
  | .int i => return i
  | t@(.object _ fields) =>
    match AA.lookup? fields "value" with
    | some v => fromNKIInt v
    | _ => throw s!"expecting 'integer', got '{Term.kindStr t}'. Couldn't cast object to integer"
  | t => throw s!"expecting 'integer', got '{Term.kindStr t}'"

instance : FromNKI Int where
  fromNKI? := fromNKIInt

instance : FromNKI Nat where
  fromNKI? t := do
    let i <- fromNKIInt t
    match i with
    | .ofNat n => return n
    | _ => throw s!"expecting positive 'integer', got '{Term.kindStr t}'"

instance : FromNKI Float where
  fromNKI?
    | .bool true => return 1
    | .bool false => return 0
    | .int i => return Float.ofInt i
    | .float f => return f
    | t => throw s!"expecting 'float', got '{Term.kindStr t}'"

instance : FromNKI Float32 where
  fromNKI? t := do
    let f : Float <- fromNKI? t
    return f.toFloat32

instance : FromNKI Immediate where
  fromNKI?
    | .bool true => return .int 1
    | .bool false => return .int 0
    | .int i => return .int i.toInt32
    | .float f => return .float f.toFloat32
    | t => throw s!"expecting int or 'float', got '{Term.kindStr t}'"

instance : FromNKI String where
  fromNKI?
    | .string s => return s
    | t => throw s!"expecting 'string', got '{Term.kindStr t}'"

instance : FromNKI TensorLib.Tensor where
  fromNKI?
  | .tensor t => return t
  | t => throw s!"expecting a 'tensor', got '{Term.kindStr t}'"

-- Enums are a mess because they can come across in different ways from Python.
-- This function will try all the variations.

private def fromEnum : Term -> Option String
  | .module name
  | .builtin name ..
  | .source { name ..}
  | .cls name
  | .method name ..
  | .var name =>
     match name with
     | .str _ s => some s
     | _ => none
  | .object _ fs =>
     match AA.lookup? fs "name" with
     | some (.string s) => some s
     | _ => none
  | .string s =>
       match s.toName with
       | .str _ s => some s
       | _ => some s
  | _ => none

-- TODO: when new NKI API is settled, rewrite is a nicer way
instance : FromNKI Dtype where
  fromNKI? t :=
    match fromEnum t with
    | some "uint8" => return .uint8
    | some "int8" => return .int8
    | some "uint16" => return .uint16
    | some "int16" => return .int16
    | some "uint32" => return .uint32
    | some "int32" => return .int32
    | some "float8e3" => return .float8e3
    | some "float8e4" => return .float8e4
    | some "float8e5" => return .float8e5
    | some "float8_e4m3" => return .float8e4
    | some "float8_e5m2" => return .float8e5
    | some "float16" => return .float16
    | some "bfloat16" => return .bfloat16
    | some "tfloat32" => return .float32r
    | some "float32" => return .float32
    | some "bool_" => return .uint8
    | some "bool" => return .uint8
    | some "float8_e4m3fn" => return .float8_e4m3fn
    | some "float8_e5m2_x4" => return .float8_e5m2_x4
    | some "float8_e4m3fn_x4" => return .float8_e4m3fn_x4
    | some "float4_e2m1fn_x4" => return .float4_e2m1fn_x4
    | some name => throw s!"unsupported dtype '{name}'"
    | none => throw s!"expecting 'dtype', got '{Term.kindStr t}'"

instance : FromNKI Shape where
  fromNKI? t := do
    let l : List Nat <- fromNKI? t
    match l with
    | [] => throw "invalid shape"
    | p :: f => return ⟨ p, f ⟩

instance : FromNKI Memory where
  fromNKI? t := do
    if let .pointer p := t then
      return p.memory
    match fromEnum t with
    | some "shared_hbm" => return .hbm
    | some "private_hbm" => return .private_hbm
    | some "hbm" => return .hbm
    | some "sbuf" => return .sbuf
    | some "psum" => return .psum
    | _ => throw s!"expecting buffer type, got {Term.kindStr t}"

instance : FromNKI Engine where
  fromNKI? t :=
    match fromEnum t with
    | some "unknown_engine" => return .unassigned
    | some "tensor_engine" => return .pe
    | some "vector_engine" => return .dve
    | some "scalar_engine" => return .act
    | some "gpsimd_engine" => return .pool
    | some "unknown" => return .unassigned
    | some "tensor" => return .pe
    | some "vector" => return .dve
    | some "scalar" => return .act
    | some "gpsimd" => return .pool
    | _ => throw s!"expecting engine type, got {Term.kindStr t}"

instance : FromNKI Access where
  fromNKI?
    | .access a => return a
    | t => throw s!"expecting tensor access, got '{Term.kindStr t}'"

instance : FromNKI TensorName where
  fromNKI?
    | .access (.simple t) => return t
    | t => throw s!"expecting 'tensor', got '{Term.kindStr t}'"

instance : FromNKI AluOp where
  fromNKI? t :=
    match fromEnum t with
    -- bitwise operations
    | some "invert" => return .bitwise_not
    | some "bitwise_and" => return .bitwise_and
    | some "bitwise_or" => return .bitwise_or
    | some "bitwise_xor" => return .bitwise_xor
    | some "left_shift" => return .logical_shift_left
    | some "right_shift" => return .logical_shift_right
    -- arithemetic operations
    | some "add" => return .add
    | some "subtract" => return .subtract
    | some "multiply" => return .mult
    | some "maximum" => return .max
    | some "minimum" => return .min
    | some "equal" => return .is_equal
    | some "not_equal" => return .not_equal
    | some "greater_equal" => return .is_ge
    | some "greater" => return .is_gt
    | some "less_equal" => return .is_le
    | some "less" => return .is_lt
    | some "logical_not" => throw "'logical_not' operator not supported"
    | some "logical_and" => return .logical_and
    | some "logical_or" => return .logical_or
    | some "logical_xor" => return .logical_xor
    | some "rsqrt" => return .rsqrt
    | some "abs" => return .abs
    | some "power" => return .pow
    | _ => throw s!"expecting operator, got '{Term.kindStr t}'"

instance : FromNKI ActivationFunc where
  fromNKI? t :=
    match fromEnum t with
    | some "copy" => return .copy
    | some "square" => return .square
    | some "sigmoid" => return .sigmoid
    | some "relu" => return .relu
    | some "gelu" => return .gelu
    | some "gelu_dx" => return .gelu_dx
    | some "gelu_apprx_tanh" => return .gelu_apprx_tanh
    | some "silu" => return .silu
    | some "silu_dx" => return .silu_dx
    | some "tanh" => return .tanh
    | some "softplus" => return .softplus
    | some "mish" => return .mish
    | some "erf" => return .erf
    | some "erf_dx" => return .erf_dx
    | some "exp" => return .exp
    | some "log" => return .log
    | some "sin" => return .sin
    | some "arctan" => return .arctan
    | some "sqrt" => return .sqrt
    | some "rsqrt" => return .rsqrt
    | some "reciprocal" => return .reciprocal
    | some "sign" => return .sign
    | some "abs" => return .abs
    | some "gelu_apprx_sigmoid" => return .gelu_apprx_sigmoid
    | some "gelu_apprx_sigmoid_dx" => return .gelu_apprx_sigmoid_dx
    | _ => throw s!"expecting activation function, got '{Term.kindStr t}'"

instance : FromNKI AccumCmd where
  fromNKI? t :=
    match fromEnum t with
    | some "idle" => return .Idle
    | some "reset" => return .Zero
    | some "reduce" => return .Accumulate
    | some "reset_reduce" => return .ZeroAccumulate
    | some "load_reduce" => return .LoadAccumulate
    | _ => throw "expecting accumulator command (idle, reset, reduce, reset_reduce, load_reduce)"

instance : FromNKI MatmulPerfMode where
  fromNKI? t :=
    match fromEnum t with
    | some "none" => return .None
    | some "double_row" => return .DoubleRow
    | some "double_row_sw_interleave" => return .DoubleRowSwInterleave
    | _ => throw "expecting matmul performance mode (none, double_row, double_row_sw_interleave)"

instance : FromNKI PrintOutputBuffer where
  fromNKI? t := do
    match fromEnum t with
    | some "stdout" => return .stdout
    | some "stderr" => return .stderr
    | _ => throw s!"expecting output buffer type, got {Term.kindStr t}"
