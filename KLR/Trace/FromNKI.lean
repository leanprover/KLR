/-
Copyright KLR Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

     https://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-/

import KLR.Core
import KLR.Trace.Types
import KLR.Util

/-
Typeclass for conversion from NKI representation.

Note the errors generated by these instance are user-facing errors.
-/

namespace KLR.Trace
open KLR.Core

class FromNKI (a : Type) where
  fromNKI? : Term -> Err a

export FromNKI (fromNKI?)

def fromNKI [FromNKI a] (dflt : a) (t : Term) : a :=
  match fromNKI? t with
  | .ok x => x
  | .error _ => dflt

instance [FromNKI a] : FromNKI (List a) where
  fromNKI?
  | .tuple l => l.mapM fromNKI?
  | .list a => a.toList.mapM fromNKI?
  | t => throw s!"expecting sequence ('list' or 'tuple'), got '{Term.kindStr t}'"

instance [FromNKI a] : FromNKI (Option a) where
  fromNKI?
    | .none => return none
    | e => return some (<- fromNKI? e)

instance [FromNKI a] [FromNKI b] : FromNKI (Sum a b) where
  fromNKI? t := do
    match fromNKI? t with
    | .ok a => return .inl a
    | .error _ =>
      match fromNKI? t with
      | .ok b => return .inr b
      | .error e => throw s!"cannot convert to either type in sum: {e}"

instance [FromNKI a] [FromNKI b] : FromNKI (a × b) where
  fromNKI?
  | .tuple [x, y]
  | .list #[x, y] => do return (<- fromNKI? x, <- fromNKI? y)
  | t => throw s!"expecting 'pair', got '{Term.kindStr t}'"

instance : FromNKI Term := ⟨ .ok ⟩

instance : FromNKI Address where
  fromNKI?
  | .pointer addr => return addr
  | t => throw s!"expecting 'pointer', got '{Term.kindStr t}'"

instance : FromNKI Bool where
  fromNKI?
    | .bool b => return b
    | t => throw s!"expecting 'boolean', got '{Term.kindStr t}'"

instance : FromNKI Int where
  fromNKI?
    | .bool true => return 1
    | .bool false => return 0
    | .int i => return i
    | t@(.object _ fields) =>
      match AA.lookup? fields "value" with
      | some (.int n) => return n
      | _ => throw s!"expecting 'integer', got '{Term.kindStr t}'. Couldn't cast object to integer"
    | t => throw s!"expecting 'integer', got '{Term.kindStr t}'"

instance : FromNKI Nat where
  fromNKI?
    | .bool true => return 1
    | .bool false => return 0
    | .int (.ofNat n) => return n
    | t@(.object _ fields) =>
      match AA.lookup? fields "value" with
      | some (.int (.ofNat n)) => return n
      | _ => throw s!"expecting positive 'integer', got '{Term.kindStr t}'. Couldn't cast object to positive integer"
    | t => throw s!"expecting positive 'integer', got '{Term.kindStr t}'"

instance : FromNKI Float where
  fromNKI?
    | .bool true => return 1
    | .bool false => return 0
    | .int i => return Float.ofInt i
    | .float f => return f
    | t => throw s!"expecting 'float', got '{Term.kindStr t}'"

instance : FromNKI Float32 where
  fromNKI? t := do
    let f : Float <- fromNKI? t
    return f.toFloat32

instance : FromNKI Immediate where
  fromNKI?
    | .bool true => return .int 1
    | .bool false => return .int 0
    | .int i => return .int i
    | .float f => return .float f.toFloat32
    | t => throw s!"expecting int or 'float', got '{Term.kindStr t}'"

instance : FromNKI String where
  fromNKI?
    | .string s => return s
    | t => throw s!"expecting 'string', got '{Term.kindStr t}'"

instance : FromNKI TensorLib.Tensor where
  fromNKI?
  | .tensor t => return t
  | t => throw s!"expecting a 'tensor', got '{Term.kindStr t}'"

-- TODO: when new NKI API is settled, rewrite is a nicer way
instance : FromNKI Dtype where
  fromNKI?
    | .object name _
    | .source {name ..}
    | .var name =>
      match name with
      -- NKI variants (see table in NKI docs)
      | `nki.language.uint8 => .ok .uint8
      | `nki.language.int8 => .ok .int8
      | `nki.language.uint16 => .ok .uint16
      | `nki.language.int16 => .ok .int16
      | `nki.language.uint32 => .ok .int32
      | `nki.language.int32 => .ok .int32
      | `nki.language.float8e3 => .ok .float8e3
      | `nki.language.float8e4 => .ok .float8e4
      | `nki.language.float8e5 => .ok .float8e5
      | `nki.language.float8_e4m3 => .ok .float8e4
      | `nki.language.float8_e5m2 => .ok .float8e5
      | `nki.language.float16 => .ok .float16
      | `nki.language.bfloat16 => .ok .bfloat16
      | `nki.language.tfloat32 => .ok .float32r  -- TODO check this
      | `nki.language.float32 => .ok .float32
      | `nki.language.bool_ => .ok .uint8
      | `nki.language.float8_e4m3fn => .ok .float8_e4m3fn
      | `nki.language.float8_e5m2_x4 => .ok .float8_e5m2_x4
      | `nki.language.float8_e4m3fn_x4 => .ok .float8_e4m3fn_x4
      | `nki.language.float4_e2m1fn_x4 => .ok .float4_e2m1fn_x4
      -- torch variants
      | `torch.uint8 => .ok .uint8
      | `torch.int8 => .ok .int8
      | `torch.int16 => .ok .int16
      | `torch.int32 => .ok .int32
      | `torch.float16 => .ok .float16
      | `torch.float32 => .ok .float32
      | `torch.bfloat16 => .ok .bfloat16
      | `torch.bool => .ok .uint8
      -- numpy variants
      | `numpy.uint8 => .ok .uint8
      | `numpy.int8 => .ok .int8
      | `numpy.uint16 => .ok .uint16
      | `numpy.int16 => .ok .int16
      | `numpy.uint32 => .ok .uint32
      | `numpy.int32 => .ok .int32
      | `numpy.float16 => .ok .float16
      | `numpy.float32 => .ok .float32
      | `numpy.bool => .ok .uint8
      | _ => throw s!"unsupported dtype '{name}'"
    | .string name =>
      match (name.split (· == '.')).getLast? with
      | some last =>
        match last with
        -- imported and string variants
        | "uint8" => .ok .uint8
        | "int8" => .ok .int8
        | "uint16" => .ok .uint16
        | "int16" => .ok .int16
        | "uint32" => .ok .int32
        | "int32" => .ok .int32
        | "float8e3" => .ok .float8e3
        | "float8e4" => .ok .float8e4
        | "float8e5" => .ok .float8e5
        | "float8_e4m3" => .ok .float8e4
        | "float8_e5m2" => .ok .float8e5
        | "float16" => .ok .float16
        | "bfloat16" => .ok .bfloat16
        | "tfloat32" => .ok .float32r  -- TODO check this
        | "float32" => .ok .float32
        | "bool" => .ok .uint8
        | "float8_e4m3fn" => .ok .float8_e4m3fn
        | "float8_e5m2_x4" => .ok .float8_e5m2_x4
        | "float8_e4m3fn_x4" => .ok .float8_e4m3fn_x4
        | "float4_e2m1fn_x4" => .ok .float4_e2m1fn_x4
        | _ => throw s!"unsupported dtype '{name}'"
      | none => throw s!"unsupported dtype '{name}'"
    | t => throw s!"expecting 'dtype', got '{Term.kindStr t}'"

instance : FromNKI Shape where
  fromNKI? t := do
    let l : List Nat <- fromNKI? t
    match l with
    | [] => throw "invalid shape"
    | p :: f => return ⟨ p, f ⟩

instance : FromNKI Memory where
  fromNKI? t :=
    let err := .error s!"expecting buffer type, got {Term.kindStr t}"
    match t with
    | .var name =>
      match name with
      -- TODO: do we need to distinguish the different HBM types?
      | `nki.language.shared_hbm => .ok .hbm
      | `nki.language.private_hbm => .ok .hbm
      | `nki.language.hbm => .ok .hbm
      | `nki.language.sbuf => .ok .sbuf
      | `nki.language.psum => .ok .psum
      | _ => err
    | .pointer p => return p.memory
    | _ => err

instance : FromNKI Engine where
  fromNKI? t :=
    let err := .error "expecting engine type"
    match t with
    | .var name =>
      match name with
      | `nki.isa.unknown_engine => .ok .unassigned
      | `nki.isa.tensor_engine => .ok .pe
      | `nki.isa.vector_engine => .ok .dve
      | `nki.isa.scalar_engine => .ok .act
      | _ => err
    | _ => err

instance : FromNKI Access where
  fromNKI?
    | .access a => return a
    | t => throw s!"expecting tensor access, got '{Term.kindStr t}'"

instance : FromNKI TensorName where
  fromNKI?
    | .access (.simple t) => return t
    | t => throw s!"expecting 'tensor', got '{Term.kindStr t}'"

instance : FromNKI AluOp where
  fromNKI?
    | .none => return .bypass
    | .var name =>
        match name with
        -- bitwise operations
        | `nki.language.invert => return .bitwise_not
        | `nki.language.bitwise_and => return .bitwise_and
        | `nki.language.bitwise_or => return .bitwise_or
        | `nki.language.bitwise_xor => return .bitwise_xor
        | `nki.language.left_shift => return .logical_shift_left
        | `nki.language.right_shift => return .logical_shift_right
        -- numpy variants
        | `numpy.bitwise_not => return .bitwise_not
        | `numpy.bitwise_invert => return .bitwise_not
        | `numpy.bitwise_and => return .bitwise_and
        | `numpy.bitwise_or => return .bitwise_or
        | `numpy.bitwise_xor => return .bitwise_xor
        | `numpy.bitwise_left_shift => return .logical_shift_left
        | `numpy.bitwise_right_shift => return .logical_shift_right
        -- arithemetic operations
        | `nki.language.add => return .add
        | `nki.language.subtract => return .subtract
        | `nki.language.multiply => return .mult
        | `nki.language.maximum => return .max
        | `nki.language.minimum => return .min
        | `nki.language.equal => return .is_equal
        | `nki.language.not_equal => return .not_equal
        | `nki.language.greater_equal => return .is_ge
        | `nki.language.greater => return .is_gt
        | `nki.language.less_equal => return .is_le
        | `nki.language.less => return .is_lt
        | `nki.language.logical_not => throw "'logical_not' operator not supported"
        | `nki.language.logical_and => return .logical_and
        | `nki.language.logical_or => return .logical_or
        | `nki.language.logical_xor => return .logical_xor
        -- numpy variants
        | `numpy.add => return .add
        | `numpy.subtract => return .subtract
        | `numpy.multiply => return .mult
        | `numpy.maximum => return .max
        | `numpy.minimum => return .min
        | `numpy.equal => return .is_equal
        | `numpy.not_equal => return .not_equal
        | `numpy.greater_equal => return .is_ge
        | `numpy.greater => return .is_gt
        | `numpy.less_equal => return .is_le
        | `numpy.less => return .is_lt
        | `numpy.logical_not => throw "'logical_not' operator not supported"
        | `numpy.logical_and => return .logical_and
        | `numpy.logical_or => return .logical_or
        | `numpy.logical_xor => return .logical_xor
        | _ => throw s!"unsupported operator {name}"
    | t => throw s!"expecting operator, got '{Term.kindStr t}'"

instance : FromNKI ActivationFunc where
  fromNKI? t :=
    let err := .error "expecting activation function (e.g., relu, sigmoid, tanh, gelu)"
    match t with
    | .var name =>
      match name with
      | `nki.language.copy | `numpy.copy => return .copy
      | `nki.language.square | `numpy.square => return .square
      | `nki.language.sigmoid => return .sigmoid
      | `nki.language.relu => return .relu
      | `nki.language.gelu => return .gelu
      | `nki.language.gelu_dx => return .gelu_dx
      | `nki.language.gelu_apprx_tanh => return .gelu_apprx_tanh
      | `nki.language.silu => return .silu
      | `nki.language.silu_dx => return .silu_dx
      | `nki.language.tanh | `numpy.tanh => return .tanh
      | `nki.language.softplus => return .softplus
      | `nki.language.mish => return .mish
      | `nki.language.erf => return .erf
      | `nki.language.erf_dx => return .erf_dx
      | `nki.language.exp | `numpy.exp => return .exp
      | `nki.language.log | `numpy.log => return .log
      | `nki.language.sin | `numpy.sin => return .sin
      | `nki.language.arctan | `numpy.arctan => return .arctan
      | `nki.language.sqrt | `numpy.sqrt => return .sqrt
      | `nki.language.rsqrt => return .rsqrt
      | `nki.language.reciprocal | `numpy.reciprocal => return .reciprocal
      | `nki.language.sign | `numpy.sign => return .sign
      | `nki.language.abs | `numpy.abs => return .abs
      | _ => err
    | _ => err


instance : FromNKI AccumCmd where
  fromNKI? t :=
    let err := .error s!"expecting accumulator command (idle, reset, reduce, reset_reduce), got {repr t}"
    match t with
    | .object `nki.isa.reduce_cmd vs =>
      match AA.lookup? vs "name" with
      | some (.string "idle") => return .Idle
      | some (.string "reset") => return .Zero
      | some (.string "reduce") => return .Accumulate
      | some (.string "reset_reduce") => return .ZeroAccumulate
      | _ => err
    | .var name =>
      match name with
      | `nki.isa.reduce_cmd.idle => return .Idle
      | `nki.isa.reduce_cmd.reset => return .Zero
      | `nki.isa.reduce_cmd.reduce => return .Accumulate
      | `nki.isa.reduce_cmd.reset_reduce => return .ZeroAccumulate
      -- Something should emit LoadAccumulate? Not sure what
      | _ => err
    | _ => err
