/-
Copyright KLR Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

     https://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-/

import KLR.Core
import KLR.Trace.Types
import KLR.Util

/-
Typeclass for conversion from NKI representation.

Note the errors generated by these instance are user-facing errors.
-/

namespace KLR.Trace
open KLR.Core

class FromNKI (a : Type) where
  fromNKI? : Term -> Err a

export FromNKI (fromNKI?)

def fromNKI [FromNKI a] (dflt : a) (t : Term) : a :=
  match fromNKI? t with
  | .ok x => x
  | .error _ => dflt

instance [FromNKI a] : FromNKI (List a) where
  fromNKI?
  | .tuple l => l.mapM fromNKI?
  | .list a => a.toList.mapM fromNKI?
  | _ => throw "expecting sequence (list or tuple)"

instance [FromNKI a] : FromNKI (Option a) where
  fromNKI?
    | .none => return none
    | e => return some (<- fromNKI? e)

instance [FromNKI a] [FromNKI b] : FromNKI (Sum a b) where
  fromNKI? t := do
    match fromNKI? t with
    | .ok a => return .inl a
    | .error _ =>
      match fromNKI? t with
      | .ok b => return .inr b
      | .error e => throw s!"cannot convert to either type in sum: {e}"

instance [FromNKI a] [FromNKI b] : FromNKI (a × b) where
  fromNKI?
  | .tuple [x, y] => do return (<- fromNKI? x, <- fromNKI? y)
  | _ => throw "expecting 2-tuple"

instance : FromNKI Term := ⟨ .ok ⟩

instance : FromNKI Address where
  fromNKI?
  | .pointer addr => return addr
  | _ => throw "expecting pointer"

instance : FromNKI Bool where
  fromNKI?
    | .bool b => return b
    | _ => throw "expecting boolean"

instance : FromNKI Int where
  fromNKI?
    | .bool true => return 1
    | .bool false => return 0
    | .int i => return i
    | _ => throw "expecting integer"

instance : FromNKI Nat where
  fromNKI?
    | .bool true => return 1
    | .bool false => return 0
    | .int (.ofNat n) => return n
    | _ => throw "expecting positive integer"

instance : FromNKI Float where
  fromNKI?
    | .bool true => return 1
    | .bool false => return 0
    | .int i => return Float.ofInt i
    | .float f => return f
    | _ => throw "expecting float"

instance : FromNKI Float32 where
  fromNKI? t := do
    let f : Float <- fromNKI? t
    return f.toFloat32

instance : FromNKI Immediate where
  fromNKI?
    | .bool true => return .int 1
    | .bool false => return .int 0
    | .int i => return .int i
    | .float f => return .float f.toFloat32
    | _ => throw "expecting int or float"

instance : FromNKI String where
  fromNKI?
    | .string s => return s
    | _ => throw "expecting string"

-- TODO: when new NKI API is settled, rewrite is a nicer way
instance : FromNKI Dtype where
  fromNKI?
    | .var name =>
      match name with
      -- NKI variants (see table in NKI docs)
      | `neuronxcc.nki.language.uint8 => .ok .uint8
      | `neuronxcc.nki.language.int8 => .ok .int8
      | `neuronxcc.nki.language.uint16 => .ok .uint16
      | `neuronxcc.nki.language.int16 => .ok .int16
      | `neuronxcc.nki.language.uint32 => .ok .int32
      | `neuronxcc.nki.language.int32 => .ok .int32
      | `neuronxcc.nki.language.float8e3 => .ok .float8e3
      | `neuronxcc.nki.language.float8e4 => .ok .float8e4
      | `neuronxcc.nki.language.float8e5 => .ok .float8e5
      | `neuronxcc.nki.language.float8_e4m3 => .ok .float8e4
      | `neuronxcc.nki.language.float8_e5m2 => .ok .float8e5
      | `neuronxcc.nki.language.float16 => .ok .float16
      | `neuronxcc.nki.language.bfloat16 => .ok .bfloat16
      | `neuronxcc.nki.language.tfloat32 => .ok .float32r  -- TODO check this
      | `neuronxcc.nki.language.float32 => .ok .float32
      | `neuronxcc.nki.language.bool_ => .ok .uint8
      -- numpy variants
      | `numpy.uint8 => .ok .uint8
      | `numpy.int8 => .ok .int8
      | `numpy.uint16 => .ok .uint16
      | `numpy.int16 => .ok .int16
      | `numpy.uint32 => .ok .uint32
      | `numpy.int32 => .ok .int32
      | `numpy.float16 => .ok .float16
      | `numpy.float32 => .ok .float32
      | `numpy.bool => .ok .uint8
      | _ => throw s!"unsupported dtype {name}"
    | .string name =>
      match name with
      -- imported and string variants
      | "uint8" => .ok .uint8
      | "int8" => .ok .int8
      | "uint16" => .ok .uint16
      | "int16" => .ok .int16
      | "uint32" => .ok .int32
      | "int32" => .ok .int32
      | "float8e3" => .ok .float8e3
      | "float8e4" => .ok .float8e4
      | "float8e5" => .ok .float8e5
      | "float8_e4m3" => .ok .float8e4
      | "float8_e5m2" => .ok .float8e5
      | "float16" => .ok .float16
      | "bfloat16" => .ok .bfloat16
      | "tfloat32" => .ok .float32r  -- TODO check this
      | "float32" => .ok .float32
      | "bool" => .ok .uint8
      | _ => throw s!"unsupported dtype {name}"
    | _ => throw s!"expecting dtype"

instance : FromNKI Shape where
  fromNKI? t := do
    let l : List Nat <- fromNKI? t
    match l with
    | [] => throw "invalid shape"
    | p :: f => return ⟨ p, f ⟩

instance : FromNKI Memory where
  fromNKI? t :=
    let err := .error "expecting buffer type"
    match t with
    | .var name =>
      match name with
      -- TODO: do we need to distinguish the different HBM types?
      | `neuronxcc.nki.language.shared_hbm => .ok .hbm
      | `neuronxcc.nki.language.private_hbm => .ok .hbm
      | `neuronxcc.nki.language.hbm => .ok .hbm
      | `neuronxcc.nki.language.sbuf => .ok .sbuf
      | `neuronxcc.nki.language.psum => .ok .psum
      | _ => err
    | _ => err

instance : FromNKI Engine where
  fromNKI? t :=
    let err := .error "expecting engine type"
    match t with
    | .var name =>
      match name with
      | `neuronxcc.nki.isa.unknown_engine => .ok .unassigned
      | `neuronxcc.nki.isa.tensor_engine => .ok .pe
      | `neuronxcc.nki.isa.vector_engine => .ok .dve
      | `neuronxcc.nki.isa.scalar_engine => .ok .sp
      | _ => err
    | _ => err

instance : FromNKI Access where
  fromNKI?
    | .access a => return a
    | _ => throw "expecting tensor access"

instance : FromNKI TensorName where
  fromNKI?
    | .access (.simple t) => return t
    | _ => throw "expecting tensor"

instance : FromNKI AluOp where
  fromNKI?
    | .none => return .bypass
    | .var name =>
        match name with
        -- bitwise operations
        | `neuronxcc.nki.language.invert => return .bitwise_not
        | `neuronxcc.nki.language.bitwise_and => return .bitwise_and
        | `neuronxcc.nki.language.bitwise_or => return .bitwise_or
        | `neuronxcc.nki.language.bitwise_xor => return .bitwise_xor
        | `neuronxcc.nki.language.left_shift => return .logical_shift_left
        | `neuronxcc.nki.language.right_shift => return .logical_shift_right
        -- numpy variants
        | `numpy.bitwise_not => return .bitwise_not
        | `numpy.bitwise_invert => return .bitwise_not
        | `numpy.bitwise_and => return .bitwise_and
        | `numpy.bitwise_or => return .bitwise_or
        | `numpy.bitwise_xor => return .bitwise_xor
        | `numpy.bitwise_left_shift => return .logical_shift_left
        | `numpy.bitwise_right_shift => return .logical_shift_right
        -- arithemetic operations
        | `neuronxcc.nki.language.add => return .add
        | `neuronxcc.nki.language.subtract => return .subtract
        | `neuronxcc.nki.language.multiply => return .mult
        | `neuronxcc.nki.language.maximum => return .max
        | `neuronxcc.nki.language.minimum => return .min
        | `neuronxcc.nki.language.equal => return .is_equal
        | `neuronxcc.nki.language.not_equal => return .not_equal
        | `neuronxcc.nki.language.greater_equal => return .is_ge
        | `neuronxcc.nki.language.greater => return .is_gt
        | `neuronxcc.nki.language.less_equal => return .is_le
        | `neuronxcc.nki.language.less => return .is_lt
        | `neuronxcc.nki.language.logical_not => throw "??"
        | `neuronxcc.nki.language.logical_and => return .logical_and
        | `neuronxcc.nki.language.logical_or => return .logical_or
        | `neuronxcc.nki.language.logical_xor => return .logical_xor
        -- numpy variants
        | `numpy.add => return .add
        | `numpy.subtract => return .subtract
        | `numpy.multiply => return .mult
        | `numpy.maximum => return .max
        | `numpy.minimum => return .min
        | `numpy.equal => return .is_equal
        | `numpy.not_equal => return .not_equal
        | `numpy.greater_equal => return .is_ge
        | `numpy.greater => return .is_gt
        | `numpy.less_equal => return .is_le
        | `numpy.less => return .is_lt
        | `numpy.logical_not => throw "??"
        | `numpy.logical_and => return .logical_and
        | `numpy.logical_or => return .logical_or
        | `numpy.logical_xor => return .logical_xor
        | _ => throw s!"unsupported operator {name}"
    | _ => throw "expecting operator"

instance : FromNKI ActivationFunc where
  fromNKI? t :=
    let err := .error "expecting activation function type"
    match t with
    | .var name =>
      match name with
      | `neuronxcc.nki.language.copy | `numpy.copy => return .copy
      | `neuronxcc.nki.language.square | `numpy.square => return .sqrt
      | `neuronxcc.nki.language.sigmoid => return .sigmoid
      | `neuronxcc.nki.language.relu => return .relu
      | `neuronxcc.nki.language.gelu => return .gelu
      | `neuronxcc.nki.language.gelu_dx => return .gelu_dx
      | `neuronxcc.nki.language.gelu_apprx_tanh => return .gelu_apprx_tanh
      | `neuronxcc.nki.language.silu => return .silu
      | `neuronxcc.nki.language.silu_dx => return .silu_dx
      | `neuronxcc.nki.language.tanh | `numpy.tanh => return .tanh
      | `neuronxcc.nki.language.softplus => return .softplus
      | `neuronxcc.nki.language.mish => return .mish
      | `neuronxcc.nki.language.erf => return .erf
      | `neuronxcc.nki.language.erf_dx => return .erf_dx
      | `neuronxcc.nki.language.exp | `numpy.exp => return .exp
      | `neuronxcc.nki.language.log | `numpy.log => return .log
      | `neuronxcc.nki.language.sin | `numpy.sin => return .sin
      | `neuronxcc.nki.language.arctan | `numpy.arctan => return .arctan
      | `neuronxcc.nki.language.sqrt | `numpy.sqrt => return .sqrt
      | `neuronxcc.nki.language.rsqrt => return .rsqrt
      | `neuronxcc.nki.language.reciprocal | `numpy.reciprocal => return .reciprocal
      | `neuronxcc.nki.language.sign | `numpy.sign => return .sign
      | `neuronxcc.nki.language.abs | `numpy.abs => return .abs
      | _ => err
    | _ => err


instance : FromNKI AccumCmd where
  fromNKI? t :=
    let err := .error "expecting activation function type"
    match t with
    | .var name =>
      match name with
      | `neuronxcc.nki.isa.reduce_cmd.idle => return .Idle
      | `neuronxcc.nki.isa.reduce_cmd.reset => return .Zero
      | `neuronxcc.nki.isa.reduce_cmd.reduce => return .Accumulate
      | `neuronxcc.nki.isa.reduce_cmd.reset_reduce => return .ZeroAccumulate
      -- Something should emit LoadAccumulate? Not sure what
      | _ => err
    | _ => err
