/-
Copyright (c) 2025 Amazon.com, Inc. or its affiliates. All Rights Reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Paul Govereau, Sean McLaughlin
-/
import Extract.Basic
import Extract.C
import KLR.Core
import KLR.File
import KLR.NKI.Basic
import KLR.Python
import KLR.Serde
import Lean

/-
Output functions for C++

Note: not too worried about formatting; will run clang-format on result.
-/
namespace Extract.Cpp
open Lean Meta

def varName : Name -> String
  | .str _ s => renameVar s
  | _ => panic! "bad name"
where
  renameVar : String -> String
  | "Bool" | "bool" => "boolean"
  | "Int" | "int" => "int32"
  | "Float" | "float" => "float32"
  | "String" | "string" => "str"
  | "Const" | "const" => "constant"
  | "register" => "reg"
  | s => s

def enumName (name : Name) : String := varName name

def unionName (name : Name) : String := (varName name).toLower


def cppName (name : Name) : String :=
  match name with
  | .str n s@⟨c :: _⟩ =>
    let s := s.replace "'" "_"
    if c.isUpper then s else
    match cppName n with
    | "" => s
    | s1 => s1 ++ s.capitalize
  | .anonymous => ""
  | _ => panic! s!"invalid CPP name {name}"

def subclassName (name : Name) : String := cppName name ++ "Wrapper"

def enumFullName : Name -> String
  | .str (.str _ a) b => a ++ "::" ++ b
  | .str _ s => s
  | .num n _ => enumFullName n
  | .anonymous => ""


instance : ToString Name where toString n := cppName n

-- Construct C++ type for a SimpleType.
def genType (t : SimpleType) : String :=
  match t with
  | .bool => "Bool"
  | .nat => "Nat"
  | .int => "Int"
  | .float => "Float"
  | .string => "String"
  | .prop => "Prop"
  | .const `Lean.Name => "String"
  | .const `KLR.Core.Reg => "Nat"
  | .const name => s!"Ptr<{name}>"
  | .enum name => s!"{name}"
  | .option t => s!"Option<{genType t}>"
  | .list t => s!"List<{genType t}>"
  | .pair .. => panic! "TODO"

private def genStruct (name : Name) (fields : List Field) : IO Unit := do
  IO.println s!"struct {name} final \{"
  fields.forM fun f => do
    let ty := genType f.type
    IO.println s!"  {ty} {f.name};"
  IO.println "};"

private def genEnum (name : Name) (variants : List LeanType) : IO Unit := do
  IO.println s!"enum class {name} \{"
  match variants with
  | [] => pure ()
  | v :: rest => do
    IO.println s!"{enumName v.name} = 1,"
    for v in rest do
      IO.println s!"{enumName v.name},"
    IO.println "};"

private def genUnion (name : Name) (variants : List LeanType) : MetaM Unit := do
  -- Generate base class for inductive
  let tagName := Name.str name "Tag"
  IO.println s!"struct {name} \{"
  genEnum tagName variants
  IO.println s!"  {tagName} tag;"
  IO.println s!"  {name}({tagName} tag) : tag(tag) \{}"
  IO.println "};"

  -- Generate subclasses
  for t in variants do
    let .prod n fs := t | throwError "unexpected union nesting"
    IO.println s!"\nstruct {subclassName n} final : {name} \{"
    for f in fs do
      IO.println s!"{genType f.type} {f.name};"
    IO.println s!" {subclassName n}() : {name}(Tag::{enumName t.name}) \{}"
    IO.println "};"

def genCppType (ty : LeanType) : MetaM Unit := do
  IO.println ""
  match ty with
  | .simple _ => pure ()
  | .prod name fields => genStruct name fields
  | .sum name variants =>
    if ty.isEnum
    then genEnum name variants
    else genUnion name variants

private def header (isH : Bool) (includes : List String := []) : String :=
  let inc := includes.map fun file => s!"#include \"{file}\""
  let inc := String.intercalate "\n" inc
s!"/*
Copyright (c) 2025 Amazon.com, Inc. or its affiliates. All Rights Reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Written by the KLR Contributors (https://github.com/leanprover/KLR)
*/
{if isH then "#pragma once\n" else ""}
// This file is automatically generated from KLR.
// Manual edits to this file will be overwritten.

#include \"klir_common.hpp\"
{inc}

namespace klr \{
"

def headerH (includes : List String := []) : String := header (isH := true) includes
def headerC (includes : List String := []) : String := header (isH := false) includes

private def genTypes (tys : List LeanType) : MetaM Unit :=
  for ty in tys do
    genCppType ty

def generateKlrAST : MetaM Unit := do
  IO.println (headerH [])
  IO.println "// KLR.Core Abstract Syntax"
  genTypes (<- C.commonAST)
  genTypes (<- C.klrAST)
  --IO.println "struct Python_Kernel {};"
  --IO.println "struct NKI_Kernel {};"
  -- Note: technically this generates incorrect code as it confuses the
  -- different Kernel types, however, we only care about the KLIR Kernel right now.
  -- TODO: fix this by qualifying the generated types, which we should do at some point.
  genTypes (<- C.fileAST)
  IO.println "}" -- TODO close namespace!

--run_meta generateKlrAST
