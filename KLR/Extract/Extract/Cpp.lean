/-
Copyright KLR Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

     https://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-/

import Extract.Basic
import KLR.Core
import KLR.File
import KLR.NKI.Basic
import KLR.Python
import KLR.Serde
import Lean

/-
Output functions for C++

Note: not too worried about formatting; will run clang-format on result.
-/
namespace Extract.Cpp
open Lean Meta

def varName : Name -> String
  | .str _ s => renameVar s
  | _ => panic! "bad name"
where
  renameVar : String -> String
  | "Bool" | "bool" => "boolean"
  | "Int" | "int" => "int32"
  | "Float" | "float" => "float32"
  | "String" | "string" => "str"
  | "Const" | "const" => "constant"
  | "register" => "reg"
  | s => s

def enumName (name : Name) : String := varName name

def unionName (name : Name) : String := (varName name).toLower


def cppName (name : Name) : String :=
  match name with
  | .str n s@⟨c :: _⟩ =>
    let s := s.replace "'" "_"
    if c.isUpper then s else
    match cppName n with
    | "" => s
    | s1 => s1 ++ s.capitalize
  | .anonymous => ""
  | _ => panic! s!"invalid CPP name {name}"

def subclassName (name : Name) : String := cppName name ++ "Wrapper"

def enumFullName : Name -> String
  | .str (.str _ a) b => a ++ "::" ++ b
  | .str _ s => s
  | .num n _ => enumFullName n
  | .anonymous => ""


instance : ToString Name where toString n := cppName n

-- Construct C++ type for a SimpleType.
def genType (t : SimpleType) : String :=
  match t with
  | .bool => "Bool"
  | .nat => "Nat"
  | .int => "Int"
  | .float => "Float"
  | .string => "String"
  | .prop => "Prop"
  | .const `Lean.Name => "String"
  | .const `KLR.Core.Reg => "Nat"
  | .const name => s!"Ptr<{name}>"
  | .enum name => s!"{name}"
  | .option t => s!"Option<{genType t}>"
  | .list t => s!"List<{genType t}>"
  | .pair .. => panic! "TODO"

private def genStruct (name : Name) (fields : List Field) : IO Unit := do
  IO.println s!"struct {name} final \{"
  fields.forM fun f => do
    let ty := genType f.type
    IO.println s!"  {ty} {f.name};"
  IO.println "};"

private def genEnum (name : Name) (variants : List LeanType) : IO Unit := do
  IO.println s!"enum class {name} \{"
  match variants with
  | [] => pure ()
  | v :: rest => do
    IO.println s!"{enumName v.name} = 1,"
    for v in rest do
      IO.println s!"{enumName v.name},"
    IO.println "};"

-- TODO We don't need MetaM everywhere
private def genUnion (name : Name) (variants : List LeanType) : MetaM Unit := do
  -- Generate base class for inductive
  let tagName := Name.str name "Tag"
  IO.println s!"struct {name} \{"
  genEnum tagName variants
  IO.println s!"  {tagName} tag;"
  IO.println s!"  {name}({tagName} tag) : tag(tag) \{}"
  IO.println "};"

  -- Generate subclasses
  for t in variants do
    let .prod n fs := t | throwError "unexpected union nesting"
    IO.println s!"\nstruct {subclassName n} final : {name} \{"
    for f in fs do
      IO.println s!"{genType f.type} {f.name};"
    IO.println s!" {subclassName n}() : {name}(Tag::{enumName t.name}) \{}"
    IO.println "};"

def genCppType (ty : LeanType) : MetaM Unit := do
  IO.println ""
  match ty with
  | .simple _ => pure ()
  | .prod name fields => genStruct name fields
  | .sum name variants =>
    if ty.isEnum
    then genEnum name variants
    else genUnion name variants

private def header (isH : Bool) (includes : List String := []) : String :=
  let inc := includes.map fun file => s!"#include \"{file}\""
  let inc := String.intercalate "\n" inc
s!"/*
Copyright (c) 2025 Amazon.com, Inc. or its affiliates. All Rights Reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Written by the KLR Contributors (https://github.com/leanprover/KLR)
*/
{if isH then "#pragma once\n" else ""}
// This file is automatically generated from KLR.
// Manual edits to this file will be overwritten.

#include \"klir_common.hpp\"
{inc}

namespace klr \{
"

def headerH (includes : List String := []) : String := header (isH := true) includes
def headerC (includes : List String := []) : String := header (isH := false) includes

private def genTypes (tys : List LeanType) : MetaM Unit :=
  for ty in tys do
    genCppType ty

def generateKlrAST : MetaM Unit := do
  IO.println (headerH [])
  IO.println "// KLR.Core Abstract Syntax"
  IO.println "struct Access;"
  genTypes (<- commonAST)
  genTypes (<- klrAST)
  --IO.println "struct Python_Kernel {};"
  --IO.println "struct NKI_Kernel {};"
  -- Note: technically this generates incorrect code as it confuses the
  -- different Kernel types, however, we only care about the KLIR Kernel right now.
  -- TODO: fix this by qualifying the generated types, which we should do at some point.
  genTypes (<- fileAST)
  IO.println "}" -- TODO close namespace!


--------------------- Section of Print Implementation -----------------------------

mutual
  -- Generate variable names with depth suffix for nested loops
  partial def genDepthVar (baseName : String) (depth : Nat) : String :=
    if depth = 0 then baseName else s!"{baseName}{depth}"

  partial def genListPrint(t: SimpleType) (variableName: String) (depth: Nat) : IO Unit := do
    IO.println s! "\{" -- open for loop scope to prevent i from being redeclared
    let indexVar := genDepthVar "i" depth
    let loopItemVar := genDepthVar "printListLoopItem" depth
    IO.println s!"size_t {indexVar} = 0;"
    IO.println s! "for ({genType t} {loopItemVar} : {variableName}) \{"
    genTypePrintImpl t loopItemVar depth
    IO.println s!" {indexVar}++;"
    IO.println s! " if ({indexVar} < {variableName}.size()) result += \", \";"
    IO.println s! "}"
    IO.println s! "}"

  partial def genOptionalPrint (t: SimpleType) (variableName: String) (depth: Nat) : IO Unit := do
    IO.println s!"if ({variableName}.has_value()) \{"
    genTypePrintImpl t s!"{variableName}.value()" depth
    IO.println s!"} else \{"
    IO.println s! "result += \"None\"; "
    IO.println s!"}"

  partial def genTypePrintImpl (t: SimpleType) (variableName: String) (depth: Nat) : IO Unit := do
    match t with
    | .bool => IO.println s!"result += std::to_string({variableName}); "
    | .nat => IO.println s!"result += std::to_string({variableName}); "
    | .int => IO.println s!"result += std::to_string({variableName}); "
    | .float => IO.println s!"result += std::to_string({variableName}); "
    | .string => IO.println s!"result += {variableName}; "
    | .prop => pure ()
    | .const `Lean.Name => IO.println s!"result += {variableName}; "
    | .const `KLR.Core.Reg => IO.println s!"result += std::to_string({variableName}); "
    | .const name => IO.println s!"result += to_string(*({variableName}.get())); "
    | .enum name => IO.println s!"result += to_string({variableName}); //mapped from enum"
    | .option t => genOptionalPrint t variableName depth
    | .list t => genListPrint t variableName (depth + 1)
    | .pair .. => panic! "Unprintable type"
end

def genTypePrint (t : SimpleType) (instanceName: String) (fieldName: Name) : IO Unit := do
  IO.println s!"result += \"{fieldName}=\";"
  genTypePrintImpl t s!"{instanceName}.{fieldName}" 0

private def genStructPrint (name : Name) (fields : List Field) : IO Unit := do
  IO.println s!"std::string to_string({name}& {name}Instance) \{"
  IO.println s!"std::string result; "
  IO.println s!"result += \"{name}(\";"
  match fields with
  | [] => pure ()
  | f :: rest => do
    genTypePrint f.type s!"{name}Instance" f.name
    for f in rest do
      IO.println s!"result += \", \";"
      genTypePrint f.type s!"{name}Instance" f.name
  IO.println s!"result += \")\";"
  IO.println "return result;"
  IO.println "};"

private def genEnumPrint (name : Name) (variants : List LeanType) : IO Unit := do
  IO.println s!"std::string to_string ({name}& {name}Instance) \{"
  match variants with
  | [] => IO.println s!"throw std::runtime_error(\"LOGIC FAULT: Nothing to print in enum {name}\");"
  | rest => do
    IO.println s!"switch ({name}Instance) \{"
    for v in rest do
      IO.println s!"case {name}::{enumName v.name}: "
      IO.println s!"return \"{enumName v.name}\"; "
      IO.println s!"break;"
    IO.println s!"default:"
    IO.println s!"  return \"UNABLE TO PRINT\"; "
    IO.println "}" -- end of switch
    IO.println "};" -- end of function

private def genUnionPrint (name : Name) (variants : List LeanType) : MetaM Unit := do
  -- Generate subclasses first
  for t in variants do
    let .prod n fs := t | throwError "unexpected union nesting"
    genStructPrint (Name.str name (subclassName n)) fs

  -- Generate base class for type matching
  IO.println s!"std::string to_string ({name}& {name}Instance) \{"

  IO.println s!"switch ({name}Instance.tag) \{"

  for t in variants do
    let .prod n fs := t | throwError "unexpected union nesting"
    IO.println s!" case ({name}::Tag::{enumName t.name}): \{"
    IO.println s!"   {subclassName n}& derivedRef = static_cast<{subclassName n}&>({name}Instance);"
    IO.println s!"   return to_string(derivedRef); }"
  IO.println s!"default:"
  IO.println s!"  return \"UNABLE TO PRINT\"; "

  IO.println "}" -- end switch stmt
  IO.println "};" -- end base function



def genCppTypePrint (ty : LeanType) : MetaM Unit := do
  IO.println ""
  match ty with
  | .simple _ => pure ()
  | .prod name fields => genStructPrint name fields
  -- | .prod name fields => pure () -- give up for now
  | .sum name variants =>
    if ty.isEnum
    then genEnumPrint name variants
    else genUnionPrint name variants

private def genPrintTypes (tys : List LeanType) : MetaM Unit :=
  for ty in tys do
    genCppTypePrint ty


def generateKlrPrettyPrint: MetaM Unit := do
  IO.println (headerC ["klir_ast.hpp", "klir_pretty_print.hpp"])
  IO.println "// Pretty Print functions for KLR.Core Abstract Syntax"
  genPrintTypes (<- commonAST)
  genPrintTypes (<- klrAST)
  genPrintTypes (<- fileAST)

  IO.println "}" -- close namespace!



--------------------- Section of Print Fucntion Header -----------------------------

private def genStructPrintHeader (name : Name) (fields : List Field) : IO Unit := do
  IO.println s!"std::string to_string({name}& {name}Instance);"

private def genEnumPrintHeader (name : Name) (variants : List LeanType) : IO Unit := do
  IO.println s!"std::string to_string ({name}& {name}Instance);"

private def genUnionPrintHeader (name : Name) (variants : List LeanType) : MetaM Unit := do
  -- Generate subclasses first
  for t in variants do
    let .prod n fs := t | throwError "unexpected union nesting"
    genStructPrintHeader (Name.str name (subclassName n)) fs

  -- Generate base class for type matching
  IO.println s!"std::string to_string ({name}& {name}Instance);"

def genCppTypePrintHeader (ty : LeanType) : MetaM Unit := do
  IO.println ""
  match ty with
  | .simple _ => pure ()
  | .prod name fields => genStructPrintHeader name fields
  -- | .prod name fields => pure () -- give up for now
  | .sum name variants =>
    if ty.isEnum
    then genEnumPrintHeader name variants
    else genUnionPrintHeader name variants

private def genPrintTypesHeader (tys : List LeanType) : MetaM Unit :=
  for ty in tys do
    genCppTypePrintHeader ty

def generateKlrPrettyPrintHeader: MetaM Unit := do
  IO.println (headerH ["klir_ast.hpp"])
  IO.println "// Pretty Print functions for KLR.Core Abstract Syntax"
  genPrintTypesHeader (<- commonAST)
  genPrintTypesHeader (<- klrAST)
  genPrintTypesHeader (<- fileAST)

  IO.println "}" -- close namespace!

--run_meta generateKlrAST
