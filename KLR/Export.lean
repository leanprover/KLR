/-
Copyright KLR Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

     https://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-/

import KLR.Python
import Lean

/-
This modules defines C export versions of inductive constructors. Both the Lean
definitions and the C header files are generated by the meta-programs in this
module.
-/

namespace KLR.Export
open Lean Meta

/-
Create a C-compatible name from a Lean Name

Note: We remove "'", replacing this with an empty string. This is a bit nicer
on the C side, and doesn't create and name conflicts for our types.
-/
private def Cname : Name -> String
  | .anonymous => ""
  | .str .anonymous s
  | .str `KLR s => s.replace "'" ""
  | .str n s => Cname n ++ "_" ++ s.replace "'" ""
  | .num n k => Cname n ++ "_" ++ toString k

/-
Create the C type which corresponds to a given Lean type.

Note: I have determined these by inspecting the output of the Lean compiler for
the types we have; this may not be generally correct.
-/
private def Ctype : Expr -> String
  | .const `Bool [] => "uint8_t"
  | .const `Float [] => "double"
  | .const `KLR.Python.Ctx []
  | .const `KLR.Python.BoolOp []
  | .const `KLR.Python.CmpOp []
  | .const `KLR.Python.UnaryOp []
  | .const `KLR.Python.BinOp [] => "uint8_t"
  | _ => "lean_object*"

/-
Generates a set of definitions of the form

  @[export X] def X := C

For each constructor, C, of an inductive type. As a side effect this function
will emit a C declaration for the function that will be generated by the Lean
compiler. For example, if you have:

  inductive I where | C : Bool -> Nat -> I

then we get a Lean definition:

  @[export I_C] def I_C := I.C

and a C declaration

  lean_object* I_C(uint8_t, lean_object*);

This code does not handle types with uninstantiated mvars.
-/
private def generate (name : Name) : MetaM Unit := do
  let mut isEnum := true
  let mut atoms : Array String := #[]
  let tci <- getConstInfoInduct name
  for c in tci.ctors do
    let ci <- getConstInfoCtor c
    let id := mkIdent (Cname c).toName
    let ts <- forallTelescopeReducing ci.type fun xs _ => do
      xs.mapM fun x => return Ctype (<- x.fvarId!.getDecl).type
    if ts.size > 0 then
      isEnum := false
      IO.println s!"lean_object* {Cname c}({",".intercalate ts.toList});"
    else
      atoms := atoms.push (Cname c)
    let cmd <- `(@[export $id] def $id := $(mkIdent c))
    liftCommandElabM (Elab.Command.elabCommand cmd)
  for a in atoms do
    if isEnum then
      IO.println s!"extern uint8_t {a};"
    else
      IO.println s!"extern lean_object* {a};"

/-
Search a namespace for all inductive definitions and generate externs for
each one.
-/
private def generateNamespace (name : Name) : MetaM Unit := do
  unless (<- getEnv).isNamespace name do
    throwError "{name} is not a namespace"
  for n in (<- getEnv).getNamespaceSet.toList do
    if name.isPrefixOf n && (<- isInductive n) then
      generate n

/-
Build extern definitions and C header file for types we need.
-/
run_meta
  let h <- IO.FS.Handle.mk "interop/klr/lean_ast.h" IO.FS.Mode.write
  IO.withStdout (.ofHandle h) do
    IO.println "#include <lean/lean.h>"
    generate `KLR.Core.Pos
    generateNamespace `KLR.Python
